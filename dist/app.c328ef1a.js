// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/@azure/core-auth/dist-esm/src/azureKeyCredential.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AzureKeyCredential = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A static-key-based credential that supports updating
 * the underlying key value.
 */
var AzureKeyCredential = exports.AzureKeyCredential = /*#__PURE__*/function () {
  /**
   * Create an instance of an AzureKeyCredential for use
   * with a service client.
   *
   * @param key - The initial value of the key to use in authentication
   */
  function AzureKeyCredential(key) {
    _classCallCheck(this, AzureKeyCredential);
    if (!key) {
      throw new Error("key must be a non-empty string");
    }
    this._key = key;
  }
  /**
   * Change the value of the key.
   *
   * Updates will take effect upon the next request after
   * updating the key value.
   *
   * @param newKey - The new key value to be used
   */
  _createClass(AzureKeyCredential, [{
    key: "key",
    get:
    /**
     * The value of the key to be used in authentication
     */
    function get() {
      return this._key;
    }
  }, {
    key: "update",
    value: function update(newKey) {
      this._key = newKey;
    }
  }]);
  return AzureKeyCredential;
}();
},{}],"node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbortSignal = void 0;
exports.abortSignal = abortSignal;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/// <reference path="../shims-public.d.ts" />
var listenersMap = new WeakMap();
var abortedMap = new WeakMap();
/**
 * An aborter instance implements AbortSignal interface, can abort HTTP requests.
 *
 * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.
 * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation
 * cannot or will not ever be cancelled.
 *
 * @example
 * Abort without timeout
 * ```ts
 * await doAsyncWork(AbortSignal.none);
 * ```
 */
var AbortSignal = exports.AbortSignal = /*#__PURE__*/function () {
  function AbortSignal() {
    _classCallCheck(this, AbortSignal);
    /**
     * onabort event listener.
     */
    this.onabort = null;
    listenersMap.set(this, []);
    abortedMap.set(this, false);
  }
  /**
   * Status of whether aborted or not.
   *
   * @readonly
   */
  _createClass(AbortSignal, [{
    key: "aborted",
    get: function get() {
      if (!abortedMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      return abortedMap.get(this);
    }
    /**
     * Creates a new AbortSignal instance that will never be aborted.
     *
     * @readonly
     */
  }, {
    key: "addEventListener",
    value:
    /**
     * Added new "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be added
     */
    function addEventListener(
    // tslint:disable-next-line:variable-name
    _type, listener) {
      if (!listenersMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      var listeners = listenersMap.get(this);
      listeners.push(listener);
    }
    /**
     * Remove "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be removed
     */
  }, {
    key: "removeEventListener",
    value: function removeEventListener(
    // tslint:disable-next-line:variable-name
    _type, listener) {
      if (!listenersMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      var listeners = listenersMap.get(this);
      var index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
    /**
     * Dispatches a synthetic event to the AbortSignal.
     */
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(_event) {
      throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
    }
  }], [{
    key: "none",
    get: function get() {
      return new AbortSignal();
    }
  }]);
  return AbortSignal;
}();
/**
 * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.
 * Will try to trigger abort event for all linked AbortSignal nodes.
 *
 * - If there is a timeout, the timer will be cancelled.
 * - If aborted is true, nothing will happen.
 *
 * @internal
 */
// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
function abortSignal(signal) {
  if (signal.aborted) {
    return;
  }
  if (signal.onabort) {
    signal.onabort.call(signal);
  }
  var listeners = listenersMap.get(signal);
  if (listeners) {
    // Create a copy of listeners so mutations to the array
    // (e.g. via removeListener calls) don't affect the listeners
    // we invoke.
    listeners.slice().forEach(function (listener) {
      listener.call(signal, {
        type: "abort"
      });
    });
  }
  abortedMap.set(signal, true);
}
},{}],"node_modules/@azure/abort-controller/dist-esm/src/AbortController.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbortError = exports.AbortController = void 0;
var _AbortSignal = require("./AbortSignal");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * This error is thrown when an asynchronous operation has been aborted.
 * Check for this error by testing the `name` that the name property of the
 * error matches `"AbortError"`.
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * controller.abort();
 * try {
 *   doAsyncWork(controller.signal)
 * } catch (e) {
 *   if (e.name === 'AbortError') {
 *     // handle abort error here.
 *   }
 * }
 * ```
 */
var AbortError = exports.AbortError = /*#__PURE__*/function (_Error) {
  _inherits(AbortError, _Error);
  var _super = _createSuper(AbortError);
  function AbortError(message) {
    var _this;
    _classCallCheck(this, AbortError);
    _this = _super.call(this, message);
    _this.name = "AbortError";
    return _this;
  }
  return _createClass(AbortError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * An AbortController provides an AbortSignal and the associated controls to signal
 * that an asynchronous operation should be aborted.
 *
 * @example
 * Abort an operation when another event fires
 * ```ts
 * const controller = new AbortController();
 * const signal = controller.signal;
 * doAsyncWork(signal);
 * button.addEventListener('click', () => controller.abort());
 * ```
 *
 * @example
 * Share aborter cross multiple operations in 30s
 * ```ts
 * // Upload the same data to 2 different data centers at the same time,
 * // abort another when any of them is finished
 * const controller = AbortController.withTimeout(30 * 1000);
 * doAsyncWork(controller.signal).then(controller.abort);
 * doAsyncWork(controller.signal).then(controller.abort);
 *```
 *
 * @example
 * Cascaded aborting
 * ```ts
 * // All operations can't take more than 30 seconds
 * const aborter = Aborter.timeout(30 * 1000);
 *
 * // Following 2 operations can't take more than 25 seconds
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * ```
 */
var AbortController = exports.AbortController = /*#__PURE__*/function () {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  function AbortController(parentSignals) {
    var _this2 = this;
    _classCallCheck(this, AbortController);
    this._signal = new _AbortSignal.AbortSignal();
    if (!parentSignals) {
      return;
    }
    // coerce parentSignals into an array
    if (!Array.isArray(parentSignals)) {
      // eslint-disable-next-line prefer-rest-params
      parentSignals = arguments;
    }
    var _iterator = _createForOfIteratorHelper(parentSignals),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var parentSignal = _step.value;
        // if the parent signal has already had abort() called,
        // then call abort on this signal as well.
        if (parentSignal.aborted) {
          this.abort();
        } else {
          // when the parent signal aborts, this signal should as well.
          parentSignal.addEventListener("abort", function () {
            _this2.abort();
          });
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * The AbortSignal associated with this controller that will signal aborted
   * when the abort method is called on this controller.
   *
   * @readonly
   */
  _createClass(AbortController, [{
    key: "signal",
    get: function get() {
      return this._signal;
    }
    /**
     * Signal that any operations passed this controller's associated abort signal
     * to cancel any remaining work and throw an `AbortError`.
     */
  }, {
    key: "abort",
    value: function abort() {
      (0, _AbortSignal.abortSignal)(this._signal);
    }
    /**
     * Creates a new AbortSignal instance that will abort after the provided ms.
     * @param ms - Elapsed time in milliseconds to trigger an abort.
     */
  }], [{
    key: "timeout",
    value: function timeout(ms) {
      var signal = new _AbortSignal.AbortSignal();
      var timer = setTimeout(_AbortSignal.abortSignal, ms, signal);
      // Prevent the active Timer from keeping the Node.js event loop active.
      if (typeof timer.unref === "function") {
        timer.unref();
      }
      return signal;
    }
  }]);
  return AbortController;
}();
},{"./AbortSignal":"node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js"}],"node_modules/@azure/abort-controller/dist-esm/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AbortController", {
  enumerable: true,
  get: function () {
    return _AbortController.AbortController;
  }
});
Object.defineProperty(exports, "AbortError", {
  enumerable: true,
  get: function () {
    return _AbortController.AbortError;
  }
});
Object.defineProperty(exports, "AbortSignal", {
  enumerable: true,
  get: function () {
    return _AbortSignal.AbortSignal;
  }
});
var _AbortController = require("./AbortController");
var _AbortSignal = require("./AbortSignal");
},{"./AbortController":"node_modules/@azure/abort-controller/dist-esm/src/AbortController.js","./AbortSignal":"node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js"}],"node_modules/@azure/core-util/dist-esm/src/createAbortablePromise.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAbortablePromise = createAbortablePromise;
var _abortController = require("@azure/abort-controller");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Creates an abortable promise.
 * @param buildPromise - A function that takes the resolve and reject functions as parameters.
 * @param options - The options for the abortable promise.
 * @returns A promise that can be aborted.
 */
function createAbortablePromise(buildPromise, options) {
  var _ref = options !== null && options !== void 0 ? options : {},
    cleanupBeforeAbort = _ref.cleanupBeforeAbort,
    abortSignal = _ref.abortSignal,
    abortErrorMsg = _ref.abortErrorMsg;
  return new Promise(function (resolve, reject) {
    function rejectOnAbort() {
      reject(new _abortController.AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : "The operation was aborted."));
    }
    function removeListeners() {
      abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", onAbort);
    }
    function onAbort() {
      cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 ? void 0 : cleanupBeforeAbort();
      removeListeners();
      rejectOnAbort();
    }
    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
      return rejectOnAbort();
    }
    try {
      buildPromise(function (x) {
        removeListeners();
        resolve(x);
      }, function (x) {
        removeListeners();
        reject(x);
      });
    } catch (err) {
      reject(err);
    }
    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", onAbort);
  });
}
},{"@azure/abort-controller":"node_modules/@azure/abort-controller/dist-esm/src/index.js"}],"node_modules/@azure/core-util/dist-esm/src/delay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.delay = delay;
var _createAbortablePromise = require("./createAbortablePromise");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var StandardAbortMessage = "The delay was aborted.";
/**
 * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.
 * @param timeInMs - The number of milliseconds to be delayed.
 * @param options - The options for delay - currently abort options
 * @returns Promise that is resolved after timeInMs
 */
function delay(timeInMs, options) {
  var token;
  var _ref = options !== null && options !== void 0 ? options : {},
    abortSignal = _ref.abortSignal,
    abortErrorMsg = _ref.abortErrorMsg;
  return (0, _createAbortablePromise.createAbortablePromise)(function (resolve) {
    token = setTimeout(resolve, timeInMs);
  }, {
    cleanupBeforeAbort: function cleanupBeforeAbort() {
      return clearTimeout(token);
    },
    abortSignal: abortSignal,
    abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage
  });
}
},{"./createAbortablePromise":"node_modules/@azure/core-util/dist-esm/src/createAbortablePromise.js"}],"node_modules/@azure/core-util/dist-esm/src/aborterUtils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cancelablePromiseRace = cancelablePromiseRace;
var _abortController = require("@azure/abort-controller");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * promise.race() wrapper that aborts rest of promises as soon as the first promise settles.
 */
function cancelablePromiseRace(_x, _x2) {
  return _cancelablePromiseRace.apply(this, arguments);
}
function _cancelablePromiseRace() {
  _cancelablePromiseRace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(abortablePromiseBuilders, options) {
    var _a, _b, aborter, abortHandler;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          abortHandler = function _abortHandler() {
            aborter.abort();
          };
          aborter = new _abortController.AbortController();
          (_a = options === null || options === void 0 ? void 0 : options.abortSignal) === null || _a === void 0 ? void 0 : _a.addEventListener("abort", abortHandler);
          _context.prev = 3;
          _context.next = 6;
          return Promise.race(abortablePromiseBuilders.map(function (p) {
            return p({
              abortSignal: aborter.signal
            });
          }));
        case 6:
          return _context.abrupt("return", _context.sent);
        case 7:
          _context.prev = 7;
          aborter.abort();
          (_b = options === null || options === void 0 ? void 0 : options.abortSignal) === null || _b === void 0 ? void 0 : _b.removeEventListener("abort", abortHandler);
          return _context.finish(7);
        case 11:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[3,, 7, 11]]);
  }));
  return _cancelablePromiseRace.apply(this, arguments);
}
},{"@azure/abort-controller":"node_modules/@azure/abort-controller/dist-esm/src/index.js"}],"node_modules/@azure/core-util/dist-esm/src/random.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Returns a random integer value between a lower and upper bound,
 * inclusive of both bounds.
 * Note that this uses Math.random and isn't secure. If you need to use
 * this for any kind of security purpose, find a better source of random.
 * @param min - The smallest integer value allowed.
 * @param max - The largest integer value allowed.
 */
function getRandomIntegerInclusive(min, max) {
  // Make sure inputs are integers.
  min = Math.ceil(min);
  max = Math.floor(max);
  // Pick a random offset from zero to the size of the range.
  // Since Math.random() can never return 1, we have to make the range one larger
  // in order to be inclusive of the maximum value after we take the floor.
  var offset = Math.floor(Math.random() * (max - min + 1));
  return offset + min;
}
},{}],"node_modules/@azure/core-util/dist-esm/src/object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObject = isObject;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper to determine when an input is a generic JS object.
 * @returns true when input is an object type that is not null, Array, RegExp, or Date.
 */
function isObject(input) {
  return _typeof(input) === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}
},{}],"node_modules/@azure/core-util/dist-esm/src/error.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getErrorMessage = getErrorMessage;
exports.isError = isError;
var _object = require("./object");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Typeguard for an error object shape (has name and message)
 * @param e - Something caught by a catch clause.
 */
function isError(e) {
  if ((0, _object.isObject)(e)) {
    var hasName = typeof e.name === "string";
    var hasMessage = typeof e.message === "string";
    return hasName && hasMessage;
  }
  return false;
}
/**
 * Given what is thought to be an error object, return the message if possible.
 * If the message is missing, returns a stringified version of the input.
 * @param e - Something thrown from a try block
 * @returns The error message or a string of the input
 */
function getErrorMessage(e) {
  if (isError(e)) {
    return e.message;
  } else {
    var stringified;
    try {
      if (_typeof(e) === "object" && e) {
        stringified = JSON.stringify(e);
      } else {
        stringified = String(e);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return "Unknown error ".concat(stringified);
  }
}
},{"./object":"node_modules/@azure/core-util/dist-esm/src/object.js"}],"node_modules/@azure/core-util/dist-esm/src/bytesEncoding.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.base64ToUint8Array = base64ToUint8Array;
exports.base64UrlToUint8Array = base64UrlToUint8Array;
exports.hexStringToUint8Array = hexStringToUint8Array;
exports.stringToUint8Array = stringToUint8Array;
exports.uint8ArrayToBase64 = uint8ArrayToBase64;
exports.uint8ArrayToBase64Url = uint8ArrayToBase64Url;
exports.uint8ArrayToHexString = uint8ArrayToHexString;
exports.uint8ArrayToString = uint8ArrayToString;
exports.uint8ArrayToUtf8String = uint8ArrayToUtf8String;
exports.utf8StringToUint8Array = utf8StringToUint8Array;
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The helper that transforms bytes with specific character encoding into string
 * @param bytes - the uint8array bytes
 * @param format - the format we use to encode the byte
 * @returns a string of the encoded string
 */
function uint8ArrayToString(bytes, format) {
  switch (format) {
    case "utf-8":
      return uint8ArrayToUtf8String(bytes);
    case "base64":
      return uint8ArrayToBase64(bytes);
    case "base64url":
      return uint8ArrayToBase64Url(bytes);
    case "hex":
      return uint8ArrayToHexString(bytes);
  }
}
/**
 * The helper that transforms string to specific character encoded bytes array.
 * @param value - the string to be converted
 * @param format - the format we use to decode the value
 * @returns a uint8array
 */
function stringToUint8Array(value, format) {
  switch (format) {
    case "utf-8":
      return utf8StringToUint8Array(value);
    case "base64":
      return base64ToUint8Array(value);
    case "base64url":
      return base64UrlToUint8Array(value);
    case "hex":
      return hexStringToUint8Array(value);
  }
}
/**
 * Decodes a Uint8Array into a Base64 string.
 * @internal
 */
function uint8ArrayToBase64(bytes) {
  return btoa(_toConsumableArray(bytes).map(function (x) {
    return String.fromCharCode(x);
  }).join(""));
}
/**
 * Decodes a Uint8Array into a Base64Url string.
 * @internal
 */
function uint8ArrayToBase64Url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
/**
 * Decodes a Uint8Array into a javascript string.
 * @internal
 */
function uint8ArrayToUtf8String(bytes) {
  var decoder = new TextDecoder();
  var dataString = decoder.decode(bytes);
  return dataString;
}
/**
 * Decodes a Uint8Array into a hex string
 * @internal
 */
function uint8ArrayToHexString(bytes) {
  return _toConsumableArray(bytes).map(function (x) {
    return x.toString(16).padStart(2, "0");
  }).join("");
}
/**
 * Encodes a JavaScript string into a Uint8Array.
 * @internal
 */
function utf8StringToUint8Array(value) {
  return new TextEncoder().encode(value);
}
/**
 * Encodes a Base64 string into a Uint8Array.
 * @internal
 */
function base64ToUint8Array(value) {
  return new Uint8Array(_toConsumableArray(atob(value)).map(function (x) {
    return x.charCodeAt(0);
  }));
}
/**
 * Encodes a Base64Url string into a Uint8Array.
 * @internal
 */
function base64UrlToUint8Array(value) {
  var base64String = value.replace(/-/g, "+").replace(/_/g, "/");
  return base64ToUint8Array(base64String);
}
var hexDigits = new Set("0123456789abcdefABCDEF");
/**
 * Encodes a hex string into a Uint8Array
 * @internal
 */
function hexStringToUint8Array(value) {
  // If value has odd length, the last character will be ignored, consistent with NodeJS Buffer behavior
  var bytes = new Uint8Array(value.length / 2);
  for (var i = 0; i < value.length / 2; ++i) {
    var highNibble = value[2 * i];
    var lowNibble = value[2 * i + 1];
    if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) {
      // Replicate Node Buffer behavior by exiting early when we encounter an invalid byte
      return bytes.slice(0, i);
    }
    bytes[i] = parseInt("".concat(highNibble).concat(lowNibble), 16);
  }
  return bytes;
}
},{}],"node_modules/@azure/core-util/dist-esm/src/sha256.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeSha256Hash = computeSha256Hash;
exports.computeSha256Hmac = computeSha256Hmac;
var _bytesEncoding = require("./bytesEncoding.browser");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var subtleCrypto;
/**
 * Returns a cached reference to the Web API crypto.subtle object.
 * @internal
 */
function getCrypto() {
  if (subtleCrypto) {
    return subtleCrypto;
  }
  if (!self.crypto || !self.crypto.subtle) {
    throw new Error("Your browser environment does not support cryptography functions.");
  }
  subtleCrypto = self.crypto.subtle;
  return subtleCrypto;
}
/**
 * Generates a SHA-256 HMAC signature.
 * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
 * @param stringToSign - The data to be signed.
 * @param encoding - The textual encoding to use for the returned HMAC digest.
 */
function computeSha256Hmac(_x, _x2, _x3) {
  return _computeSha256Hmac.apply(this, arguments);
}
/**
 * Generates a SHA-256 hash.
 * @param content - The data to be included in the hash.
 * @param encoding - The textual encoding to use for the returned hash.
 */
function _computeSha256Hmac() {
  _computeSha256Hmac = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, stringToSign, encoding) {
    var crypto, keyBytes, stringToSignBytes, cryptoKey, signature;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          crypto = getCrypto();
          keyBytes = (0, _bytesEncoding.stringToUint8Array)(key, "base64");
          stringToSignBytes = (0, _bytesEncoding.stringToUint8Array)(stringToSign, "utf-8");
          _context.next = 5;
          return crypto.importKey("raw", keyBytes, {
            name: "HMAC",
            hash: {
              name: "SHA-256"
            }
          }, false, ["sign"]);
        case 5:
          cryptoKey = _context.sent;
          _context.next = 8;
          return crypto.sign({
            name: "HMAC",
            hash: {
              name: "SHA-256"
            }
          }, cryptoKey, stringToSignBytes);
        case 8:
          signature = _context.sent;
          return _context.abrupt("return", (0, _bytesEncoding.uint8ArrayToString)(new Uint8Array(signature), encoding));
        case 10:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _computeSha256Hmac.apply(this, arguments);
}
function computeSha256Hash(_x4, _x5) {
  return _computeSha256Hash.apply(this, arguments);
}
function _computeSha256Hash() {
  _computeSha256Hash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(content, encoding) {
    var contentBytes, digest;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          contentBytes = (0, _bytesEncoding.stringToUint8Array)(content, "utf-8");
          _context2.next = 3;
          return getCrypto().digest({
            name: "SHA-256"
          }, contentBytes);
        case 3:
          digest = _context2.sent;
          return _context2.abrupt("return", (0, _bytesEncoding.uint8ArrayToString)(new Uint8Array(digest), encoding));
        case 5:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _computeSha256Hash.apply(this, arguments);
}
},{"./bytesEncoding.browser":"node_modules/@azure/core-util/dist-esm/src/bytesEncoding.browser.js"}],"node_modules/@azure/core-util/dist-esm/src/typeGuards.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDefined = isDefined;
exports.isObjectWithProperties = isObjectWithProperties;
exports.objectHasProperty = objectHasProperty;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 */
function isDefined(thing) {
  return typeof thing !== "undefined" && thing !== null;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified properties.
 * @param thing - Anything.
 * @param properties - The name of the properties that should appear in the object.
 */
function isObjectWithProperties(thing, properties) {
  if (!isDefined(thing) || _typeof(thing) !== "object") {
    return false;
  }
  var _iterator = _createForOfIteratorHelper(properties),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;
      if (!objectHasProperty(thing, property)) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return true;
}
/**
 * Helper TypeGuard that checks if the input is an object with the specified property.
 * @param thing - Any object.
 * @param property - The name of the property that should appear in the object.
 */
function objectHasProperty(thing, property) {
  return isDefined(thing) && _typeof(thing) === "object" && property in thing;
}
},{}],"node_modules/@azure/core-util/dist-esm/src/uuidUtils.native.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateUUID = generateUUID;
exports.randomUUID = randomUUID;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*
 * NOTE: When moving this file, please update "react-native" section in package.json.
 */
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 */
function generateUUID() {
  var uuid = "";
  for (var i = 0; i < 32; i++) {
    // Generate a random number between 0 and 15
    var randomNumber = Math.floor(Math.random() * 16);
    // Set the UUID version to 4 in the 13th position
    if (i === 12) {
      uuid += "4";
    } else if (i === 16) {
      // Set the UUID variant to "10" in the 17th position
      uuid += randomNumber & 0x3 | 0x8;
    } else {
      // Add a random hexadecimal digit to the UUID string
      uuid += randomNumber.toString(16);
    }
    // Add hyphens to the UUID string at the appropriate positions
    if (i === 7 || i === 11 || i === 15 || i === 19) {
      uuid += "-";
    }
  }
  return uuid;
}
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 */
function randomUUID() {
  return generateUUID();
}
},{}],"node_modules/@azure/core-util/dist-esm/src/uuidUtils.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomUUID = randomUUID;
var _uuidUtils = require("./uuidUtils.native");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var _a;
// NOTE: This could be undefined if not used in a secure context
var uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : _uuidUtils.generateUUID;
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 */
function randomUUID() {
  return uuidFunction();
}
},{"./uuidUtils.native":"node_modules/@azure/core-util/dist-esm/src/uuidUtils.native.js"}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};
},{}],"node_modules/@azure/core-util/dist-esm/src/checkEnvironment.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWebWorker = exports.isReactNative = exports.isNode = exports.isDeno = exports.isBun = exports.isBrowser = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var _a, _b, _c, _d;
/**
 * A constant that indicates whether the environment the code is running is a Web Browser.
 */
// eslint-disable-next-line @azure/azure-sdk/ts-no-window
var isBrowser = exports.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
/**
 * A constant that indicates whether the environment the code is running is a Web Worker.
 */
var isWebWorker = exports.isWebWorker = (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_a = self.constructor) === null || _a === void 0 ? void 0 : _a.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "SharedWorkerGlobalScope");
/**
 * A constant that indicates whether the environment the code is running is Deno.
 */
var isDeno = exports.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
/**
 * A constant that indicates whether the environment the code is running is Node.JS.
 */
var isNode = exports.isNode = typeof process !== "undefined" && Boolean(process.version) && Boolean((_d = process.versions) === null || _d === void 0 ? void 0 : _d.node) &&
// Deno thought it was a good idea to spoof process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
!isDeno;
/**
 * A constant that indicates whether the environment the code is running is Bun.sh.
 */
var isBun = exports.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
/**
 * A constant that indicates whether the environment the code is running is in React-Native.
 */
// https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
var isReactNative = exports.isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
},{"process":"node_modules/process/browser.js"}],"node_modules/@azure/core-util/dist-esm/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "cancelablePromiseRace", {
  enumerable: true,
  get: function () {
    return _aborterUtils.cancelablePromiseRace;
  }
});
Object.defineProperty(exports, "computeSha256Hash", {
  enumerable: true,
  get: function () {
    return _sha.computeSha256Hash;
  }
});
Object.defineProperty(exports, "computeSha256Hmac", {
  enumerable: true,
  get: function () {
    return _sha.computeSha256Hmac;
  }
});
Object.defineProperty(exports, "createAbortablePromise", {
  enumerable: true,
  get: function () {
    return _createAbortablePromise.createAbortablePromise;
  }
});
Object.defineProperty(exports, "delay", {
  enumerable: true,
  get: function () {
    return _delay.delay;
  }
});
Object.defineProperty(exports, "getErrorMessage", {
  enumerable: true,
  get: function () {
    return _error.getErrorMessage;
  }
});
Object.defineProperty(exports, "getRandomIntegerInclusive", {
  enumerable: true,
  get: function () {
    return _random.getRandomIntegerInclusive;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function () {
    return _checkEnvironment.isBrowser;
  }
});
Object.defineProperty(exports, "isBun", {
  enumerable: true,
  get: function () {
    return _checkEnvironment.isBun;
  }
});
Object.defineProperty(exports, "isDefined", {
  enumerable: true,
  get: function () {
    return _typeGuards.isDefined;
  }
});
Object.defineProperty(exports, "isDeno", {
  enumerable: true,
  get: function () {
    return _checkEnvironment.isDeno;
  }
});
Object.defineProperty(exports, "isError", {
  enumerable: true,
  get: function () {
    return _error.isError;
  }
});
Object.defineProperty(exports, "isNode", {
  enumerable: true,
  get: function () {
    return _checkEnvironment.isNode;
  }
});
Object.defineProperty(exports, "isObject", {
  enumerable: true,
  get: function () {
    return _object.isObject;
  }
});
Object.defineProperty(exports, "isObjectWithProperties", {
  enumerable: true,
  get: function () {
    return _typeGuards.isObjectWithProperties;
  }
});
Object.defineProperty(exports, "isReactNative", {
  enumerable: true,
  get: function () {
    return _checkEnvironment.isReactNative;
  }
});
Object.defineProperty(exports, "isWebWorker", {
  enumerable: true,
  get: function () {
    return _checkEnvironment.isWebWorker;
  }
});
Object.defineProperty(exports, "objectHasProperty", {
  enumerable: true,
  get: function () {
    return _typeGuards.objectHasProperty;
  }
});
Object.defineProperty(exports, "randomUUID", {
  enumerable: true,
  get: function () {
    return _uuidUtils.randomUUID;
  }
});
Object.defineProperty(exports, "stringToUint8Array", {
  enumerable: true,
  get: function () {
    return _bytesEncoding.stringToUint8Array;
  }
});
Object.defineProperty(exports, "uint8ArrayToString", {
  enumerable: true,
  get: function () {
    return _bytesEncoding.uint8ArrayToString;
  }
});
var _delay = require("./delay");
var _aborterUtils = require("./aborterUtils");
var _createAbortablePromise = require("./createAbortablePromise");
var _random = require("./random");
var _object = require("./object");
var _error = require("./error");
var _sha = require("./sha256");
var _typeGuards = require("./typeGuards");
var _uuidUtils = require("./uuidUtils");
var _checkEnvironment = require("./checkEnvironment");
var _bytesEncoding = require("./bytesEncoding");
},{"./delay":"node_modules/@azure/core-util/dist-esm/src/delay.js","./aborterUtils":"node_modules/@azure/core-util/dist-esm/src/aborterUtils.js","./createAbortablePromise":"node_modules/@azure/core-util/dist-esm/src/createAbortablePromise.js","./random":"node_modules/@azure/core-util/dist-esm/src/random.js","./object":"node_modules/@azure/core-util/dist-esm/src/object.js","./error":"node_modules/@azure/core-util/dist-esm/src/error.js","./sha256":"node_modules/@azure/core-util/dist-esm/src/sha256.browser.js","./typeGuards":"node_modules/@azure/core-util/dist-esm/src/typeGuards.js","./uuidUtils":"node_modules/@azure/core-util/dist-esm/src/uuidUtils.browser.js","./checkEnvironment":"node_modules/@azure/core-util/dist-esm/src/checkEnvironment.js","./bytesEncoding":"node_modules/@azure/core-util/dist-esm/src/bytesEncoding.browser.js"}],"node_modules/@azure/core-auth/dist-esm/src/azureNamedKeyCredential.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AzureNamedKeyCredential = void 0;
exports.isNamedKeyCredential = isNamedKeyCredential;
var _coreUtil = require("@azure/core-util");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A static name/key-based credential that supports updating
 * the underlying name and key values.
 */
var AzureNamedKeyCredential = exports.AzureNamedKeyCredential = /*#__PURE__*/function () {
  /**
   * Create an instance of an AzureNamedKeyCredential for use
   * with a service client.
   *
   * @param name - The initial value of the name to use in authentication.
   * @param key - The initial value of the key to use in authentication.
   */
  function AzureNamedKeyCredential(name, key) {
    _classCallCheck(this, AzureNamedKeyCredential);
    if (!name || !key) {
      throw new TypeError("name and key must be non-empty strings");
    }
    this._name = name;
    this._key = key;
  }
  /**
   * Change the value of the key.
   *
   * Updates will take effect upon the next request after
   * updating the key value.
   *
   * @param newName - The new name value to be used.
   * @param newKey - The new key value to be used.
   */
  _createClass(AzureNamedKeyCredential, [{
    key: "key",
    get:
    /**
     * The value of the key to be used in authentication.
     */
    function get() {
      return this._key;
    }
    /**
     * The value of the name to be used in authentication.
     */
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
  }, {
    key: "update",
    value: function update(newName, newKey) {
      if (!newName || !newKey) {
        throw new TypeError("newName and newKey must be non-empty strings");
      }
      this._name = newName;
      this._key = newKey;
    }
  }]);
  return AzureNamedKeyCredential;
}();
/**
 * Tests an object to determine whether it implements NamedKeyCredential.
 *
 * @param credential - The assumed NamedKeyCredential to be tested.
 */
function isNamedKeyCredential(credential) {
  return (0, _coreUtil.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
}
},{"@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js"}],"node_modules/@azure/core-auth/dist-esm/src/azureSASCredential.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AzureSASCredential = void 0;
exports.isSASCredential = isSASCredential;
var _coreUtil = require("@azure/core-util");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A static-signature-based credential that supports updating
 * the underlying signature value.
 */
var AzureSASCredential = exports.AzureSASCredential = /*#__PURE__*/function () {
  /**
   * Create an instance of an AzureSASCredential for use
   * with a service client.
   *
   * @param signature - The initial value of the shared access signature to use in authentication
   */
  function AzureSASCredential(signature) {
    _classCallCheck(this, AzureSASCredential);
    if (!signature) {
      throw new Error("shared access signature must be a non-empty string");
    }
    this._signature = signature;
  }
  /**
   * Change the value of the signature.
   *
   * Updates will take effect upon the next request after
   * updating the signature value.
   *
   * @param newSignature - The new shared access signature value to be used
   */
  _createClass(AzureSASCredential, [{
    key: "signature",
    get:
    /**
     * The value of the shared access signature to be used in authentication
     */
    function get() {
      return this._signature;
    }
  }, {
    key: "update",
    value: function update(newSignature) {
      if (!newSignature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = newSignature;
    }
  }]);
  return AzureSASCredential;
}();
/**
 * Tests an object to determine whether it implements SASCredential.
 *
 * @param credential - The assumed SASCredential to be tested.
 */
function isSASCredential(credential) {
  return (0, _coreUtil.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
}
},{"@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js"}],"node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTokenCredential = isTokenCredential;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tests an object to determine whether it implements TokenCredential.
 *
 * @param credential - The assumed TokenCredential to be tested.
 */
function isTokenCredential(credential) {
  // Check for an object with a 'getToken' function and possibly with
  // a 'signRequest' function.  We do this check to make sure that
  // a ServiceClientCredentials implementor (like TokenClientCredentials
  // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
  // it doesn't actually implement TokenCredential also.
  var castCredential = credential;
  return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === undefined || castCredential.getToken.length > 0);
}
},{}],"node_modules/@azure/core-auth/dist-esm/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AzureKeyCredential", {
  enumerable: true,
  get: function () {
    return _azureKeyCredential.AzureKeyCredential;
  }
});
Object.defineProperty(exports, "AzureNamedKeyCredential", {
  enumerable: true,
  get: function () {
    return _azureNamedKeyCredential.AzureNamedKeyCredential;
  }
});
Object.defineProperty(exports, "AzureSASCredential", {
  enumerable: true,
  get: function () {
    return _azureSASCredential.AzureSASCredential;
  }
});
Object.defineProperty(exports, "isNamedKeyCredential", {
  enumerable: true,
  get: function () {
    return _azureNamedKeyCredential.isNamedKeyCredential;
  }
});
Object.defineProperty(exports, "isSASCredential", {
  enumerable: true,
  get: function () {
    return _azureSASCredential.isSASCredential;
  }
});
Object.defineProperty(exports, "isTokenCredential", {
  enumerable: true,
  get: function () {
    return _tokenCredential.isTokenCredential;
  }
});
var _azureKeyCredential = require("./azureKeyCredential");
var _azureNamedKeyCredential = require("./azureNamedKeyCredential");
var _azureSASCredential = require("./azureSASCredential");
var _tokenCredential = require("./tokenCredential");
},{"./azureKeyCredential":"node_modules/@azure/core-auth/dist-esm/src/azureKeyCredential.js","./azureNamedKeyCredential":"node_modules/@azure/core-auth/dist-esm/src/azureNamedKeyCredential.js","./azureSASCredential":"node_modules/@azure/core-auth/dist-esm/src/azureSASCredential.js","./tokenCredential":"node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js"}],"node_modules/jwt-decode/build/jwt-decode.esm.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InvalidTokenError = n;
exports.default = void 0;
function e(e) {
  this.message = e;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function (r) {
  var t = String(r).replace(/=+$/, "");
  if (t.length % 4 == 1) throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n, o, a = 0, i = 0, c = ""; o = t.charAt(i++); ~o && (n = a % 4 ? 64 * n + o : o, a++ % 4) ? c += String.fromCharCode(255 & n >> (-2 * a & 6)) : 0) o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);
  return c;
};
function t(e) {
  var t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function (e) {
      return decodeURIComponent(r(e).replace(/(.)/g, function (e, r) {
        var t = r.charCodeAt(0).toString(16).toUpperCase();
        return t.length < 2 && (t = "0" + t), "%" + t;
      }));
    }(t);
  } catch (e) {
    return r(t);
  }
}
function n(e) {
  this.message = e;
}
function o(e, r) {
  if ("string" != typeof e) throw new n("Invalid token specified");
  var o = !0 === (r = r || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e.split(".")[o]));
  } catch (e) {
    throw new n("Invalid token specified: " + e.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
var _default = exports.default = o;
},{}],"node_modules/@azure/communication-common/dist-esm/src/tokenParser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseToken = void 0;
var _jwtDecode2 = _interopRequireDefault(require("jwt-decode"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var parseToken = exports.parseToken = function parseToken(token) {
  var _jwtDecode = (0, _jwtDecode2.default)(token),
    exp = _jwtDecode.exp;
  return {
    token: token,
    expiresOnTimestamp: exp * 1000
  };
};
},{"jwt-decode":"node_modules/jwt-decode/build/jwt-decode.esm.js"}],"node_modules/@azure/communication-common/dist-esm/src/autoRefreshTokenCredential.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AutoRefreshTokenCredential = void 0;
var _tokenParser = require("./tokenParser");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var expiredToken = {
  token: "",
  expiresOnTimestamp: -10
};
var minutesToMs = function minutesToMs(minutes) {
  return minutes * 1000 * 60;
};
var defaultExpiringSoonInterval = minutesToMs(10);
var defaultRefreshAfterLifetimePercentage = 0.5;
var AutoRefreshTokenCredential = exports.AutoRefreshTokenCredential = /*#__PURE__*/function () {
  function AutoRefreshTokenCredential(refreshArgs) {
    _classCallCheck(this, AutoRefreshTokenCredential);
    this.expiringSoonIntervalInMs = defaultExpiringSoonInterval;
    this.refreshAfterLifetimePercentage = defaultRefreshAfterLifetimePercentage;
    this.activeTokenFetching = null;
    this.activeTokenUpdating = null;
    this.disposed = false;
    var tokenRefresher = refreshArgs.tokenRefresher,
      token = refreshArgs.token,
      refreshProactively = refreshArgs.refreshProactively;
    this.refresh = tokenRefresher;
    this.currentToken = token ? (0, _tokenParser.parseToken)(token) : expiredToken;
    this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;
    if (this.refreshProactively) {
      this.scheduleRefresh();
    }
  }
  _createClass(AutoRefreshTokenCredential, [{
    key: "getToken",
    value: function () {
      var _getToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
        var updatePromise;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.isTokenExpiringSoon(this.currentToken)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", this.currentToken);
            case 2:
              if (this.isTokenValid(this.currentToken)) {
                _context.next = 6;
                break;
              }
              updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
              _context.next = 6;
              return updatePromise;
            case 6:
              return _context.abrupt("return", this.currentToken);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getToken(_x) {
        return _getToken.apply(this, arguments);
      }
      return getToken;
    }()
  }, {
    key: "dispose",
    value: function dispose() {
      this.disposed = true;
      this.activeTokenFetching = null;
      this.activeTokenUpdating = null;
      this.currentToken = expiredToken;
      if (this.activeTimeout) {
        clearTimeout(this.activeTimeout);
      }
    }
  }, {
    key: "updateTokenAndReschedule",
    value: function () {
      var _updateTokenAndReschedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(abortSignal) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!this.activeTokenUpdating) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return", this.activeTokenUpdating);
            case 2:
              this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
              _context2.prev = 3;
              _context2.next = 6;
              return this.activeTokenUpdating;
            case 6:
              _context2.prev = 6;
              this.activeTokenUpdating = null;
              return _context2.finish(6);
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[3,, 6, 9]]);
      }));
      function updateTokenAndReschedule(_x2) {
        return _updateTokenAndReschedule.apply(this, arguments);
      }
      return updateTokenAndReschedule;
    }()
  }, {
    key: "refreshTokenAndReschedule",
    value: function () {
      var _refreshTokenAndReschedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(abortSignal) {
        var newToken;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.refreshToken(abortSignal);
            case 2:
              newToken = _context3.sent;
              if (this.isTokenValid(newToken)) {
                _context3.next = 5;
                break;
              }
              throw new Error("The token returned from the tokenRefresher is expired.");
            case 5:
              this.currentToken = newToken;
              if (this.refreshProactively) {
                this.scheduleRefresh();
              }
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function refreshTokenAndReschedule(_x3) {
        return _refreshTokenAndReschedule.apply(this, arguments);
      }
      return refreshTokenAndReschedule;
    }()
  }, {
    key: "refreshToken",
    value: function () {
      var _refreshToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(abortSignal) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              if (!this.activeTokenFetching) {
                this.activeTokenFetching = this.refresh(abortSignal);
              }
              _context4.t0 = _tokenParser.parseToken;
              _context4.next = 5;
              return this.activeTokenFetching;
            case 5:
              _context4.t1 = _context4.sent;
              return _context4.abrupt("return", (0, _context4.t0)(_context4.t1));
            case 7:
              _context4.prev = 7;
              this.activeTokenFetching = null;
              return _context4.finish(7);
            case 10:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[0,, 7, 10]]);
      }));
      function refreshToken(_x4) {
        return _refreshToken.apply(this, arguments);
      }
      return refreshToken;
    }()
  }, {
    key: "scheduleRefresh",
    value: function scheduleRefresh() {
      var _this = this;
      if (this.disposed) {
        return;
      }
      if (this.activeTimeout) {
        clearTimeout(this.activeTimeout);
      }
      var tokenTtlInMs = this.currentToken.expiresOnTimestamp - Date.now();
      var timespanInMs = null;
      if (this.isTokenExpiringSoon(this.currentToken)) {
        // Schedule the next refresh for when it reaches a certain percentage of the remaining lifetime.
        timespanInMs = tokenTtlInMs * this.refreshAfterLifetimePercentage;
      } else {
        // Schedule the next refresh for when it gets in to the soon-to-expire window.
        timespanInMs = tokenTtlInMs - this.expiringSoonIntervalInMs;
      }
      this.activeTimeout = setTimeout(function () {
        return _this.updateTokenAndReschedule();
      }, timespanInMs);
    }
  }, {
    key: "isTokenValid",
    value: function isTokenValid(token) {
      return token && Date.now() < token.expiresOnTimestamp;
    }
  }, {
    key: "isTokenExpiringSoon",
    value: function isTokenExpiringSoon(token) {
      return !token || Date.now() >= token.expiresOnTimestamp - this.expiringSoonIntervalInMs;
    }
  }]);
  return AutoRefreshTokenCredential;
}();
},{"./tokenParser":"node_modules/@azure/communication-common/dist-esm/src/tokenParser.js"}],"node_modules/@azure/communication-common/dist-esm/src/staticTokenCredential.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StaticTokenCredential = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * StaticTokenCredential
 */
var StaticTokenCredential = exports.StaticTokenCredential = /*#__PURE__*/function () {
  function StaticTokenCredential(token) {
    _classCallCheck(this, StaticTokenCredential);
    this.token = token;
  }
  _createClass(StaticTokenCredential, [{
    key: "getToken",
    value: function () {
      var _getToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.token);
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getToken() {
        return _getToken.apply(this, arguments);
      }
      return getToken;
    }()
  }, {
    key: "dispose",
    value: function dispose() {
      /* intentionally empty */
    }
  }]);
  return StaticTokenCredential;
}();
},{}],"node_modules/@azure/communication-common/dist-esm/src/azureCommunicationTokenCredential.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AzureCommunicationTokenCredential = void 0;
var _autoRefreshTokenCredential = require("./autoRefreshTokenCredential");
var _staticTokenCredential = require("./staticTokenCredential");
var _tokenParser = require("./tokenParser");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The CommunicationTokenCredential implementation with support for proactive token refresh.
 */
var AzureCommunicationTokenCredential = exports.AzureCommunicationTokenCredential = /*#__PURE__*/function () {
  function AzureCommunicationTokenCredential(tokenOrRefreshOptions) {
    _classCallCheck(this, AzureCommunicationTokenCredential);
    this.disposed = false;
    if (typeof tokenOrRefreshOptions === "string") {
      this.tokenCredential = new _staticTokenCredential.StaticTokenCredential((0, _tokenParser.parseToken)(tokenOrRefreshOptions));
    } else {
      this.tokenCredential = new _autoRefreshTokenCredential.AutoRefreshTokenCredential(tokenOrRefreshOptions);
    }
  }
  /**
   * Gets an `AccessToken` for the user. Throws if already disposed.
   * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.
   */
  _createClass(AzureCommunicationTokenCredential, [{
    key: "getToken",
    value: (function () {
      var _getToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
        var token;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.throwIfDisposed();
              _context.next = 3;
              return this.tokenCredential.getToken(options);
            case 3:
              token = _context.sent;
              this.throwIfDisposed();
              return _context.abrupt("return", token);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getToken(_x) {
        return _getToken.apply(this, arguments);
      }
      return getToken;
    }()
    /**
     * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.
     */
    )
  }, {
    key: "dispose",
    value: function dispose() {
      this.disposed = true;
      this.tokenCredential.dispose();
    }
  }, {
    key: "throwIfDisposed",
    value: function throwIfDisposed() {
      if (this.disposed) {
        throw new Error("User credential is disposed");
      }
    }
  }]);
  return AzureCommunicationTokenCredential;
}();
},{"./autoRefreshTokenCredential":"node_modules/@azure/communication-common/dist-esm/src/autoRefreshTokenCredential.js","./staticTokenCredential":"node_modules/@azure/communication-common/dist-esm/src/staticTokenCredential.js","./tokenParser":"node_modules/@azure/communication-common/dist-esm/src/tokenParser.js"}],"node_modules/@azure/communication-common/dist-esm/src/credential/encodeUtils.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeBase64 = encodeBase64;
exports.encodeUTF8 = void 0;
exports.encodeUTF8fromBase64 = encodeUTF8fromBase64;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var encodeUTF8 = exports.encodeUTF8 = function encodeUTF8(str) {
  return new TextEncoder().encode(str);
};
function encodeUTF8fromBase64(str) {
  if (typeof atob !== "function") {
    throw new Error("Your browser environment is missing the global `atob` function");
  }
  var binary = atob(str);
  var bytes = new Uint8Array(binary.length);
  for (var i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
function encodeBase64(value) {
  if (typeof btoa !== "function") {
    throw new Error("Your browser environment is missing the global `btoa` function");
  }
  var bytes = new Uint8Array(value);
  var binary = "";
  var _iterator = _createForOfIteratorHelper(bytes),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var byte = _step.value;
      binary += String.fromCharCode(byte);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return btoa(binary);
}
},{}],"node_modules/@azure/communication-common/dist-esm/src/credential/cryptoUtils.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shaHash = exports.shaHMAC = void 0;
var _encodeUtils = require("./encodeUtils.browser");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var _a;
/// <reference lib="dom" />

var subtle = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.subtle;
var shaHash = exports.shaHash = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(content) {
    var data, hash;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          data = (0, _encodeUtils.encodeUTF8)(content);
          _context.next = 3;
          return subtle.digest("SHA-256", data);
        case 3:
          hash = _context.sent;
          return _context.abrupt("return", (0, _encodeUtils.encodeBase64)(hash));
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function shaHash(_x) {
    return _ref.apply(this, arguments);
  };
}();
var shaHMAC = exports.shaHMAC = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(secret, content) {
    var importParams, encodedMessage, encodedKey, crypto, cryptoKey, signature;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          importParams = {
            name: "HMAC",
            hash: {
              name: "SHA-256"
            }
          };
          encodedMessage = (0, _encodeUtils.encodeUTF8)(content);
          encodedKey = (0, _encodeUtils.encodeUTF8fromBase64)(secret);
          crypto = subtle;
          _context2.next = 6;
          return crypto.importKey("raw", encodedKey, importParams, false, ["sign"]);
        case 6:
          cryptoKey = _context2.sent;
          _context2.next = 9;
          return crypto.sign(importParams, cryptoKey, encodedMessage);
        case 9:
          signature = _context2.sent;
          return _context2.abrupt("return", (0, _encodeUtils.encodeBase64)(signature));
        case 11:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function shaHMAC(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();
},{"./encodeUtils.browser":"node_modules/@azure/communication-common/dist-esm/src/credential/encodeUtils.browser.js"}],"node_modules/@azure/communication-common/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCommunicationAccessKeyCredentialPolicy = createCommunicationAccessKeyCredentialPolicy;
var _cryptoUtils = require("./cryptoUtils");
var _coreUtil = require("@azure/core-util");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * CommunicationKeyCredentialPolicy provides a means of signing requests made through
 * the SmsClient.
 */
var communicationAccessKeyCredentialPolicy = "CommunicationAccessKeyCredentialPolicy";
/**
 * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.
 * @hidden
 *
 * @param credential - The key credential.
 */
function createCommunicationAccessKeyCredentialPolicy(credential) {
  return {
    name: communicationAccessKeyCredentialPolicy,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _a, verb, utcNow, contentHash, dateHeader, signedHeaders, url, query, urlPathAndQuery, port, hostAndPort, stringToSign, signature;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              verb = request.method.toUpperCase();
              utcNow = new Date().toUTCString();
              _context.next = 4;
              return (0, _cryptoUtils.shaHash)(((_a = request.body) === null || _a === void 0 ? void 0 : _a.toString()) || "");
            case 4:
              contentHash = _context.sent;
              dateHeader = "x-ms-date";
              signedHeaders = "".concat(dateHeader, ";host;x-ms-content-sha256");
              url = new URL(request.url);
              query = url.searchParams.toString();
              urlPathAndQuery = query ? "".concat(url.pathname, "?").concat(query) : url.pathname;
              port = url.port;
              hostAndPort = port ? "".concat(url.host, ":").concat(port) : url.host;
              stringToSign = "".concat(verb, "\n").concat(urlPathAndQuery, "\n").concat(utcNow, ";").concat(hostAndPort, ";").concat(contentHash);
              _context.next = 15;
              return (0, _cryptoUtils.shaHMAC)(credential.key, stringToSign);
            case 15:
              signature = _context.sent;
              if (_coreUtil.isNode) {
                request.headers.set("Host", hostAndPort || "");
              }
              request.headers.set(dateHeader, utcNow);
              request.headers.set("x-ms-content-sha256", contentHash);
              request.headers.set("Authorization", "HMAC-SHA256 SignedHeaders=".concat(signedHeaders, "&Signature=").concat(signature));
              return _context.abrupt("return", next(request));
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
},{"./cryptoUtils":"node_modules/@azure/communication-common/dist-esm/src/credential/cryptoUtils.browser.js","@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEmptyPipeline = createEmptyPipeline;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
/**
 * A private implementation of Pipeline.
 * Do not export this class from the package.
 * @internal
 */
var HttpPipeline = /*#__PURE__*/function () {
  function HttpPipeline(policies) {
    _classCallCheck(this, HttpPipeline);
    var _a;
    this._policies = [];
    this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];
    this._orderedPolicies = undefined;
  }
  _createClass(HttpPipeline, [{
    key: "addPolicy",
    value: function addPolicy(policy) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (options.phase && options.afterPhase) {
        throw new Error("Policies inside a phase cannot specify afterPhase.");
      }
      if (options.phase && !ValidPhaseNames.has(options.phase)) {
        throw new Error("Invalid phase name: ".concat(options.phase));
      }
      if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
        throw new Error("Invalid afterPhase name: ".concat(options.afterPhase));
      }
      this._policies.push({
        policy: policy,
        options: options
      });
      this._orderedPolicies = undefined;
    }
  }, {
    key: "removePolicy",
    value: function removePolicy(options) {
      var removedPolicies = [];
      this._policies = this._policies.filter(function (policyDescriptor) {
        if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
          removedPolicies.push(policyDescriptor.policy);
          return false;
        } else {
          return true;
        }
      });
      this._orderedPolicies = undefined;
      return removedPolicies;
    }
  }, {
    key: "sendRequest",
    value: function sendRequest(httpClient, request) {
      var policies = this.getOrderedPolicies();
      var pipeline = policies.reduceRight(function (next, policy) {
        return function (req) {
          return policy.sendRequest(req, next);
        };
      }, function (req) {
        return httpClient.sendRequest(req);
      });
      return pipeline(request);
    }
  }, {
    key: "getOrderedPolicies",
    value: function getOrderedPolicies() {
      if (!this._orderedPolicies) {
        this._orderedPolicies = this.orderPolicies();
      }
      return this._orderedPolicies;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new HttpPipeline(this._policies);
    }
  }, {
    key: "orderPolicies",
    value: function orderPolicies() {
      /**
       * The goal of this method is to reliably order pipeline policies
       * based on their declared requirements when they were added.
       *
       * Order is first determined by phase:
       *
       * 1. Serialize Phase
       * 2. Policies not in a phase
       * 3. Deserialize Phase
       * 4. Retry Phase
       * 5. Sign Phase
       *
       * Within each phase, policies are executed in the order
       * they were added unless they were specified to execute
       * before/after other policies or after a particular phase.
       *
       * To determine the final order, we will walk the policy list
       * in phase order multiple times until all dependencies are
       * satisfied.
       *
       * `afterPolicies` are the set of policies that must be
       * executed before a given policy. This requirement is
       * considered satisfied when each of the listed policies
       * have been scheduled.
       *
       * `beforePolicies` are the set of policies that must be
       * executed after a given policy. Since this dependency
       * can be expressed by converting it into a equivalent
       * `afterPolicies` declarations, they are normalized
       * into that form for simplicity.
       *
       * An `afterPhase` dependency is considered satisfied when all
       * policies in that phase have scheduled.
       *
       */
      var result = [];
      // Track all policies we know about.
      var policyMap = new Map();
      function createPhase(name) {
        return {
          name: name,
          policies: new Set(),
          hasRun: false,
          hasAfterPolicies: false
        };
      }
      // Track policies for each phase.
      var serializePhase = createPhase("Serialize");
      var noPhase = createPhase("None");
      var deserializePhase = createPhase("Deserialize");
      var retryPhase = createPhase("Retry");
      var signPhase = createPhase("Sign");
      // a list of phases in order
      var orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
      // Small helper function to map phase name to each Phase
      function getPhase(phase) {
        if (phase === "Retry") {
          return retryPhase;
        } else if (phase === "Serialize") {
          return serializePhase;
        } else if (phase === "Deserialize") {
          return deserializePhase;
        } else if (phase === "Sign") {
          return signPhase;
        } else {
          return noPhase;
        }
      }
      // First walk each policy and create a node to track metadata.
      var _iterator = _createForOfIteratorHelper(this._policies),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var descriptor = _step.value;
          var policy = descriptor.policy;
          var options = descriptor.options;
          var policyName = policy.name;
          if (policyMap.has(policyName)) {
            throw new Error("Duplicate policy names not allowed in pipeline");
          }
          var node = {
            policy: policy,
            dependsOn: new Set(),
            dependants: new Set()
          };
          if (options.afterPhase) {
            node.afterPhase = getPhase(options.afterPhase);
            node.afterPhase.hasAfterPolicies = true;
          }
          policyMap.set(policyName, node);
          var phase = getPhase(options.phase);
          phase.policies.add(node);
        }
        // Now that each policy has a node, connect dependency references.
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var _iterator2 = _createForOfIteratorHelper(this._policies),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _descriptor = _step2.value;
          var _policy = _descriptor.policy,
            _options = _descriptor.options;
          var _policyName = _policy.name;
          var _node = policyMap.get(_policyName);
          if (!_node) {
            throw new Error("Missing node for policy ".concat(_policyName));
          }
          if (_options.afterPolicies) {
            var _iterator6 = _createForOfIteratorHelper(_options.afterPolicies),
              _step6;
            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var afterPolicyName = _step6.value;
                var afterNode = policyMap.get(afterPolicyName);
                if (afterNode) {
                  // Linking in both directions helps later
                  // when we want to notify dependants.
                  _node.dependsOn.add(afterNode);
                  afterNode.dependants.add(_node);
                }
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
          if (_options.beforePolicies) {
            var _iterator7 = _createForOfIteratorHelper(_options.beforePolicies),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var beforePolicyName = _step7.value;
                var beforeNode = policyMap.get(beforePolicyName);
                if (beforeNode) {
                  // To execute before another node, make it
                  // depend on the current node.
                  beforeNode.dependsOn.add(_node);
                  _node.dependants.add(beforeNode);
                }
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      function walkPhase(phase) {
        phase.hasRun = true;
        // Sets iterate in insertion order
        var _iterator3 = _createForOfIteratorHelper(phase.policies),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var node = _step3.value;
            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
              // If this node is waiting on a phase to complete,
              // we need to skip it for now.
              // Even if the phase is empty, we should wait for it
              // to be walked to avoid re-ordering policies.
              continue;
            }
            if (node.dependsOn.size === 0) {
              // If there's nothing else we're waiting for, we can
              // add this policy to the result list.
              result.push(node.policy);
              // Notify anything that depends on this policy that
              // the policy has been scheduled.
              var _iterator4 = _createForOfIteratorHelper(node.dependants),
                _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var dependant = _step4.value;
                  dependant.dependsOn.delete(node);
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
              policyMap.delete(node.policy.name);
              phase.policies.delete(node);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      function walkPhases() {
        var _iterator5 = _createForOfIteratorHelper(orderedPhases),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var phase = _step5.value;
            walkPhase(phase);
            // if the phase isn't complete
            if (phase.policies.size > 0 && phase !== noPhase) {
              if (!noPhase.hasRun) {
                // Try running noPhase to see if that unblocks this phase next tick.
                // This can happen if a phase that happens before noPhase
                // is waiting on a noPhase policy to complete.
                walkPhase(noPhase);
              }
              // Don't proceed to the next phase until this phase finishes.
              return;
            }
            if (phase.hasAfterPolicies) {
              // Run any policies unblocked by this phase
              walkPhase(noPhase);
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
      // Iterate until we've put every node in the result list.
      var iteration = 0;
      while (policyMap.size > 0) {
        iteration++;
        var initialResultLength = result.length;
        // Keep walking each phase in order until we can order every node.
        walkPhases();
        // The result list *should* get at least one larger each time
        // after the first full pass.
        // Otherwise, we're going to loop forever.
        if (result.length <= initialResultLength && iteration > 1) {
          throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
        }
      }
      return result;
    }
  }], [{
    key: "create",
    value: function create() {
      return new HttpPipeline();
    }
  }]);
  return HttpPipeline;
}();
/**
 * Creates a totally empty pipeline.
 * Useful for testing or creating a custom one.
 */
function createEmptyPipeline() {
  return HttpPipeline.create();
}
},{}],"node_modules/@azure/logger/dist-esm/src/log.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = log;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function log() {
  if (arguments.length > 0) {
    var firstArg = String(arguments.length <= 0 ? undefined : arguments[0]);
    if (firstArg.includes(":error")) {
      var _console;
      (_console = console).error.apply(_console, arguments);
    } else if (firstArg.includes(":warning")) {
      var _console2;
      (_console2 = console).warn.apply(_console2, arguments);
    } else if (firstArg.includes(":info")) {
      var _console3;
      (_console3 = console).info.apply(_console3, arguments);
    } else if (firstArg.includes(":verbose")) {
      var _console4;
      (_console4 = console).debug.apply(_console4, arguments);
    } else {
      var _console5;
      (_console5 = console).debug.apply(_console5, arguments);
    }
  }
}
},{}],"node_modules/parcel-bundler/src/builtins/_empty.js":[function(require,module,exports) {

},{}],"node_modules/@azure/logger/dist-esm/src/debug.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _log = require("./log");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var debugEnvVariable = typeof process !== "undefined" && process.env && undefined || undefined;
var enabledString;
var enabledNamespaces = [];
var skippedNamespaces = [];
var debuggers = [];
if (debugEnvVariable) {
  enable(debugEnvVariable);
}
var debugObj = Object.assign(function (namespace) {
  return createDebugger(namespace);
}, {
  enable: enable,
  enabled: enabled,
  disable: disable,
  log: _log.log
});
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  var wildcard = /\*/g;
  var namespaceList = namespaces.split(",").map(function (ns) {
    return ns.trim().replace(wildcard, ".*?");
  });
  var _iterator = _createForOfIteratorHelper(namespaceList),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var ns = _step.value;
      if (ns.startsWith("-")) {
        skippedNamespaces.push(new RegExp("^".concat(ns.substr(1), "$")));
      } else {
        enabledNamespaces.push(new RegExp("^".concat(ns, "$")));
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var _iterator2 = _createForOfIteratorHelper(debuggers),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var instance = _step2.value;
      instance.enabled = enabled(instance.namespace);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  var _iterator3 = _createForOfIteratorHelper(skippedNamespaces),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var skipped = _step3.value;
      if (skipped.test(namespace)) {
        return false;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  var _iterator4 = _createForOfIteratorHelper(enabledNamespaces),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var enabledNamespace = _step4.value;
      if (enabledNamespace.test(namespace)) {
        return true;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return false;
}
function disable() {
  var result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  var newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy: destroy,
    log: debugObj.log,
    namespace: namespace,
    extend: extend
  });
  function debug() {
    if (!newDebugger.enabled) {
      return;
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length > 0) {
      args[0] = "".concat(namespace, " ").concat(args[0]);
    }
    newDebugger.log.apply(newDebugger, args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  var index = debuggers.indexOf(this);
  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  var newDebugger = createDebugger("".concat(this.namespace, ":").concat(namespace));
  newDebugger.log = this.log;
  return newDebugger;
}
var _default = exports.default = debugObj;
},{"./log":"node_modules/@azure/logger/dist-esm/src/log.browser.js","process":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@azure/logger/dist-esm/src/index.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AzureLogger = void 0;
exports.createClientLogger = createClientLogger;
exports.getLogLevel = getLogLevel;
exports.setLogLevel = setLogLevel;
var _debug = _interopRequireDefault(require("./debug"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var registeredLoggers = new Set();
var logLevelFromEnv = typeof process !== "undefined" && process.env && undefined || undefined;
var azureLogLevel;
/**
 * The AzureLogger provides a mechanism for overriding where logs are output to.
 * By default, logs are sent to stderr.
 * Override the `log` method to redirect logs to another location.
 */
var AzureLogger = exports.AzureLogger = (0, _debug.default)("azure");
AzureLogger.log = function () {
  _debug.default.log.apply(_debug.default, arguments);
};
var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
if (logLevelFromEnv) {
  // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
  if (isAzureLogLevel(logLevelFromEnv)) {
    setLogLevel(logLevelFromEnv);
  } else {
    console.error("AZURE_LOG_LEVEL set to unknown log level '".concat(logLevelFromEnv, "'; logging is not enabled. Acceptable values: ").concat(AZURE_LOG_LEVELS.join(", "), "."));
  }
}
/**
 * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.
 * @param level - The log level to enable for logging.
 * Options from most verbose to least verbose are:
 * - verbose
 * - info
 * - warning
 * - error
 */
function setLogLevel(level) {
  if (level && !isAzureLogLevel(level)) {
    throw new Error("Unknown log level '".concat(level, "'. Acceptable values: ").concat(AZURE_LOG_LEVELS.join(",")));
  }
  azureLogLevel = level;
  var enabledNamespaces = [];
  var _iterator = _createForOfIteratorHelper(registeredLoggers),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var logger = _step.value;
      if (shouldEnable(logger)) {
        enabledNamespaces.push(logger.namespace);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  _debug.default.enable(enabledNamespaces.join(","));
}
/**
 * Retrieves the currently specified log level.
 */
function getLogLevel() {
  return azureLogLevel;
}
var levelMap = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
/**
 * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
 * @param namespace - The name of the SDK package.
 * @hidden
 */
function createClientLogger(namespace) {
  var clientRootLogger = AzureLogger.extend(namespace);
  patchLogMethod(AzureLogger, clientRootLogger);
  return {
    error: createLogger(clientRootLogger, "error"),
    warning: createLogger(clientRootLogger, "warning"),
    info: createLogger(clientRootLogger, "info"),
    verbose: createLogger(clientRootLogger, "verbose")
  };
}
function patchLogMethod(parent, child) {
  child.log = function () {
    parent.log.apply(parent, arguments);
  };
}
function createLogger(parent, level) {
  var logger = Object.assign(parent.extend(level), {
    level: level
  });
  patchLogMethod(parent, logger);
  if (shouldEnable(logger)) {
    var enabledNamespaces = _debug.default.disable();
    _debug.default.enable(enabledNamespaces + "," + logger.namespace);
  }
  registeredLoggers.add(logger);
  return logger;
}
function shouldEnable(logger) {
  return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);
}
function isAzureLogLevel(logLevel) {
  return AZURE_LOG_LEVELS.includes(logLevel);
}
},{"./debug":"node_modules/@azure/logger/dist-esm/src/debug.js","process":"node_modules/parcel-bundler/src/builtins/_empty.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = void 0;
var _logger = require("@azure/logger");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var logger = exports.logger = (0, _logger.createClientLogger)("core-rest-pipeline");
},{"@azure/logger":"node_modules/@azure/logger/dist-esm/src/index.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sanitizer = void 0;
var _coreUtil = require("@azure/core-util");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var RedactedString = "REDACTED";
// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts
var defaultAllowedHeaderNames = ["x-ms-client-request-id", "x-ms-return-client-request-id", "x-ms-useragent", "x-ms-correlation-request-id", "x-ms-request-id", "client-request-id", "ms-cv", "return-client-request-id", "traceparent", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Origin", "Accept", "Accept-Encoding", "Cache-Control", "Connection", "Content-Length", "Content-Type", "Date", "ETag", "Expires", "If-Match", "If-Modified-Since", "If-None-Match", "If-Unmodified-Since", "Last-Modified", "Pragma", "Request-Id", "Retry-After", "Server", "Transfer-Encoding", "User-Agent", "WWW-Authenticate"];
var defaultAllowedQueryParameters = ["api-version"];
/**
 * @internal
 */
var Sanitizer = exports.Sanitizer = /*#__PURE__*/function () {
  function Sanitizer() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$additionalAllowe = _ref.additionalAllowedHeaderNames,
      allowedHeaderNames = _ref$additionalAllowe === void 0 ? [] : _ref$additionalAllowe,
      _ref$additionalAllowe2 = _ref.additionalAllowedQueryParameters,
      allowedQueryParameters = _ref$additionalAllowe2 === void 0 ? [] : _ref$additionalAllowe2;
    _classCallCheck(this, Sanitizer);
    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
    this.allowedHeaderNames = new Set(allowedHeaderNames.map(function (n) {
      return n.toLowerCase();
    }));
    this.allowedQueryParameters = new Set(allowedQueryParameters.map(function (p) {
      return p.toLowerCase();
    }));
  }
  _createClass(Sanitizer, [{
    key: "sanitize",
    value: function sanitize(obj) {
      var _this = this;
      var seen = new Set();
      return JSON.stringify(obj, function (key, value) {
        // Ensure Errors include their interesting non-enumerable members
        if (value instanceof Error) {
          return Object.assign(Object.assign({}, value), {
            name: value.name,
            message: value.message
          });
        }
        if (key === "headers") {
          return _this.sanitizeHeaders(value);
        } else if (key === "url") {
          return _this.sanitizeUrl(value);
        } else if (key === "query") {
          return _this.sanitizeQuery(value);
        } else if (key === "body") {
          // Don't log the request body
          return undefined;
        } else if (key === "response") {
          // Don't log response again
          return undefined;
        } else if (key === "operationSpec") {
          // When using sendOperationRequest, the request carries a massive
          // field with the autorest spec. No need to log it.
          return undefined;
        } else if (Array.isArray(value) || (0, _coreUtil.isObject)(value)) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      }, 2);
    }
  }, {
    key: "sanitizeHeaders",
    value: function sanitizeHeaders(obj) {
      var sanitized = {};
      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        if (this.allowedHeaderNames.has(key.toLowerCase())) {
          sanitized[key] = obj[key];
        } else {
          sanitized[key] = RedactedString;
        }
      }
      return sanitized;
    }
  }, {
    key: "sanitizeQuery",
    value: function sanitizeQuery(value) {
      if (_typeof(value) !== "object" || value === null) {
        return value;
      }
      var sanitized = {};
      for (var _i2 = 0, _Object$keys2 = Object.keys(value); _i2 < _Object$keys2.length; _i2++) {
        var k = _Object$keys2[_i2];
        if (this.allowedQueryParameters.has(k.toLowerCase())) {
          sanitized[k] = value[k];
        } else {
          sanitized[k] = RedactedString;
        }
      }
      return sanitized;
    }
  }, {
    key: "sanitizeUrl",
    value: function sanitizeUrl(value) {
      if (typeof value !== "string" || value === null) {
        return value;
      }
      var url = new URL(value);
      if (!url.search) {
        return value;
      }
      var _iterator = _createForOfIteratorHelper(url.searchParams),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 1),
            key = _step$value[0];
          if (!this.allowedQueryParameters.has(key.toLowerCase())) {
            url.searchParams.set(key, RedactedString);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return url.toString();
    }
  }]);
  return Sanitizer;
}();
},{"@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logPolicy = logPolicy;
exports.logPolicyName = void 0;
var _log = require("../log");
var _sanitizer = require("../util/sanitizer");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the logPolicy.
 */
var logPolicyName = exports.logPolicyName = "logPolicy";
/**
 * A policy that logs all requests and responses.
 * @param options - Options to configure logPolicy.
 */
function logPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _a;
  var logger = (_a = options.logger) !== null && _a !== void 0 ? _a : _log.logger.info;
  var sanitizer = new _sanitizer.Sanitizer({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var response;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (logger.enabled) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", next(request));
            case 2:
              logger("Request: ".concat(sanitizer.sanitize(request)));
              _context.next = 5;
              return next(request);
            case 5:
              response = _context.sent;
              logger("Response status code: ".concat(response.status));
              logger("Headers: ".concat(sanitizer.sanitize(response.headers)));
              return _context.abrupt("return", response);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
},{"../log":"node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js","../util/sanitizer":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.redirectPolicy = redirectPolicy;
exports.redirectPolicyName = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the redirectPolicy.
 */
var redirectPolicyName = exports.redirectPolicyName = "redirectPolicy";
/**
 * Methods that are allowed to follow redirects 301 and 302
 */
var allowedRedirect = ["GET", "HEAD"];
/**
 * A policy to follow Location headers from the server in order
 * to support server-side redirection.
 * In the browser, this policy is not used.
 * @param options - Options to control policy behavior.
 */
function redirectPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _options$maxRetries = options.maxRetries,
    maxRetries = _options$maxRetries === void 0 ? 20 : _options$maxRetries;
  return {
    name: redirectPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var response;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return next(request);
            case 2:
              response = _context.sent;
              return _context.abrupt("return", handleRedirect(next, response, maxRetries));
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
function handleRedirect(_x, _x2, _x3) {
  return _handleRedirect.apply(this, arguments);
}
function _handleRedirect() {
  _handleRedirect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(next, response, maxRetries) {
    var currentRetries,
      request,
      status,
      headers,
      locationHeader,
      url,
      res,
      _args2 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          currentRetries = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 0;
          request = response.request, status = response.status, headers = response.headers;
          locationHeader = headers.get("location");
          if (!(locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries)) {
            _context2.next = 12;
            break;
          }
          url = new URL(locationHeader, request.url);
          request.url = url.toString();
          // POST request with Status code 303 should be converted into a
          // redirected GET request if the redirect url is present in the location header
          if (status === 303) {
            request.method = "GET";
            request.headers.delete("Content-Length");
            delete request.body;
          }
          request.headers.delete("Authorization");
          _context2.next = 10;
          return next(request);
        case 10:
          res = _context2.sent;
          return _context2.abrupt("return", handleRedirect(next, res, maxRetries, currentRetries + 1));
        case 12:
          return _context2.abrupt("return", response);
        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _handleRedirect.apply(this, arguments);
}
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHeaderName = getHeaderName;
exports.setPlatformSpecificData = setPlatformSpecificData;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*
 * NOTE: When moving this file, please update "browser" section in package.json.
 */
/**
 * @internal
 */
function getHeaderName() {
  return "x-ms-useragent";
}
/**
 * @internal
 */
function setPlatformSpecificData(map) {
  var _a, _b, _c;
  var localNavigator = globalThis.navigator;
  map.set("OS", ((_c = (_b = (_a = localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.userAgentData) === null || _a === void 0 ? void 0 : _a.platform) !== null && _b !== void 0 ? _b : localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.platform) !== null && _c !== void 0 ? _c : "unknown").replace(" ", ""));
}
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SDK_VERSION = exports.DEFAULT_RETRY_POLICY_COUNT = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var SDK_VERSION = exports.SDK_VERSION = "1.12.3";
var DEFAULT_RETRY_POLICY_COUNT = exports.DEFAULT_RETRY_POLICY_COUNT = 3;
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUserAgentHeaderName = getUserAgentHeaderName;
exports.getUserAgentValue = getUserAgentValue;
var _userAgentPlatform = require("./userAgentPlatform");
var _constants = require("../constants");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getUserAgentString(telemetryInfo) {
  var parts = [];
  var _iterator = _createForOfIteratorHelper(telemetryInfo),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        key = _step$value[0],
        value = _step$value[1];
      var token = value ? "".concat(key, "/").concat(value) : key;
      parts.push(token);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return parts.join(" ");
}
/**
 * @internal
 */
function getUserAgentHeaderName() {
  return (0, _userAgentPlatform.getHeaderName)();
}
/**
 * @internal
 */
function getUserAgentValue(prefix) {
  var runtimeInfo = new Map();
  runtimeInfo.set("core-rest-pipeline", _constants.SDK_VERSION);
  (0, _userAgentPlatform.setPlatformSpecificData)(runtimeInfo);
  var defaultAgent = getUserAgentString(runtimeInfo);
  var userAgentValue = prefix ? "".concat(prefix, " ").concat(defaultAgent) : defaultAgent;
  return userAgentValue;
}
},{"./userAgentPlatform":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgentPlatform.browser.js","../constants":"node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.userAgentPolicy = userAgentPolicy;
exports.userAgentPolicyName = void 0;
var _userAgent = require("../util/userAgent");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var UserAgentHeaderName = (0, _userAgent.getUserAgentHeaderName)();
/**
 * The programmatic identifier of the userAgentPolicy.
 */
var userAgentPolicyName = exports.userAgentPolicyName = "userAgentPolicy";
/**
 * A policy that sets the User-Agent header (or equivalent) to reflect
 * the library version.
 * @param options - Options to customize the user agent value.
 */
function userAgentPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var userAgentValue = (0, _userAgent.getUserAgentValue)(options.userAgentPrefix);
  return {
    name: userAgentPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!request.headers.has(UserAgentHeaderName)) {
                request.headers.set(UserAgentHeaderName, userAgentValue);
              }
              return _context.abrupt("return", next(request));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
},{"../util/userAgent":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decompressResponsePolicy = decompressResponsePolicy;
exports.decompressResponsePolicyName = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*
 * NOTE: When moving this file, please update "browser" section in package.json
 */
var decompressResponsePolicyName = exports.decompressResponsePolicyName = "decompressResponsePolicy";
/**
 * decompressResponsePolicy is not supported in the browser and attempting
 * to use it will raise an error.
 */
function decompressResponsePolicy() {
  throw new Error("decompressResponsePolicy is not supported in browser environment");
}
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.delay = delay;
exports.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
var _abortController = require("@azure/abort-controller");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var StandardAbortMessage = "The operation was aborted.";
/**
 * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.
 * @param delayInMs - The number of milliseconds to be delayed.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 * @param options - The options for delay - currently abort options
 *                  - abortSignal - The abortSignal associated with containing operation.
 *                  - abortErrorMsg - The abort error message associated with containing operation.
 * @returns Resolved promise
 */
function delay(delayInMs, value, options) {
  return new Promise(function (resolve, reject) {
    var timer = undefined;
    var onAborted = undefined;
    var rejectOnAbort = function rejectOnAbort() {
      return reject(new _abortController.AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));
    };
    var removeListeners = function removeListeners() {
      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = function onAborted() {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(function () {
      removeListeners();
      resolve(value);
    }, delayInMs);
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
/**
 * @internal
 * @returns the parsed value or undefined if the parsed value is invalid.
 */
function parseHeaderValueAsNumber(response, headerName) {
  var value = response.headers.get(headerName);
  if (!value) return;
  var valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum)) return;
  return valueAsNum;
}
},{"@azure/abort-controller":"node_modules/@azure/abort-controller/dist-esm/src/index.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isThrottlingRetryResponse = isThrottlingRetryResponse;
exports.throttlingRetryStrategy = throttlingRetryStrategy;
var _helpers = require("../util/helpers");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The header that comes back from Azure services representing
 * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).
 */
var RetryAfterHeader = "Retry-After";
/**
 * The headers that come back from Azure services representing
 * the amount of time (minimum) to wait to retry.
 *
 * "retry-after-ms", "x-ms-retry-after-ms" : milliseconds
 * "Retry-After" : seconds or timestamp
 */
var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
/**
 * A response is a throttling retry response if it has a throttling status code (429 or 503),
 * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
 *
 * Returns the `retryAfterInMs` value if the response is a throttling retry response.
 * If not throttling retry response, returns `undefined`.
 *
 * @internal
 */
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status))) return undefined;
  try {
    // Headers: "retry-after-ms", "x-ms-retry-after-ms", "Retry-After"
    var _iterator = _createForOfIteratorHelper(AllRetryAfterHeaders),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var header = _step.value;
        var retryAfterValue = (0, _helpers.parseHeaderValueAsNumber)(response, header);
        if (retryAfterValue === 0 || retryAfterValue) {
          // "Retry-After" header ==> seconds
          // "retry-after-ms", "x-ms-retry-after-ms" headers ==> milli-seconds
          var multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
          return retryAfterValue * multiplyingFactor; // in milli-seconds
        }
      }
      // RetryAfterHeader ("Retry-After") has a special case where it might be formatted as a date instead of a number of seconds
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader) return;
    var date = Date.parse(retryAfterHeader);
    var diff = date - Date.now();
    // negative diff would mean a date in the past, so retry asap with 0 milliseconds
    return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
  } catch (e) {
    return undefined;
  }
}
/**
 * A response is a retry response if it has a throttling status code (429 or 503),
 * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
 */
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry: function retry(_ref) {
      var response = _ref.response;
      var retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return {
          skipStrategy: true
        };
      }
      return {
        retryAfterInMs: retryAfterInMs
      };
    }
  };
}
},{"../util/helpers":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exponentialRetryStrategy = exponentialRetryStrategy;
exports.isExponentialRetryResponse = isExponentialRetryResponse;
exports.isSystemError = isSystemError;
var _coreUtil = require("@azure/core-util");
var _throttlingRetryStrategy = require("./throttlingRetryStrategy");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// intervals are in milliseconds
var DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
/**
 * A retry strategy that retries with an exponentially increasing delay in these two cases:
 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
 * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).
 */
function exponentialRetryStrategy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _a, _b;
  var retryInterval = (_a = options.retryDelayInMs) !== null && _a !== void 0 ? _a : DEFAULT_CLIENT_RETRY_INTERVAL;
  var maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
  var retryAfterInMs = retryInterval;
  return {
    name: "exponentialRetryStrategy",
    retry: function retry(_ref) {
      var retryCount = _ref.retryCount,
        response = _ref.response,
        responseError = _ref.responseError;
      var matchedSystemError = isSystemError(responseError);
      var ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      var isExponential = isExponentialRetryResponse(response);
      var ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      var unknownResponse = response && ((0, _throttlingRetryStrategy.isThrottlingRetryResponse)(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return {
          skipStrategy: true
        };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return {
          errorToThrow: responseError
        };
      }
      // Exponentially increase the delay each time
      var exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
      // Don't let the delay exceed the maximum
      var clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
      // Allow the final value to have some "jitter" (within 50% of the delay size) so
      // that retries across multiple clients don't occur simultaneously.
      retryAfterInMs = clampedExponentialDelay / 2 + (0, _coreUtil.getRandomIntegerInclusive)(0, clampedExponentialDelay / 2);
      return {
        retryAfterInMs: retryAfterInMs
      };
    }
  };
}
/**
 * A response is a retry response if it has status codes:
 * - 408, or
 * - Greater or equal than 500, except for 501 and 505.
 */
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== undefined && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
/**
 * Determines whether an error from a pipeline response was triggered in the network layer.
 */
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
}
},{"@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js","./throttlingRetryStrategy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.retryPolicy = retryPolicy;
var _helpers = require("../util/helpers");
var _logger = require("@azure/logger");
var _abortController = require("@azure/abort-controller");
var _constants = require("../constants");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var retryPolicyLogger = (0, _logger.createClientLogger)("core-rest-pipeline retryPolicy");
/**
 * The programmatic identifier of the retryPolicy.
 */
var retryPolicyName = "retryPolicy";
/**
 * retryPolicy is a generic policy to enable retrying requests when certain conditions are met
 */
function retryPolicy(strategies) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    maxRetries: _constants.DEFAULT_RETRY_POLICY_COUNT
  };
  var logger = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _a, _b, response, responseError, retryCount, abortError, _iterator, _step, strategy, strategyLogger, modifiers, errorToThrow, retryAfterInMs, redirectTo;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              retryCount = -1; // eslint-disable-next-line no-constant-condition
            case 1:
              if (!true) {
                _context.next = 78;
                break;
              }
              retryCount += 1;
              response = undefined;
              responseError = undefined;
              _context.prev = 5;
              logger.info("Retry ".concat(retryCount, ": Attempting to send request"), request.requestId);
              _context.next = 9;
              return next(request);
            case 9:
              response = _context.sent;
              logger.info("Retry ".concat(retryCount, ": Received a response from request"), request.requestId);
              _context.next = 20;
              break;
            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](5);
              logger.error("Retry ".concat(retryCount, ": Received an error from request"), request.requestId);
              // RestErrors are valid targets for the retry strategies.
              // If none of the retry strategies can work with them, they will be thrown later in this policy.
              // If the received error is not a RestError, it is immediately thrown.
              responseError = _context.t0;
              if (!(!_context.t0 || responseError.name !== "RestError")) {
                _context.next = 19;
                break;
              }
              throw _context.t0;
            case 19:
              response = responseError.response;
            case 20:
              if (!((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted)) {
                _context.next = 24;
                break;
              }
              logger.error("Retry ".concat(retryCount, ": Request aborted."));
              abortError = new _abortController.AbortError();
              throw abortError;
            case 24:
              if (!(retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : _constants.DEFAULT_RETRY_POLICY_COUNT))) {
                _context.next = 35;
                break;
              }
              logger.info("Retry ".concat(retryCount, ": Maximum retries reached. Returning the last received response, or throwing the last received error."));
              if (!responseError) {
                _context.next = 30;
                break;
              }
              throw responseError;
            case 30:
              if (!response) {
                _context.next = 34;
                break;
              }
              return _context.abrupt("return", response);
            case 34:
              throw new Error("Maximum retries reached with no response or error to throw");
            case 35:
              logger.info("Retry ".concat(retryCount, ": Processing ").concat(strategies.length, " retry strategies."));
              _iterator = _createForOfIteratorHelper(strategies);
              _context.prev = 37;
              _iterator.s();
            case 39:
              if ((_step = _iterator.n()).done) {
                _context.next = 62;
                break;
              }
              strategy = _step.value;
              strategyLogger = strategy.logger || retryPolicyLogger;
              strategyLogger.info("Retry ".concat(retryCount, ": Processing retry strategy ").concat(strategy.name, "."));
              modifiers = strategy.retry({
                retryCount: retryCount,
                response: response,
                responseError: responseError
              });
              if (!modifiers.skipStrategy) {
                _context.next = 47;
                break;
              }
              strategyLogger.info("Retry ".concat(retryCount, ": Skipped."));
              return _context.abrupt("continue", 60);
            case 47:
              errorToThrow = modifiers.errorToThrow, retryAfterInMs = modifiers.retryAfterInMs, redirectTo = modifiers.redirectTo;
              if (!errorToThrow) {
                _context.next = 51;
                break;
              }
              strategyLogger.error("Retry ".concat(retryCount, ": Retry strategy ").concat(strategy.name, " throws error:"), errorToThrow);
              throw errorToThrow;
            case 51:
              if (!(retryAfterInMs || retryAfterInMs === 0)) {
                _context.next = 56;
                break;
              }
              strategyLogger.info("Retry ".concat(retryCount, ": Retry strategy ").concat(strategy.name, " retries after ").concat(retryAfterInMs));
              _context.next = 55;
              return (0, _helpers.delay)(retryAfterInMs, undefined, {
                abortSignal: request.abortSignal
              });
            case 55:
              return _context.abrupt("continue", 1);
            case 56:
              if (!redirectTo) {
                _context.next = 60;
                break;
              }
              strategyLogger.info("Retry ".concat(retryCount, ": Retry strategy ").concat(strategy.name, " redirects to ").concat(redirectTo));
              request.url = redirectTo;
              return _context.abrupt("continue", 1);
            case 60:
              _context.next = 39;
              break;
            case 62:
              _context.next = 67;
              break;
            case 64:
              _context.prev = 64;
              _context.t1 = _context["catch"](37);
              _iterator.e(_context.t1);
            case 67:
              _context.prev = 67;
              _iterator.f();
              return _context.finish(67);
            case 70:
              if (!responseError) {
                _context.next = 73;
                break;
              }
              logger.info("None of the retry strategies could work with the received error. Throwing it.");
              throw responseError;
            case 73:
              if (!response) {
                _context.next = 76;
                break;
              }
              logger.info("None of the retry strategies could work with the received response. Returning it.");
              return _context.abrupt("return", response);
            case 76:
              _context.next = 1;
              break;
            case 78:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[5, 13], [37, 64, 67, 70]]);
      }))();
    }
  };
}
},{"../util/helpers":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js","@azure/logger":"node_modules/@azure/logger/dist-esm/src/index.js","@azure/abort-controller":"node_modules/@azure/abort-controller/dist-esm/src/index.js","../constants":"node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultRetryPolicy = defaultRetryPolicy;
exports.defaultRetryPolicyName = void 0;
var _exponentialRetryStrategy = require("../retryStrategies/exponentialRetryStrategy");
var _throttlingRetryStrategy = require("../retryStrategies/throttlingRetryStrategy");
var _retryPolicy = require("./retryPolicy");
var _constants = require("../constants");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Name of the {@link defaultRetryPolicy}
 */
var defaultRetryPolicyName = exports.defaultRetryPolicyName = "defaultRetryPolicy";
/**
 * A policy that retries according to three strategies:
 * - When the server sends a 429 response with a Retry-After header.
 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
 * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.
 */
function defaultRetryPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _a;
  return {
    name: defaultRetryPolicyName,
    sendRequest: (0, _retryPolicy.retryPolicy)([(0, _throttlingRetryStrategy.throttlingRetryStrategy)(), (0, _exponentialRetryStrategy.exponentialRetryStrategy)(options)], {
      maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : _constants.DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}
},{"../retryStrategies/exponentialRetryStrategy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js","../retryStrategies/throttlingRetryStrategy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js","./retryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js","../constants":"node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHttpHeaders = createHttpHeaders;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
var _marked = /*#__PURE__*/_regeneratorRuntime().mark(headerIterator);
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function normalizeName(name) {
  return name.toLowerCase();
}
function headerIterator(map) {
  var _iterator, _step, entry;
  return _regeneratorRuntime().wrap(function headerIterator$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        _iterator = _createForOfIteratorHelper(map.values());
        _context.prev = 1;
        _iterator.s();
      case 3:
        if ((_step = _iterator.n()).done) {
          _context.next = 9;
          break;
        }
        entry = _step.value;
        _context.next = 7;
        return [entry.name, entry.value];
      case 7:
        _context.next = 3;
        break;
      case 9:
        _context.next = 14;
        break;
      case 11:
        _context.prev = 11;
        _context.t0 = _context["catch"](1);
        _iterator.e(_context.t0);
      case 14:
        _context.prev = 14;
        _iterator.f();
        return _context.finish(14);
      case 17:
      case "end":
        return _context.stop();
    }
  }, _marked, null, [[1, 11, 14, 17]]);
}
var HttpHeadersImpl = /*#__PURE__*/function (_Symbol$iterator) {
  function HttpHeadersImpl(rawHeaders) {
    _classCallCheck(this, HttpHeadersImpl);
    this._headersMap = new Map();
    if (rawHeaders) {
      for (var _i = 0, _Object$keys = Object.keys(rawHeaders); _i < _Object$keys.length; _i++) {
        var headerName = _Object$keys[_i];
        this.set(headerName, rawHeaders[headerName]);
      }
    }
  }
  /**
   * Set a header in this collection with the provided name and value. The name is
   * case-insensitive.
   * @param name - The name of the header to set. This value is case-insensitive.
   * @param value - The value of the header to set.
   */
  _createClass(HttpHeadersImpl, [{
    key: "set",
    value: function set(name, value) {
      this._headersMap.set(normalizeName(name), {
        name: name,
        value: String(value).trim()
      });
    }
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param name - The name of the header. This value is case-insensitive.
     */
  }, {
    key: "get",
    value: function get(name) {
      var _a;
      return (_a = this._headersMap.get(normalizeName(name))) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     * @param name - The name of the header to set. This value is case-insensitive.
     */
  }, {
    key: "has",
    value: function has(name) {
      return this._headersMap.has(normalizeName(name));
    }
    /**
     * Remove the header with the provided headerName.
     * @param name - The name of the header to remove.
     */
  }, {
    key: "delete",
    value: function _delete(name) {
      this._headersMap.delete(normalizeName(name));
    }
    /**
     * Get the JSON object representation of this HTTP header collection.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var result = {};
      if (options.preserveCase) {
        var _iterator2 = _createForOfIteratorHelper(this._headersMap.values()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var entry = _step2.value;
            result[entry.name] = entry.value;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        var _iterator3 = _createForOfIteratorHelper(this._headersMap),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = _slicedToArray(_step3.value, 2),
              normalizedName = _step3$value[0],
              _entry = _step3$value[1];
            result[normalizedName] = _entry.value;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      return result;
    }
    /**
     * Get the string representation of this HTTP header collection.
     */
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify(this.toJSON({
        preserveCase: true
      }));
    }
    /**
     * Iterate over tuples of header [name, value] pairs.
     */
  }, {
    key: _Symbol$iterator,
    value: function value() {
      return headerIterator(this._headersMap);
    }
  }]);
  return HttpHeadersImpl;
}(Symbol.iterator);
/**
 * Creates an object that satisfies the `HttpHeaders` interface.
 * @param rawHeaders - A simple object representing initial headers
 */
function createHttpHeaders(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formDataPolicy = formDataPolicy;
exports.formDataPolicyName = void 0;
var _coreUtil = require("@azure/core-util");
var _httpHeaders = require("../httpHeaders");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the formDataPolicy.
 */
var formDataPolicyName = exports.formDataPolicyName = "formDataPolicy";
/**
 * A policy that encodes FormData on the request into the body.
 */
function formDataPolicy() {
  return {
    name: formDataPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var contentType;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!request.formData) {
                _context.next = 9;
                break;
              }
              contentType = request.headers.get("Content-Type");
              if (!(contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1)) {
                _context.next = 6;
                break;
              }
              request.body = wwwFormUrlEncode(request.formData);
              _context.next = 8;
              break;
            case 6:
              _context.next = 8;
              return prepareFormData(request.formData, request);
            case 8:
              request.formData = undefined;
            case 9:
              return _context.abrupt("return", next(request));
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
function wwwFormUrlEncode(formData) {
  var urlSearchParams = new URLSearchParams();
  for (var _i = 0, _Object$entries = Object.entries(formData); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      key = _Object$entries$_i[0],
      value = _Object$entries$_i[1];
    if (Array.isArray(value)) {
      var _iterator = _createForOfIteratorHelper(value),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var subValue = _step.value;
          urlSearchParams.append(key, subValue.toString());
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else {
      urlSearchParams.append(key, value.toString());
    }
  }
  return urlSearchParams.toString();
}
function prepareFormData(_x, _x2) {
  return _prepareFormData.apply(this, arguments);
}
function _prepareFormData() {
  _prepareFormData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(formData, request) {
    var contentType, parts, _i2, _Object$entries2, _Object$entries2$_i, fieldName, values, _iterator2, _step2, value, fileName, headers;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          // validate content type (multipart/form-data)
          contentType = request.headers.get("Content-Type");
          if (!(contentType && !contentType.startsWith("multipart/form-data"))) {
            _context2.next = 3;
            break;
          }
          return _context2.abrupt("return");
        case 3:
          request.headers.set("Content-Type", contentType !== null && contentType !== void 0 ? contentType : "multipart/form-data");
          // set body to MultipartRequestBody using content from FormDataMap
          parts = [];
          for (_i2 = 0, _Object$entries2 = Object.entries(formData); _i2 < _Object$entries2.length; _i2++) {
            _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2), fieldName = _Object$entries2$_i[0], values = _Object$entries2$_i[1];
            _iterator2 = _createForOfIteratorHelper(Array.isArray(values) ? values : [values]);
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                value = _step2.value;
                if (typeof value === "string") {
                  parts.push({
                    headers: (0, _httpHeaders.createHttpHeaders)({
                      "Content-Disposition": "form-data; name=\"".concat(fieldName, "\"")
                    }),
                    body: (0, _coreUtil.stringToUint8Array)(value, "utf-8")
                  });
                } else {
                  // using || instead of ?? here since if value.name is empty we should create a file name
                  fileName = value.name || "blob";
                  headers = (0, _httpHeaders.createHttpHeaders)();
                  headers.set("Content-Disposition", "form-data; name=\"".concat(fieldName, "\"; filename=\"").concat(fileName, "\""));
                  if (value.type) {
                    headers.set("Content-Type", value.type);
                  }
                  parts.push({
                    headers: headers,
                    body: value
                  });
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            request.multipartBody = {
              parts: parts
            };
          }
        case 6:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _prepareFormData.apply(this, arguments);
}
},{"@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js","../httpHeaders":"node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultProxySettings = getDefaultProxySettings;
exports.proxyPolicy = proxyPolicy;
exports.proxyPolicyName = void 0;
exports.resetCachedProxyAgents = resetCachedProxyAgents;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/*
 * NOTE: When moving this file, please update "browser" section in package.json
 */
var proxyPolicyName = exports.proxyPolicyName = "proxyPolicy";
var errorMessage = "proxyPolicy is not supported in browser environment";
function getDefaultProxySettings() {
  throw new Error(errorMessage);
}
/**
 * proxyPolicy is not supported in the browser and attempting
 * to use it will raise an error.
 */
function proxyPolicy() {
  throw new Error(errorMessage);
}
/**
 * A function to reset the cached agents.
 * proxyPolicy is not supported in the browser and attempting
 * to use it will raise an error.
 * @internal
 */
function resetCachedProxyAgents() {
  throw new Error(errorMessage);
}
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setClientRequestIdPolicy = setClientRequestIdPolicy;
exports.setClientRequestIdPolicyName = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the setClientRequestIdPolicy.
 */
var setClientRequestIdPolicyName = exports.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
/**
 * Each PipelineRequest gets a unique id upon creation.
 * This policy passes that unique id along via an HTTP header to enable better
 * telemetry and tracing.
 * @param requestIdHeaderName - The name of the header to pass the request ID to.
 */
function setClientRequestIdPolicy() {
  var requestIdHeaderName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "x-ms-client-request-id";
  return {
    name: setClientRequestIdPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!request.headers.has(requestIdHeaderName)) {
                request.headers.set(requestIdHeaderName, request.requestId);
              }
              return _context.abrupt("return", next(request));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tlsPolicy = tlsPolicy;
exports.tlsPolicyName = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Name of the TLS Policy
 */
var tlsPolicyName = exports.tlsPolicyName = "tlsPolicy";
/**
 * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.
 */
function tlsPolicy(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: function () {
      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(req, next) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // Users may define a request tlsSettings, honor those over the client level one
              if (!req.tlsSettings) {
                req.tlsSettings = tlsSettings;
              }
              return _context.abrupt("return", next(req));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function sendRequest(_x, _x2) {
        return _sendRequest.apply(this, arguments);
      }
      return sendRequest;
    }()
  };
}
},{}],"node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TracingContextImpl = void 0;
exports.createTracingContext = createTracingContext;
exports.knownContextKeys = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/** @internal */
var knownContextKeys = exports.knownContextKeys = {
  span: Symbol.for("@azure/core-tracing span"),
  namespace: Symbol.for("@azure/core-tracing namespace")
};
/**
 * Creates a new {@link TracingContext} with the given options.
 * @param options - A set of known keys that may be set on the context.
 * @returns A new {@link TracingContext} with the given options.
 *
 * @internal
 */
function createTracingContext() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var context = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context = context.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context = context.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context;
}
/** @internal */
var TracingContextImpl = exports.TracingContextImpl = /*#__PURE__*/function () {
  function TracingContextImpl(initialContext) {
    _classCallCheck(this, TracingContextImpl);
    this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : new Map();
  }
  _createClass(TracingContextImpl, [{
    key: "setValue",
    value: function setValue(key, value) {
      var newContext = new TracingContextImpl(this);
      newContext._contextMap.set(key, value);
      return newContext;
    }
  }, {
    key: "getValue",
    value: function getValue(key) {
      return this._contextMap.get(key);
    }
  }, {
    key: "deleteValue",
    value: function deleteValue(key) {
      var newContext = new TracingContextImpl(this);
      newContext._contextMap.delete(key);
      return newContext;
    }
  }]);
  return TracingContextImpl;
}();
},{}],"node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDefaultInstrumenter = createDefaultInstrumenter;
exports.createDefaultTracingSpan = createDefaultTracingSpan;
exports.getInstrumenter = getInstrumenter;
exports.useInstrumenter = useInstrumenter;
var _tracingContext = require("./tracingContext");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

function createDefaultTracingSpan() {
  return {
    end: function end() {
      // noop
    },
    isRecording: function isRecording() {
      return false;
    },
    recordException: function recordException() {
      // noop
    },
    setAttribute: function setAttribute() {
      // noop
    },
    setStatus: function setStatus() {
      // noop
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: function createRequestHeaders() {
      return {};
    },
    parseTraceparentHeader: function parseTraceparentHeader() {
      return undefined;
    },
    startSpan: function startSpan(_name, spanOptions) {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: (0, _tracingContext.createTracingContext)({
          parentContext: spanOptions.tracingContext
        })
      };
    },
    withContext: function withContext(_context, callback) {
      for (var _len = arguments.length, callbackArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        callbackArgs[_key - 2] = arguments[_key];
      }
      return callback.apply(void 0, callbackArgs);
    }
  };
}
/** @internal */
var instrumenterImplementation;
/**
 * Extends the Azure SDK with support for a given instrumenter implementation.
 *
 * @param instrumenter - The instrumenter implementation to use.
 */
function useInstrumenter(instrumenter) {
  instrumenterImplementation = instrumenter;
}
/**
 * Gets the currently set instrumenter, a No-Op instrumenter by default.
 *
 * @returns The currently set instrumenter
 */
function getInstrumenter() {
  if (!instrumenterImplementation) {
    instrumenterImplementation = createDefaultInstrumenter();
  }
  return instrumenterImplementation;
}
},{"./tracingContext":"node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js"}],"node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTracingClient = createTracingClient;
var _instrumenter = require("./instrumenter");
var _tracingContext = require("./tracingContext");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Creates a new tracing client.
 *
 * @param options - Options used to configure the tracing client.
 * @returns - An instance of {@link TracingClient}.
 */
function createTracingClient(options) {
  var namespace = options.namespace,
    packageName = options.packageName,
    packageVersion = options.packageVersion;
  function startSpan(name, operationOptions, spanOptions) {
    var _a;
    var startSpanResult = (0, _instrumenter.getInstrumenter)().startSpan(name, Object.assign(Object.assign({}, spanOptions), {
      packageName: packageName,
      packageVersion: packageVersion,
      tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext
    }));
    var tracingContext = startSpanResult.tracingContext;
    var span = startSpanResult.span;
    if (!tracingContext.getValue(_tracingContext.knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(_tracingContext.knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(_tracingContext.knownContextKeys.namespace));
    var updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), {
        tracingContext: tracingContext
      })
    });
    return {
      span: span,
      updatedOptions: updatedOptions
    };
  }
  function withSpan(_x, _x2, _x3, _x4) {
    return _withSpan.apply(this, arguments);
  }
  function _withSpan() {
    _withSpan = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(name, operationOptions, callback, spanOptions) {
      var _startSpan, span, updatedOptions, result;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _startSpan = startSpan(name, operationOptions, spanOptions), span = _startSpan.span, updatedOptions = _startSpan.updatedOptions;
            _context.prev = 1;
            _context.next = 4;
            return withContext(updatedOptions.tracingOptions.tracingContext, function () {
              return Promise.resolve(callback(updatedOptions, span));
            });
          case 4:
            result = _context.sent;
            span.setStatus({
              status: "success"
            });
            return _context.abrupt("return", result);
          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](1);
            span.setStatus({
              status: "error",
              error: _context.t0
            });
            throw _context.t0;
          case 13:
            _context.prev = 13;
            span.end();
            return _context.finish(13);
          case 16:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[1, 9, 13, 16]]);
    }));
    return _withSpan.apply(this, arguments);
  }
  function withContext(context, callback) {
    var _getInstrumenter;
    for (var _len = arguments.length, callbackArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      callbackArgs[_key - 2] = arguments[_key];
    }
    return (_getInstrumenter = (0, _instrumenter.getInstrumenter)()).withContext.apply(_getInstrumenter, [context, callback].concat(callbackArgs));
  }
  /**
   * Parses a traceparent header value into a span identifier.
   *
   * @param traceparentHeader - The traceparent header to parse.
   * @returns An implementation-specific identifier for the span.
   */
  function parseTraceparentHeader(traceparentHeader) {
    return (0, _instrumenter.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
  }
  /**
   * Creates a set of request headers to propagate tracing information to a backend.
   *
   * @param tracingContext - The context containing the span to serialize.
   * @returns The set of headers to add to a request.
   */
  function createRequestHeaders(tracingContext) {
    return (0, _instrumenter.getInstrumenter)().createRequestHeaders(tracingContext);
  }
  return {
    startSpan: startSpan,
    withSpan: withSpan,
    withContext: withContext,
    parseTraceparentHeader: parseTraceparentHeader,
    createRequestHeaders: createRequestHeaders
  };
}
},{"./instrumenter":"node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js","./tracingContext":"node_modules/@azure/core-tracing/dist-esm/src/tracingContext.js"}],"node_modules/@azure/core-tracing/dist-esm/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "createTracingClient", {
  enumerable: true,
  get: function () {
    return _tracingClient.createTracingClient;
  }
});
Object.defineProperty(exports, "useInstrumenter", {
  enumerable: true,
  get: function () {
    return _instrumenter.useInstrumenter;
  }
});
var _instrumenter = require("./instrumenter");
var _tracingClient = require("./tracingClient");
},{"./instrumenter":"node_modules/@azure/core-tracing/dist-esm/src/instrumenter.js","./tracingClient":"node_modules/@azure/core-tracing/dist-esm/src/tracingClient.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.custom = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var custom = exports.custom = {};
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RestError = void 0;
exports.isRestError = isRestError;
var _coreUtil = require("@azure/core-util");
var _inspect = require("./util/inspect");
var _sanitizer = require("./util/sanitizer");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var errorSanitizer = new _sanitizer.Sanitizer();
/**
 * A custom error type for failed pipeline requests.
 */
var RestError = exports.RestError = /*#__PURE__*/function (_Error) {
  _inherits(RestError, _Error);
  var _super = _createSuper(RestError);
  function RestError(message) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, RestError);
    _this = _super.call(this, message);
    _this.name = "RestError";
    _this.code = options.code;
    _this.statusCode = options.statusCode;
    _this.request = options.request;
    _this.response = options.response;
    Object.setPrototypeOf(_assertThisInitialized(_this), RestError.prototype);
    return _this;
  }
  /**
   * Logging method for util.inspect in Node
   */
  _createClass(RestError, [{
    key: _inspect.custom,
    value: function value() {
      return "RestError: ".concat(this.message, " \n ").concat(errorSanitizer.sanitize(this));
    }
  }]);
  return RestError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Something went wrong when making the request.
 * This means the actual request failed for some reason,
 * such as a DNS issue or the connection being lost.
 */
RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
/**
 * This means that parsing the response from the server failed.
 * It may have been malformed.
 */
RestError.PARSE_ERROR = "PARSE_ERROR";
/**
 * Typeguard for RestError
 * @param e - Something caught by a catch clause.
 */
function isRestError(e) {
  if (e instanceof RestError) {
    return true;
  }
  return (0, _coreUtil.isError)(e) && e.name === "RestError";
}
},{"@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js","./util/inspect":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/inspect.browser.js","./util/sanitizer":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/sanitizer.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tracingPolicy = tracingPolicy;
exports.tracingPolicyName = void 0;
var _coreTracing = require("@azure/core-tracing");
var _constants = require("../constants");
var _userAgent = require("../util/userAgent");
var _log = require("../log");
var _coreUtil = require("@azure/core-util");
var _restError = require("../restError");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the tracingPolicy.
 */
var tracingPolicyName = exports.tracingPolicyName = "tracingPolicy";
/**
 * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
 * that has SpanOptions with a parent.
 * Requests made without a parent Span will not be recorded.
 * @param options - Options to configure the telemetry logged by the tracing policy.
 */
function tracingPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var userAgent = (0, _userAgent.getUserAgentValue)(options.userAgentPrefix);
  var tracingClient = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _a, _b, _ref, span, tracingContext, response;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(!tracingClient || !((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext))) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", next(request));
            case 2:
              _ref = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {}, span = _ref.span, tracingContext = _ref.tracingContext;
              if (!(!span || !tracingContext)) {
                _context.next = 5;
                break;
              }
              return _context.abrupt("return", next(request));
            case 5:
              _context.prev = 5;
              _context.next = 8;
              return tracingClient.withContext(tracingContext, next, request);
            case 8:
              response = _context.sent;
              tryProcessResponse(span, response);
              return _context.abrupt("return", response);
            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](5);
              tryProcessError(span, _context.t0);
              throw _context.t0;
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[5, 13]]);
      }))();
    }
  };
}
function tryCreateTracingClient() {
  try {
    return (0, _coreTracing.createTracingClient)({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: _constants.SDK_VERSION
    });
  } catch (e) {
    _log.logger.warning("Error when creating the TracingClient: ".concat((0, _coreUtil.getErrorMessage)(e)));
    return undefined;
  }
}
function tryCreateSpan(tracingClient, request, userAgent) {
  try {
    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
    var _tracingClient$startS = tracingClient.startSpan("HTTP ".concat(request.method), {
        tracingOptions: request.tracingOptions
      }, {
        spanKind: "client",
        spanAttributes: {
          "http.method": request.method,
          "http.url": request.url,
          requestId: request.requestId
        }
      }),
      span = _tracingClient$startS.span,
      updatedOptions = _tracingClient$startS.updatedOptions;
    // If the span is not recording, don't do any more work.
    if (!span.isRecording()) {
      span.end();
      return undefined;
    }
    if (userAgent) {
      span.setAttribute("http.user_agent", userAgent);
    }
    // set headers
    var headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (var _i = 0, _Object$entries = Object.entries(headers); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];
      request.headers.set(key, value);
    }
    return {
      span: span,
      tracingContext: updatedOptions.tracingOptions.tracingContext
    };
  } catch (e) {
    _log.logger.warning("Skipping creating a tracing span due to an error: ".concat((0, _coreUtil.getErrorMessage)(e)));
    return undefined;
  }
}
function tryProcessError(span, error) {
  try {
    span.setStatus({
      status: "error",
      error: (0, _coreUtil.isError)(error) ? error : undefined
    });
    if ((0, _restError.isRestError)(error) && error.statusCode) {
      span.setAttribute("http.status_code", error.statusCode);
    }
    span.end();
  } catch (e) {
    _log.logger.warning("Skipping tracing span processing due to an error: ".concat((0, _coreUtil.getErrorMessage)(e)));
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    var serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    span.setStatus({
      status: "success"
    });
    span.end();
  } catch (e) {
    _log.logger.warning("Skipping tracing span processing due to an error: ".concat((0, _coreUtil.getErrorMessage)(e)));
  }
}
},{"@azure/core-tracing":"node_modules/@azure/core-tracing/dist-esm/src/index.js","../constants":"node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js","../util/userAgent":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/userAgent.js","../log":"node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js","@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js","../restError":"node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/typeGuards.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBlob = isBlob;
exports.isNodeReadableStream = isNodeReadableStream;
exports.isReadableStream = isReadableStream;
exports.isWebReadableStream = isWebReadableStream;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isNodeReadableStream(x) {
  return Boolean(x && typeof x["pipe"] === "function");
}
function isWebReadableStream(x) {
  return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
}
function isReadableStream(x) {
  return isNodeReadableStream(x) || isWebReadableStream(x);
}
function isBlob(x) {
  return typeof x.stream === "function";
}
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/stream.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatenateStreams = concatenateStreams;
exports.toStream = toStream;
exports.toWebStream = toWebStream;
var _typeGuards = require("./typeGuards");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function toStream(source) {
  if (source instanceof Uint8Array) {
    return new Blob([source]).stream();
  } else if ((0, _typeGuards.isWebReadableStream)(source)) {
    return source;
  } else if ((0, _typeGuards.isBlob)(source)) {
    return source.stream();
  } else {
    throw new Error("Unsupported type. Only ReadableStream, Uint8Array and Blob are supported in browser");
  }
}
function toWebStream(stream) {
  if ((0, _typeGuards.isWebReadableStream)(stream)) {
    return stream;
  } else {
    throw new Error("Did not expect a Node stream in browser environment");
  }
}
function concatenateStreams(streams) {
  var _a;
  var remainingStreams = Array.from(streams);
  var reader = (_a = remainingStreams.shift()) === null || _a === void 0 ? void 0 : _a.getReader();
  function doPull(_x) {
    return _doPull.apply(this, arguments);
  }
  function _doPull() {
    _doPull = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(controller) {
      var _a, value, done, _yield$reader$read;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (reader) {
              _context.next = 3;
              break;
            }
            controller.close();
            return _context.abrupt("return");
          case 3:
            _context.prev = 3;
            _context.next = 6;
            return reader.read();
          case 6:
            _yield$reader$read = _context.sent;
            value = _yield$reader$read.value;
            done = _yield$reader$read.done;
            _context.next = 16;
            break;
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](3);
            controller.error(_context.t0);
            reader.releaseLock();
            return _context.abrupt("return");
          case 16:
            if (!done) {
              _context.next = 23;
              break;
            }
            reader.releaseLock();
            reader = (_a = remainingStreams.shift()) === null || _a === void 0 ? void 0 : _a.getReader();
            _context.next = 21;
            return doPull(controller);
          case 21:
            _context.next = 24;
            break;
          case 23:
            controller.enqueue(value);
          case 24:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[3, 11]]);
    }));
    return _doPull.apply(this, arguments);
  }
  return new ReadableStream({
    pull: function pull(controller) {
      return doPull(controller);
    },
    cancel: function cancel(reason) {
      reader === null || reader === void 0 ? void 0 : reader.cancel(reason);
    }
  });
}
},{"./typeGuards":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/typeGuards.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/multipartPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.multipartPolicy = multipartPolicy;
exports.multipartPolicyName = void 0;
var _coreUtil = require("@azure/core-util");
var _stream = require("../util/stream");
var _typeGuards = require("../util/typeGuards");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function generateBoundary() {
  return "----AzSDKFormBoundary".concat((0, _coreUtil.randomUUID)());
}
function encodeHeaders(headers) {
  var result = "";
  var _iterator = _createForOfIteratorHelper(headers),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        key = _step$value[0],
        value = _step$value[1];
      result += "".concat(key, ": ").concat(value, "\r\n");
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return result;
}
function getLength(source) {
  if (source instanceof Uint8Array) {
    return source.byteLength;
  } else if ((0, _typeGuards.isBlob)(source)) {
    // if was created using createFile then -1 means we have an unknown size
    return source.size === -1 ? undefined : source.size;
  } else {
    return undefined;
  }
}
function getTotalLength(sources) {
  var total = 0;
  var _iterator2 = _createForOfIteratorHelper(sources),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var source = _step2.value;
      var partLength = getLength(source);
      if (partLength === undefined) {
        return undefined;
      } else {
        total += partLength;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return total;
}
function buildRequestBody(request, parts, boundary) {
  var sources = [(0, _coreUtil.stringToUint8Array)("--".concat(boundary), "utf-8")].concat(_toConsumableArray(parts.flatMap(function (part) {
    return [(0, _coreUtil.stringToUint8Array)("\r\n", "utf-8"), (0, _coreUtil.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"), (0, _coreUtil.stringToUint8Array)("\r\n", "utf-8"), part.body, (0, _coreUtil.stringToUint8Array)("\r\n--".concat(boundary), "utf-8")];
  })), [(0, _coreUtil.stringToUint8Array)("--\r\n\r\n", "utf-8")]);
  var contentLength = getTotalLength(sources);
  if (contentLength) {
    request.headers.set("Content-Length", contentLength);
  }
  request.body = function () {
    return (0, _stream.concatenateStreams)(sources.map(function (source) {
      return typeof source === "function" ? source() : source;
    }).map(_stream.toStream));
  };
}
/**
 * Name of multipart policy
 */
var multipartPolicyName = exports.multipartPolicyName = "multipartPolicy";
var maxBoundaryLength = 70;
var validBoundaryCharacters = new Set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?");
function assertValidBoundary(boundary) {
  if (boundary.length > maxBoundaryLength) {
    throw new Error("Multipart boundary \"".concat(boundary, "\" exceeds maximum length of 70 characters"));
  }
  if (Array.from(boundary).some(function (x) {
    return !validBoundaryCharacters.has(x);
  })) {
    throw new Error("Multipart boundary \"".concat(boundary, "\" contains invalid characters"));
  }
}
/**
 * Pipeline policy for multipart requests
 */
function multipartPolicy() {
  return {
    name: multipartPolicyName,
    sendRequest: function sendRequest(request, next) {
      var _a;
      if (!request.multipartBody) {
        return next(request);
      }
      if (request.body) {
        throw new Error("multipartBody and regular body cannot be set at the same time");
      }
      var boundary = request.multipartBody.boundary;
      var contentTypeHeader = (_a = request.headers.get("Content-Type")) !== null && _a !== void 0 ? _a : "multipart/mixed";
      var parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
      if (!parsedHeader) {
        throw new Error("Got multipart request body, but content-type header was not multipart: ".concat(contentTypeHeader));
      }
      var _parsedHeader = _slicedToArray(parsedHeader, 3),
        contentType = _parsedHeader[1],
        parsedBoundary = _parsedHeader[2];
      if (parsedBoundary && boundary && parsedBoundary !== boundary) {
        throw new Error("Multipart boundary was specified as ".concat(parsedBoundary, " in the header, but got ").concat(boundary, " in the request body"));
      }
      boundary !== null && boundary !== void 0 ? boundary : boundary = parsedBoundary;
      if (boundary) {
        assertValidBoundary(boundary);
      } else {
        boundary = generateBoundary();
      }
      request.headers.set("Content-Type", "".concat(contentType, "; boundary=").concat(boundary));
      buildRequestBody(request, request.multipartBody.parts, boundary);
      request.multipartBody = undefined;
      return next(request);
    }
  };
}
},{"@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js","../util/stream":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/stream.browser.js","../util/typeGuards":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/typeGuards.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPipelineFromOptions = createPipelineFromOptions;
var _logPolicy = require("./policies/logPolicy");
var _pipeline = require("./pipeline");
var _redirectPolicy = require("./policies/redirectPolicy");
var _userAgentPolicy = require("./policies/userAgentPolicy");
var _decompressResponsePolicy = require("./policies/decompressResponsePolicy");
var _defaultRetryPolicy = require("./policies/defaultRetryPolicy");
var _formDataPolicy = require("./policies/formDataPolicy");
var _coreUtil = require("@azure/core-util");
var _proxyPolicy = require("./policies/proxyPolicy");
var _setClientRequestIdPolicy = require("./policies/setClientRequestIdPolicy");
var _tlsPolicy = require("./policies/tlsPolicy");
var _tracingPolicy = require("./policies/tracingPolicy");
var _multipartPolicy = require("./policies/multipartPolicy");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Create a new pipeline with a default set of customizable policies.
 * @param options - Options to configure a custom pipeline.
 */
function createPipelineFromOptions(options) {
  var _a;
  var pipeline = (0, _pipeline.createEmptyPipeline)();
  if (_coreUtil.isNode) {
    if (options.tlsOptions) {
      pipeline.addPolicy((0, _tlsPolicy.tlsPolicy)(options.tlsOptions));
    }
    pipeline.addPolicy((0, _proxyPolicy.proxyPolicy)(options.proxyOptions));
    pipeline.addPolicy((0, _decompressResponsePolicy.decompressResponsePolicy)());
  }
  pipeline.addPolicy((0, _formDataPolicy.formDataPolicy)());
  pipeline.addPolicy((0, _userAgentPolicy.userAgentPolicy)(options.userAgentOptions));
  pipeline.addPolicy((0, _setClientRequestIdPolicy.setClientRequestIdPolicy)((_a = options.telemetryOptions) === null || _a === void 0 ? void 0 : _a.clientRequestIdHeaderName));
  // The multipart policy is added after policies with no phase, so that
  // policies can be added between it and formDataPolicy to modify
  // properties (e.g., making the boundary constant in recorded tests).
  pipeline.addPolicy((0, _multipartPolicy.multipartPolicy)(), {
    afterPhase: "Deserialize"
  });
  pipeline.addPolicy((0, _defaultRetryPolicy.defaultRetryPolicy)(options.retryOptions), {
    phase: "Retry"
  });
  pipeline.addPolicy((0, _tracingPolicy.tracingPolicy)(options.userAgentOptions), {
    afterPhase: "Retry"
  });
  if (_coreUtil.isNode) {
    // Both XHR and Fetch expect to handle redirects automatically,
    // so only include this policy when we're in Node.
    pipeline.addPolicy((0, _redirectPolicy.redirectPolicy)(options.redirectOptions), {
      afterPhase: "Retry"
    });
  }
  pipeline.addPolicy((0, _logPolicy.logPolicy)(options.loggingOptions), {
    afterPhase: "Sign"
  });
  return pipeline;
}
},{"./policies/logPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js","./pipeline":"node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js","./policies/redirectPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js","./policies/userAgentPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js","./policies/decompressResponsePolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.browser.js","./policies/defaultRetryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js","./policies/formDataPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.js","@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js","./policies/proxyPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.browser.js","./policies/setClientRequestIdPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js","./policies/tlsPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js","./policies/tracingPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js","./policies/multipartPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/multipartPolicy.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/fetchHttpClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFetchHttpClient = createFetchHttpClient;
var _abortController = require("@azure/abort-controller");
var _restError = require("./restError");
var _httpHeaders = require("./httpHeaders");
var _typeGuards = require("./util/typeGuards");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Checks if the body is a Blob or Blob-like
 */
function isBlob(body) {
  // File objects count as a type of Blob, so we want to use instanceof explicitly
  return (typeof Blob === "function" || (typeof Blob === "undefined" ? "undefined" : _typeof(Blob)) === "object") && body instanceof Blob;
}
/**
 * A HttpClient implementation that uses window.fetch to send HTTP requests.
 * @internal
 */
var FetchHttpClient = /*#__PURE__*/function () {
  function FetchHttpClient() {
    _classCallCheck(this, FetchHttpClient);
  }
  _createClass(FetchHttpClient, [{
    key: "sendRequest",
    value: (
    /**
     * Makes a request over an underlying transport layer and returns the response.
     * @param request - The request to be made.
     */
    function () {
      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var url, isInsecure;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              url = new URL(request.url);
              isInsecure = url.protocol !== "https:";
              if (!(isInsecure && !request.allowInsecureConnection)) {
                _context.next = 4;
                break;
              }
              throw new Error("Cannot connect to ".concat(request.url, " while allowInsecureConnection is false."));
            case 4:
              if (!request.proxySettings) {
                _context.next = 6;
                break;
              }
              throw new Error("HTTP proxy is not supported in browser environment");
            case 6:
              _context.prev = 6;
              _context.next = 9;
              return makeRequest(request);
            case 9:
              return _context.abrupt("return", _context.sent);
            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](6);
              throw getError(_context.t0, request);
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[6, 12]]);
      }));
      function sendRequest(_x) {
        return _sendRequest.apply(this, arguments);
      }
      return sendRequest;
    }())
  }]);
  return FetchHttpClient;
}();
/**
 * Sends a request
 */
function makeRequest(_x2) {
  return _makeRequest.apply(this, arguments);
}
/**
 * Creates a pipeline response from a Fetch response;
 */
function _makeRequest() {
  _makeRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
    var _setupAbortSignal, abortController, abortControllerCleanup, headers, _buildRequestBody, streaming, requestBody, requestInit, response;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _setupAbortSignal = setupAbortSignal(request), abortController = _setupAbortSignal.abortController, abortControllerCleanup = _setupAbortSignal.abortControllerCleanup;
          _context3.prev = 1;
          headers = buildFetchHeaders(request.headers);
          _buildRequestBody = buildRequestBody(request), streaming = _buildRequestBody.streaming, requestBody = _buildRequestBody.body;
          requestInit = Object.assign(Object.assign({
            body: requestBody,
            method: request.method,
            headers: headers,
            signal: abortController.signal
          }, "credentials" in Request.prototype ? {
            credentials: request.withCredentials ? "include" : "same-origin"
          } : {}), "cache" in Request.prototype ? {
            cache: "no-store"
          } : {}); // According to https://fetch.spec.whatwg.org/#fetch-method,
          // init.duplex must be set when body is a ReadableStream object.
          // currently "half" is the only valid value.
          if (streaming) {
            requestInit.duplex = "half";
          }
          /**
           * Developers of the future:
           * Do not set redirect: "manual" as part
           * of request options.
           * It will not work as you expect.
           */
          _context3.next = 8;
          return fetch(request.url, requestInit);
        case 8:
          response = _context3.sent;
          // If we're uploading a blob, we need to fire the progress event manually
          if (isBlob(request.body) && request.onUploadProgress) {
            request.onUploadProgress({
              loadedBytes: request.body.size
            });
          }
          return _context3.abrupt("return", buildPipelineResponse(response, request, abortControllerCleanup));
        case 13:
          _context3.prev = 13;
          _context3.t0 = _context3["catch"](1);
          abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
          throw _context3.t0;
        case 17:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[1, 13]]);
  }));
  return _makeRequest.apply(this, arguments);
}
function buildPipelineResponse(_x3, _x4, _x5) {
  return _buildPipelineResponse.apply(this, arguments);
}
function _buildPipelineResponse() {
  _buildPipelineResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(httpResponse, request, abortControllerCleanup) {
    var _a, _b, headers, response, bodyStream, responseStream, _responseStream;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          headers = buildPipelineHeaders(httpResponse);
          response = {
            request: request,
            headers: headers,
            status: httpResponse.status
          };
          bodyStream = (0, _typeGuards.isWebReadableStream)(httpResponse.body) ? buildBodyStream(httpResponse.body, {
            onProgress: request.onDownloadProgress,
            onEnd: abortControllerCleanup
          }) : httpResponse.body;
          if (!(
          // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
          ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status)))) {
            _context4.next = 7;
            break;
          }
          if (request.enableBrowserStreams) {
            response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;
          } else {
            responseStream = new Response(bodyStream);
            response.blobBody = responseStream.blob();
            abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
          }
          _context4.next = 12;
          break;
        case 7:
          _responseStream = new Response(bodyStream);
          _context4.next = 10;
          return _responseStream.text();
        case 10:
          response.bodyAsText = _context4.sent;
          abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
        case 12:
          return _context4.abrupt("return", response);
        case 13:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _buildPipelineResponse.apply(this, arguments);
}
function setupAbortSignal(request) {
  var abortController = new AbortController();
  // Cleanup function
  var abortControllerCleanup;
  /**
   * Attach an abort listener to the request
   */
  var abortListener;
  if (request.abortSignal) {
    if (request.abortSignal.aborted) {
      throw new _abortController.AbortError("The operation was aborted.");
    }
    abortListener = function abortListener(event) {
      if (event.type === "abort") {
        abortController.abort();
      }
    };
    request.abortSignal.addEventListener("abort", abortListener);
    abortControllerCleanup = function abortControllerCleanup() {
      var _a;
      if (abortListener) {
        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", abortListener);
      }
    };
  }
  // If a timeout was passed, call the abort signal once the time elapses
  if (request.timeout > 0) {
    setTimeout(function () {
      abortController.abort();
    }, request.timeout);
  }
  return {
    abortController: abortController,
    abortControllerCleanup: abortControllerCleanup
  };
}
/**
 * Gets the specific error
 */
function getError(e, request) {
  var _a;
  if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
    return e;
  } else {
    return new _restError.RestError("Error sending request: ".concat(e.message), {
      code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : _restError.RestError.REQUEST_SEND_ERROR,
      request: request
    });
  }
}
/**
 * Converts PipelineRequest headers to Fetch headers
 */
function buildFetchHeaders(pipelineHeaders) {
  var headers = new Headers();
  var _iterator = _createForOfIteratorHelper(pipelineHeaders),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        name = _step$value[0],
        value = _step$value[1];
      headers.append(name, value);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return headers;
}
function buildPipelineHeaders(httpResponse) {
  var responseHeaders = (0, _httpHeaders.createHttpHeaders)();
  var _iterator2 = _createForOfIteratorHelper(httpResponse.headers),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
        name = _step2$value[0],
        value = _step2$value[1];
      responseHeaders.set(name, value);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return responseHeaders;
}
function buildRequestBody(request) {
  var body = typeof request.body === "function" ? request.body() : request.body;
  if ((0, _typeGuards.isNodeReadableStream)(body)) {
    throw new Error("Node streams are not supported in browser environment.");
  }
  return (0, _typeGuards.isWebReadableStream)(body) ? {
    streaming: true,
    body: buildBodyStream(body, {
      onProgress: request.onUploadProgress
    })
  } : {
    streaming: false,
    body: body
  };
}
/**
 * Reads the request/response original stream and stream it through a new
 * ReadableStream, this is done to be able to report progress in a way that
 * all modern browsers support. TransformStreams would be an alternative,
 * however they are not yet supported by all browsers i.e Firefox
 */
function buildBodyStream(readableStream) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var loadedBytes = 0;
  var onProgress = options.onProgress,
    onEnd = options.onEnd;
  // If the current browser supports pipeThrough we use a TransformStream
  // to report progress
  if (isTransformStreamSupported(readableStream)) {
    return readableStream.pipeThrough(new TransformStream({
      transform: function transform(chunk, controller) {
        if (chunk === null) {
          controller.terminate();
          return;
        }
        controller.enqueue(chunk);
        loadedBytes += chunk.length;
        if (onProgress) {
          onProgress({
            loadedBytes: loadedBytes
          });
        }
      },
      flush: function flush() {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      }
    }));
  } else {
    // If we can't use transform streams, wrap the original stream in a new readable stream
    // and use pull to enqueue each chunk and report progress.
    var reader = readableStream.getReader();
    return new ReadableStream({
      pull: function pull(controller) {
        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var _a, _yield$reader$read, done, value;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return reader.read();
              case 2:
                _yield$reader$read = _context2.sent;
                done = _yield$reader$read.done;
                value = _yield$reader$read.value;
                if (!(done || !value)) {
                  _context2.next = 10;
                  break;
                }
                onEnd === null || onEnd === void 0 ? void 0 : onEnd();
                // Close the stream
                controller.close();
                reader.releaseLock();
                return _context2.abrupt("return");
              case 10:
                loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;
                // Enqueue the next data chunk into our target stream
                controller.enqueue(value);
                if (onProgress) {
                  onProgress({
                    loadedBytes: loadedBytes
                  });
                }
              case 13:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }))();
      },
      cancel: function cancel(reason) {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
        return reader.cancel(reason);
      }
    });
  }
}
/**
 * Create a new HttpClient instance for the browser environment.
 * @internal
 */
function createFetchHttpClient() {
  return new FetchHttpClient();
}
function isTransformStreamSupported(readableStream) {
  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;
}
},{"@azure/abort-controller":"node_modules/@azure/abort-controller/dist-esm/src/index.js","./restError":"node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js","./httpHeaders":"node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js","./util/typeGuards":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/typeGuards.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDefaultHttpClient = createDefaultHttpClient;
var _fetchHttpClient = require("./fetchHttpClient");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Create the correct HttpClient for the current environment.
 */
function createDefaultHttpClient() {
  return (0, _fetchHttpClient.createFetchHttpClient)();
}
},{"./fetchHttpClient":"node_modules/@azure/core-rest-pipeline/dist-esm/src/fetchHttpClient.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPipelineRequest = createPipelineRequest;
var _httpHeaders = require("./httpHeaders");
var _coreUtil = require("@azure/core-util");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var PipelineRequestImpl = /*#__PURE__*/_createClass(function PipelineRequestImpl(options) {
  _classCallCheck(this, PipelineRequestImpl);
  var _a, _b, _c, _d, _e, _f, _g;
  this.url = options.url;
  this.body = options.body;
  this.headers = (_a = options.headers) !== null && _a !== void 0 ? _a : (0, _httpHeaders.createHttpHeaders)();
  this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET";
  this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;
  this.multipartBody = options.multipartBody;
  this.formData = options.formData;
  this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;
  this.proxySettings = options.proxySettings;
  this.streamResponseStatusCodes = options.streamResponseStatusCodes;
  this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
  this.abortSignal = options.abortSignal;
  this.tracingOptions = options.tracingOptions;
  this.onUploadProgress = options.onUploadProgress;
  this.onDownloadProgress = options.onDownloadProgress;
  this.requestId = options.requestId || (0, _coreUtil.randomUUID)();
  this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
  this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
});
/**
 * Creates a new pipeline request with the given options.
 * This method is to allow for the easy setting of default values and not required.
 * @param options - The options to create the request with.
 */
function createPipelineRequest(options) {
  return new PipelineRequestImpl(options);
}
},{"./httpHeaders":"node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js","@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/exponentialRetryPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exponentialRetryPolicy = exponentialRetryPolicy;
exports.exponentialRetryPolicyName = void 0;
var _exponentialRetryStrategy = require("../retryStrategies/exponentialRetryStrategy");
var _retryPolicy = require("./retryPolicy");
var _constants = require("../constants");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The programmatic identifier of the exponentialRetryPolicy.
 */
var exponentialRetryPolicyName = exports.exponentialRetryPolicyName = "exponentialRetryPolicy";
/**
 * A policy that attempts to retry requests while introducing an exponentially increasing delay.
 * @param options - Options that configure retry logic.
 */
function exponentialRetryPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _a;
  return (0, _retryPolicy.retryPolicy)([(0, _exponentialRetryStrategy.exponentialRetryStrategy)(Object.assign(Object.assign({}, options), {
    ignoreSystemErrors: true
  }))], {
    maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : _constants.DEFAULT_RETRY_POLICY_COUNT
  });
}
},{"../retryStrategies/exponentialRetryStrategy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js","./retryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js","../constants":"node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/systemErrorRetryPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
exports.systemErrorRetryPolicyName = void 0;
var _exponentialRetryStrategy = require("../retryStrategies/exponentialRetryStrategy");
var _retryPolicy = require("./retryPolicy");
var _constants = require("../constants");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Name of the {@link systemErrorRetryPolicy}
 */
var systemErrorRetryPolicyName = exports.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
/**
 * A retry policy that specifically seeks to handle errors in the
 * underlying transport layer (e.g. DNS lookup failures) rather than
 * retryable error codes from the server itself.
 * @param options - Options that customize the policy.
 */
function systemErrorRetryPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _a;
  return {
    name: systemErrorRetryPolicyName,
    sendRequest: (0, _retryPolicy.retryPolicy)([(0, _exponentialRetryStrategy.exponentialRetryStrategy)(Object.assign(Object.assign({}, options), {
      ignoreHttpStatusCodes: true
    }))], {
      maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : _constants.DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}
},{"../retryStrategies/exponentialRetryStrategy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/exponentialRetryStrategy.js","./retryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js","../constants":"node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/throttlingRetryPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.throttlingRetryPolicy = throttlingRetryPolicy;
exports.throttlingRetryPolicyName = void 0;
var _throttlingRetryStrategy = require("../retryStrategies/throttlingRetryStrategy");
var _retryPolicy = require("./retryPolicy");
var _constants = require("../constants");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Name of the {@link throttlingRetryPolicy}
 */
var throttlingRetryPolicyName = exports.throttlingRetryPolicyName = "throttlingRetryPolicy";
/**
 * A policy that retries when the server sends a 429 response with a Retry-After header.
 *
 * To learn more, please refer to
 * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,
 * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and
 * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
 *
 * @param options - Options that configure retry logic.
 */
function throttlingRetryPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _a;
  return {
    name: throttlingRetryPolicyName,
    sendRequest: (0, _retryPolicy.retryPolicy)([(0, _throttlingRetryStrategy.throttlingRetryStrategy)()], {
      maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : _constants.DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}
},{"../retryStrategies/throttlingRetryStrategy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/retryStrategies/throttlingRetryStrategy.js","./retryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js","../constants":"node_modules/@azure/core-rest-pipeline/dist-esm/src/constants.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_CYCLER_OPTIONS = void 0;
exports.createTokenCycler = createTokenCycler;
var _helpers = require("./helpers");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Default options for the cycler if none are provided
var DEFAULT_CYCLER_OPTIONS = exports.DEFAULT_CYCLER_OPTIONS = {
  forcedRefreshWindowInMs: 1000,
  retryIntervalInMs: 3000,
  refreshWindowInMs: 1000 * 60 * 2 // Start refreshing 2m before expiry
};
/**
 * Converts an an unreliable access token getter (which may resolve with null)
 * into an AccessTokenGetter by retrying the unreliable getter in a regular
 * interval.
 *
 * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
 * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
 * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
 * @returns - A promise that, if it resolves, will resolve with an access token.
 */
function beginRefresh(_x, _x2, _x3) {
  return _beginRefresh.apply(this, arguments);
}
/**
 * Creates a token cycler from a credential, scopes, and optional settings.
 *
 * A token cycler represents a way to reliably retrieve a valid access token
 * from a TokenCredential. It will handle initializing the token, refreshing it
 * when it nears expiration, and synchronizes refresh attempts to avoid
 * concurrency hazards.
 *
 * @param credential - the underlying TokenCredential that provides the access
 * token
 * @param tokenCyclerOptions - optionally override default settings for the cycler
 *
 * @returns - a function that reliably produces a valid access token
 */
function _beginRefresh() {
  _beginRefresh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(getAccessToken, retryIntervalInMs, refreshTimeout) {
    var tryGetAccessToken, _tryGetAccessToken, token;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _tryGetAccessToken = function _tryGetAccessToken3() {
            _tryGetAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
              var finalToken;
              return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!(Date.now() < refreshTimeout)) {
                      _context2.next = 12;
                      break;
                    }
                    _context2.prev = 1;
                    _context2.next = 4;
                    return getAccessToken();
                  case 4:
                    return _context2.abrupt("return", _context2.sent);
                  case 7:
                    _context2.prev = 7;
                    _context2.t0 = _context2["catch"](1);
                    return _context2.abrupt("return", null);
                  case 10:
                    _context2.next = 18;
                    break;
                  case 12:
                    _context2.next = 14;
                    return getAccessToken();
                  case 14:
                    finalToken = _context2.sent;
                    if (!(finalToken === null)) {
                      _context2.next = 17;
                      break;
                    }
                    throw new Error("Failed to refresh access token.");
                  case 17:
                    return _context2.abrupt("return", finalToken);
                  case 18:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2, null, [[1, 7]]);
            }));
            return _tryGetAccessToken.apply(this, arguments);
          };
          tryGetAccessToken = function _tryGetAccessToken2() {
            return _tryGetAccessToken.apply(this, arguments);
          }; // This wrapper handles exceptions gracefully as long as we haven't exceeded
          // the timeout.
          _context3.next = 4;
          return tryGetAccessToken();
        case 4:
          token = _context3.sent;
        case 5:
          if (!(token === null)) {
            _context3.next = 13;
            break;
          }
          _context3.next = 8;
          return (0, _helpers.delay)(retryIntervalInMs);
        case 8:
          _context3.next = 10;
          return tryGetAccessToken();
        case 10:
          token = _context3.sent;
          _context3.next = 5;
          break;
        case 13:
          return _context3.abrupt("return", token);
        case 14:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _beginRefresh.apply(this, arguments);
}
function createTokenCycler(credential, tokenCyclerOptions) {
  var refreshWorker = null;
  var token = null;
  var tenantId;
  var options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  /**
   * This little holder defines several predicates that we use to construct
   * the rules of refreshing the token.
   */
  var cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a;
      return !cycler.isRefreshing && ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  /**
   * Starts a refresh job or returns the existing job if one is already
   * running.
   */
  function refresh(scopes, getTokenOptions) {
    var _a;
    if (!cycler.isRefreshing) {
      // We bind `scopes` here to avoid passing it around a lot
      var tryGetAccessToken = function tryGetAccessToken() {
        return credential.getToken(scopes, getTokenOptions);
      };
      // Take advantage of promise chaining to insert an assignment to `token`
      // before the refresh can be considered done.
      refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs,
      // If we don't have a token, then we should timeout immediately
      (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now()).then(function (_token) {
        refreshWorker = null;
        token = _token;
        tenantId = getTokenOptions.tenantId;
        return token;
      }).catch(function (reason) {
        // We also should reset the refresher if we enter a failed state.  All
        // existing awaiters will throw, but subsequent requests will start a
        // new retry chain.
        refreshWorker = null;
        token = null;
        tenantId = undefined;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(scopes, tokenOptions) {
      var mustRefresh;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            //
            // Simple rules:
            // - If we MUST refresh, then return the refresh task, blocking
            //   the pipeline until a token is available.
            // - If we SHOULD refresh, then run refresh but don't return it
            //   (we can still use the cached token).
            // - Return the token, since it's fine if we didn't return in
            //   step 1.
            //
            // If the tenantId passed in token options is different to the one we have
            // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to
            // refresh the token with the new tenantId or token.
            mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
            if (!mustRefresh) {
              _context.next = 3;
              break;
            }
            return _context.abrupt("return", refresh(scopes, tokenOptions));
          case 3:
            if (cycler.shouldRefresh) {
              refresh(scopes, tokenOptions);
            }
            return _context.abrupt("return", token);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x4, _x5) {
      return _ref.apply(this, arguments);
    };
  }();
}
},{"./helpers":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/helpers.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
exports.bearerTokenAuthenticationPolicyName = void 0;
var _tokenCycler = require("../util/tokenCycler");
var _log = require("../log");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the bearerTokenAuthenticationPolicy.
 */
var bearerTokenAuthenticationPolicyName = exports.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
/**
 * Default authorize request handler
 */
function defaultAuthorizeRequest(_x) {
  return _defaultAuthorizeRequest.apply(this, arguments);
}
/**
 * We will retrieve the challenge only if the response status code was 401,
 * and if the response contained the header "WWW-Authenticate" with a non-empty value.
 */
function _defaultAuthorizeRequest() {
  _defaultAuthorizeRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
    var scopes, getAccessToken, request, getTokenOptions, accessToken;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          scopes = options.scopes, getAccessToken = options.getAccessToken, request = options.request;
          getTokenOptions = {
            abortSignal: request.abortSignal,
            tracingOptions: request.tracingOptions
          };
          _context2.next = 4;
          return getAccessToken(scopes, getTokenOptions);
        case 4:
          accessToken = _context2.sent;
          if (accessToken) {
            options.request.headers.set("Authorization", "Bearer ".concat(accessToken.token));
          }
        case 6:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _defaultAuthorizeRequest.apply(this, arguments);
}
function getChallenge(response) {
  var challenge = response.headers.get("WWW-Authenticate");
  if (response.status === 401 && challenge) {
    return challenge;
  }
  return;
}
/**
 * A policy that can request a token from a TokenCredential implementation and
 * then apply it to the Authorization header of a request as a Bearer token.
 */
function bearerTokenAuthenticationPolicy(options) {
  var _a;
  var credential = options.credential,
    scopes = options.scopes,
    challengeCallbacks = options.challengeCallbacks;
  var logger = options.logger || _log.logger;
  var callbacks = Object.assign({
    authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest,
    authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge
  }, challengeCallbacks);
  // This function encapsulates the entire process of reliably retrieving the token
  // The options are left out of the public API until there's demand to configure this.
  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`
  // in order to pass through the `options` object.
  var getAccessToken = credential ? (0, _tokenCycler.createTokenCycler)(credential /* , options */) : function () {
    return Promise.resolve(null);
  };
  return {
    name: bearerTokenAuthenticationPolicyName,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var response, error, shouldSendRequest;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (request.url.toLowerCase().startsWith("https://")) {
                _context.next = 2;
                break;
              }
              throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
            case 2:
              _context.next = 4;
              return callbacks.authorizeRequest({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                request: request,
                getAccessToken: getAccessToken,
                logger: logger
              });
            case 4:
              _context.prev = 4;
              _context.next = 7;
              return next(request);
            case 7:
              response = _context.sent;
              _context.next = 14;
              break;
            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](4);
              error = _context.t0;
              response = _context.t0.response;
            case 14:
              if (!(callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response))) {
                _context.next = 20;
                break;
              }
              _context.next = 17;
              return callbacks.authorizeRequestOnChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                request: request,
                response: response,
                getAccessToken: getAccessToken,
                logger: logger
              });
            case 17:
              shouldSendRequest = _context.sent;
              if (!shouldSendRequest) {
                _context.next = 20;
                break;
              }
              return _context.abrupt("return", next(request));
            case 20:
              if (!error) {
                _context.next = 24;
                break;
              }
              throw error;
            case 24:
              return _context.abrupt("return", response);
            case 25:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[4, 10]]);
      }))();
    }
  };
}
},{"../util/tokenCycler":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js","../log":"node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/ndJsonPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ndJsonPolicy = ndJsonPolicy;
exports.ndJsonPolicyName = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the ndJsonPolicy.
 */
var ndJsonPolicyName = exports.ndJsonPolicyName = "ndJsonPolicy";
/**
 * ndJsonPolicy is a policy used to control keep alive settings for every request.
 */
function ndJsonPolicy() {
  return {
    name: ndJsonPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var body;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // There currently isn't a good way to bypass the serializer
              if (typeof request.body === "string" && request.body.startsWith("[")) {
                body = JSON.parse(request.body);
                if (Array.isArray(body)) {
                  request.body = body.map(function (item) {
                    return JSON.stringify(item) + "\n";
                  }).join("");
                }
              }
              return _context.abrupt("return", next(request));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
},{}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/auxiliaryAuthenticationHeaderPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
exports.auxiliaryAuthenticationHeaderPolicyName = void 0;
var _tokenCycler = require("../util/tokenCycler");
var _log = require("../log");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.
 */
var auxiliaryAuthenticationHeaderPolicyName = exports.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
function sendAuthorizeRequest(_x) {
  return _sendAuthorizeRequest.apply(this, arguments);
}
/**
 * A policy for external tokens to `x-ms-authorization-auxiliary` header.
 * This header will be used when creating a cross-tenant application we may need to handle authentication requests
 * for resources that are in different tenants.
 * You could see [ARM docs](https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works
 */
function _sendAuthorizeRequest() {
  _sendAuthorizeRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
    var _a, _b, scopes, getAccessToken, request, getTokenOptions;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          scopes = options.scopes, getAccessToken = options.getAccessToken, request = options.request;
          getTokenOptions = {
            abortSignal: request.abortSignal,
            tracingOptions: request.tracingOptions
          };
          _context2.next = 4;
          return getAccessToken(scopes, getTokenOptions);
        case 4:
          _context2.t2 = _a = _context2.sent;
          _context2.t1 = _context2.t2 === null;
          if (_context2.t1) {
            _context2.next = 8;
            break;
          }
          _context2.t1 = _a === void 0;
        case 8:
          if (!_context2.t1) {
            _context2.next = 12;
            break;
          }
          _context2.t3 = void 0;
          _context2.next = 13;
          break;
        case 12:
          _context2.t3 = _a.token;
        case 13:
          _context2.t4 = _b = _context2.t3;
          _context2.t0 = _context2.t4 !== null;
          if (!_context2.t0) {
            _context2.next = 17;
            break;
          }
          _context2.t0 = _b !== void 0;
        case 17:
          if (!_context2.t0) {
            _context2.next = 21;
            break;
          }
          _context2.t5 = _b;
          _context2.next = 22;
          break;
        case 21:
          _context2.t5 = "";
        case 22:
          return _context2.abrupt("return", _context2.t5);
        case 23:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _sendAuthorizeRequest.apply(this, arguments);
}
function auxiliaryAuthenticationHeaderPolicy(options) {
  var credentials = options.credentials,
    scopes = options.scopes;
  var logger = options.logger || _log.logger;
  var tokenCyclerMap = new WeakMap();
  return {
    name: auxiliaryAuthenticationHeaderPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var tokenPromises, _iterator, _step, credential, getAccessToken, auxiliaryTokens;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (request.url.toLowerCase().startsWith("https://")) {
                _context.next = 2;
                break;
              }
              throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
            case 2:
              if (!(!credentials || credentials.length === 0)) {
                _context.next = 5;
                break;
              }
              logger.info("".concat(auxiliaryAuthenticationHeaderPolicyName, " header will not be set due to empty credentials."));
              return _context.abrupt("return", next(request));
            case 5:
              tokenPromises = [];
              _iterator = _createForOfIteratorHelper(credentials);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  credential = _step.value;
                  getAccessToken = tokenCyclerMap.get(credential);
                  if (!getAccessToken) {
                    getAccessToken = (0, _tokenCycler.createTokenCycler)(credential);
                    tokenCyclerMap.set(credential, getAccessToken);
                  }
                  tokenPromises.push(sendAuthorizeRequest({
                    scopes: Array.isArray(scopes) ? scopes : [scopes],
                    request: request,
                    getAccessToken: getAccessToken,
                    logger: logger
                  }));
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              _context.next = 10;
              return Promise.all(tokenPromises);
            case 10:
              auxiliaryTokens = _context.sent.filter(function (token) {
                return Boolean(token);
              });
              if (!(auxiliaryTokens.length === 0)) {
                _context.next = 14;
                break;
              }
              logger.warning("None of the auxiliary tokens are valid. ".concat(AUTHORIZATION_AUXILIARY_HEADER, " header will not be set."));
              return _context.abrupt("return", next(request));
            case 14:
              request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map(function (token) {
                return "Bearer ".concat(token);
              }).join(", "));
              return _context.abrupt("return", next(request));
            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
},{"../util/tokenCycler":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/tokenCycler.js","../log":"node_modules/@azure/core-rest-pipeline/dist-esm/src/log.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/file.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFile = createFile;
exports.createFileFromStream = createFileFromStream;
var _stream2 = require("./stream");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var unimplementedMethods = {
  arrayBuffer: function arrayBuffer() {
    throw new Error("Not implemented");
  },
  slice: function slice() {
    throw new Error("Not implemented");
  },
  text: function text() {
    throw new Error("Not implemented");
  }
};
/**
 * Create an object that implements the File interface. This object is intended to be
 * passed into RequestBodyType.formData, and is not guaranteed to work as expected in
 * other situations.
 *
 * Use this function to:
 * - Create a File object for use in RequestBodyType.formData in environments where the
 *   global File object is unavailable.
 * - Create a File-like object from a readable stream without reading the stream into memory.
 *
 * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is
 *                  passed in a request's form data map, the stream will not be read into memory
 *                  and instead will be streamed when the request is made. In the event of a retry, the
 *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.
 * @param name - the name of the file.
 * @param options - optional metadata about the file, e.g. file name, file size, MIME type.
 */
function createFileFromStream(_stream, name) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _a, _b, _c, _d;
  return Object.assign(Object.assign({}, unimplementedMethods), {
    type: (_a = options.type) !== null && _a !== void 0 ? _a : "",
    lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(),
    webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : "",
    size: (_d = options.size) !== null && _d !== void 0 ? _d : -1,
    name: name,
    stream: function stream() {
      return (0, _stream2.toWebStream)(_stream());
    }
  });
}
/**
 * Create an object that implements the File interface. This object is intended to be
 * passed into RequestBodyType.formData, and is not guaranteed to work as expected in
 * other situations.
 *
 * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.
 *
 * @param content - the content of the file as a Uint8Array in memory.
 * @param name - the name of the file.
 * @param options - optional metadata about the file, e.g. file name, file size, MIME type.
 */
function createFile(content, name) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _a, _b, _c;
  return Object.assign(Object.assign({}, unimplementedMethods), {
    type: (_a = options.type) !== null && _a !== void 0 ? _a : "",
    lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(),
    webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : "",
    size: content.byteLength,
    name: name,
    arrayBuffer: function () {
      var _arrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", content.buffer);
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function arrayBuffer() {
        return _arrayBuffer.apply(this, arguments);
      }
      return arrayBuffer;
    }(),
    stream: function stream() {
      return new Blob([content]).stream();
    }
  });
}
},{"./stream":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/stream.browser.js"}],"node_modules/@azure/core-rest-pipeline/dist-esm/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "RestError", {
  enumerable: true,
  get: function () {
    return _restError.RestError;
  }
});
Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicy", {
  enumerable: true,
  get: function () {
    return _auxiliaryAuthenticationHeaderPolicy.auxiliaryAuthenticationHeaderPolicy;
  }
});
Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicyName", {
  enumerable: true,
  get: function () {
    return _auxiliaryAuthenticationHeaderPolicy.auxiliaryAuthenticationHeaderPolicyName;
  }
});
Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", {
  enumerable: true,
  get: function () {
    return _bearerTokenAuthenticationPolicy.bearerTokenAuthenticationPolicy;
  }
});
Object.defineProperty(exports, "bearerTokenAuthenticationPolicyName", {
  enumerable: true,
  get: function () {
    return _bearerTokenAuthenticationPolicy.bearerTokenAuthenticationPolicyName;
  }
});
Object.defineProperty(exports, "createDefaultHttpClient", {
  enumerable: true,
  get: function () {
    return _defaultHttpClient.createDefaultHttpClient;
  }
});
Object.defineProperty(exports, "createEmptyPipeline", {
  enumerable: true,
  get: function () {
    return _pipeline.createEmptyPipeline;
  }
});
Object.defineProperty(exports, "createFile", {
  enumerable: true,
  get: function () {
    return _file.createFile;
  }
});
Object.defineProperty(exports, "createFileFromStream", {
  enumerable: true,
  get: function () {
    return _file.createFileFromStream;
  }
});
Object.defineProperty(exports, "createHttpHeaders", {
  enumerable: true,
  get: function () {
    return _httpHeaders.createHttpHeaders;
  }
});
Object.defineProperty(exports, "createPipelineFromOptions", {
  enumerable: true,
  get: function () {
    return _createPipelineFromOptions.createPipelineFromOptions;
  }
});
Object.defineProperty(exports, "createPipelineRequest", {
  enumerable: true,
  get: function () {
    return _pipelineRequest.createPipelineRequest;
  }
});
Object.defineProperty(exports, "decompressResponsePolicy", {
  enumerable: true,
  get: function () {
    return _decompressResponsePolicy.decompressResponsePolicy;
  }
});
Object.defineProperty(exports, "decompressResponsePolicyName", {
  enumerable: true,
  get: function () {
    return _decompressResponsePolicy.decompressResponsePolicyName;
  }
});
Object.defineProperty(exports, "defaultRetryPolicy", {
  enumerable: true,
  get: function () {
    return _defaultRetryPolicy.defaultRetryPolicy;
  }
});
Object.defineProperty(exports, "exponentialRetryPolicy", {
  enumerable: true,
  get: function () {
    return _exponentialRetryPolicy.exponentialRetryPolicy;
  }
});
Object.defineProperty(exports, "exponentialRetryPolicyName", {
  enumerable: true,
  get: function () {
    return _exponentialRetryPolicy.exponentialRetryPolicyName;
  }
});
Object.defineProperty(exports, "formDataPolicy", {
  enumerable: true,
  get: function () {
    return _formDataPolicy.formDataPolicy;
  }
});
Object.defineProperty(exports, "formDataPolicyName", {
  enumerable: true,
  get: function () {
    return _formDataPolicy.formDataPolicyName;
  }
});
Object.defineProperty(exports, "getDefaultProxySettings", {
  enumerable: true,
  get: function () {
    return _proxyPolicy.getDefaultProxySettings;
  }
});
Object.defineProperty(exports, "isRestError", {
  enumerable: true,
  get: function () {
    return _restError.isRestError;
  }
});
Object.defineProperty(exports, "logPolicy", {
  enumerable: true,
  get: function () {
    return _logPolicy.logPolicy;
  }
});
Object.defineProperty(exports, "logPolicyName", {
  enumerable: true,
  get: function () {
    return _logPolicy.logPolicyName;
  }
});
Object.defineProperty(exports, "multipartPolicy", {
  enumerable: true,
  get: function () {
    return _multipartPolicy.multipartPolicy;
  }
});
Object.defineProperty(exports, "multipartPolicyName", {
  enumerable: true,
  get: function () {
    return _multipartPolicy.multipartPolicyName;
  }
});
Object.defineProperty(exports, "ndJsonPolicy", {
  enumerable: true,
  get: function () {
    return _ndJsonPolicy.ndJsonPolicy;
  }
});
Object.defineProperty(exports, "ndJsonPolicyName", {
  enumerable: true,
  get: function () {
    return _ndJsonPolicy.ndJsonPolicyName;
  }
});
Object.defineProperty(exports, "proxyPolicy", {
  enumerable: true,
  get: function () {
    return _proxyPolicy.proxyPolicy;
  }
});
Object.defineProperty(exports, "proxyPolicyName", {
  enumerable: true,
  get: function () {
    return _proxyPolicy.proxyPolicyName;
  }
});
Object.defineProperty(exports, "redirectPolicy", {
  enumerable: true,
  get: function () {
    return _redirectPolicy.redirectPolicy;
  }
});
Object.defineProperty(exports, "redirectPolicyName", {
  enumerable: true,
  get: function () {
    return _redirectPolicy.redirectPolicyName;
  }
});
Object.defineProperty(exports, "retryPolicy", {
  enumerable: true,
  get: function () {
    return _retryPolicy.retryPolicy;
  }
});
Object.defineProperty(exports, "setClientRequestIdPolicy", {
  enumerable: true,
  get: function () {
    return _setClientRequestIdPolicy.setClientRequestIdPolicy;
  }
});
Object.defineProperty(exports, "setClientRequestIdPolicyName", {
  enumerable: true,
  get: function () {
    return _setClientRequestIdPolicy.setClientRequestIdPolicyName;
  }
});
Object.defineProperty(exports, "systemErrorRetryPolicy", {
  enumerable: true,
  get: function () {
    return _systemErrorRetryPolicy.systemErrorRetryPolicy;
  }
});
Object.defineProperty(exports, "systemErrorRetryPolicyName", {
  enumerable: true,
  get: function () {
    return _systemErrorRetryPolicy.systemErrorRetryPolicyName;
  }
});
Object.defineProperty(exports, "throttlingRetryPolicy", {
  enumerable: true,
  get: function () {
    return _throttlingRetryPolicy.throttlingRetryPolicy;
  }
});
Object.defineProperty(exports, "throttlingRetryPolicyName", {
  enumerable: true,
  get: function () {
    return _throttlingRetryPolicy.throttlingRetryPolicyName;
  }
});
Object.defineProperty(exports, "tlsPolicy", {
  enumerable: true,
  get: function () {
    return _tlsPolicy.tlsPolicy;
  }
});
Object.defineProperty(exports, "tlsPolicyName", {
  enumerable: true,
  get: function () {
    return _tlsPolicy.tlsPolicyName;
  }
});
Object.defineProperty(exports, "tracingPolicy", {
  enumerable: true,
  get: function () {
    return _tracingPolicy.tracingPolicy;
  }
});
Object.defineProperty(exports, "tracingPolicyName", {
  enumerable: true,
  get: function () {
    return _tracingPolicy.tracingPolicyName;
  }
});
Object.defineProperty(exports, "userAgentPolicy", {
  enumerable: true,
  get: function () {
    return _userAgentPolicy.userAgentPolicy;
  }
});
Object.defineProperty(exports, "userAgentPolicyName", {
  enumerable: true,
  get: function () {
    return _userAgentPolicy.userAgentPolicyName;
  }
});
var _pipeline = require("./pipeline");
var _createPipelineFromOptions = require("./createPipelineFromOptions");
var _defaultHttpClient = require("./defaultHttpClient");
var _httpHeaders = require("./httpHeaders");
var _pipelineRequest = require("./pipelineRequest");
var _restError = require("./restError");
var _decompressResponsePolicy = require("./policies/decompressResponsePolicy");
var _exponentialRetryPolicy = require("./policies/exponentialRetryPolicy");
var _setClientRequestIdPolicy = require("./policies/setClientRequestIdPolicy");
var _logPolicy = require("./policies/logPolicy");
var _multipartPolicy = require("./policies/multipartPolicy");
var _proxyPolicy = require("./policies/proxyPolicy");
var _redirectPolicy = require("./policies/redirectPolicy");
var _systemErrorRetryPolicy = require("./policies/systemErrorRetryPolicy");
var _throttlingRetryPolicy = require("./policies/throttlingRetryPolicy");
var _retryPolicy = require("./policies/retryPolicy");
var _tracingPolicy = require("./policies/tracingPolicy");
var _defaultRetryPolicy = require("./policies/defaultRetryPolicy");
var _userAgentPolicy = require("./policies/userAgentPolicy");
var _tlsPolicy = require("./policies/tlsPolicy");
var _formDataPolicy = require("./policies/formDataPolicy");
var _bearerTokenAuthenticationPolicy = require("./policies/bearerTokenAuthenticationPolicy");
var _ndJsonPolicy = require("./policies/ndJsonPolicy");
var _auxiliaryAuthenticationHeaderPolicy = require("./policies/auxiliaryAuthenticationHeaderPolicy");
var _file = require("./util/file");
},{"./pipeline":"node_modules/@azure/core-rest-pipeline/dist-esm/src/pipeline.js","./createPipelineFromOptions":"node_modules/@azure/core-rest-pipeline/dist-esm/src/createPipelineFromOptions.js","./defaultHttpClient":"node_modules/@azure/core-rest-pipeline/dist-esm/src/defaultHttpClient.browser.js","./httpHeaders":"node_modules/@azure/core-rest-pipeline/dist-esm/src/httpHeaders.js","./pipelineRequest":"node_modules/@azure/core-rest-pipeline/dist-esm/src/pipelineRequest.js","./restError":"node_modules/@azure/core-rest-pipeline/dist-esm/src/restError.js","./policies/decompressResponsePolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/decompressResponsePolicy.browser.js","./policies/exponentialRetryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/exponentialRetryPolicy.js","./policies/setClientRequestIdPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/setClientRequestIdPolicy.js","./policies/logPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/logPolicy.js","./policies/multipartPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/multipartPolicy.js","./policies/proxyPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/proxyPolicy.browser.js","./policies/redirectPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/redirectPolicy.js","./policies/systemErrorRetryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/systemErrorRetryPolicy.js","./policies/throttlingRetryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/throttlingRetryPolicy.js","./policies/retryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/retryPolicy.js","./policies/tracingPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tracingPolicy.js","./policies/defaultRetryPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/defaultRetryPolicy.js","./policies/userAgentPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/userAgentPolicy.js","./policies/tlsPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/tlsPolicy.js","./policies/formDataPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/formDataPolicy.js","./policies/bearerTokenAuthenticationPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js","./policies/ndJsonPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/ndJsonPolicy.js","./policies/auxiliaryAuthenticationHeaderPolicy":"node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/auxiliaryAuthenticationHeaderPolicy.js","./util/file":"node_modules/@azure/core-rest-pipeline/dist-esm/src/util/file.js"}],"node_modules/@azure/communication-common/dist-esm/src/credential/communicationAuthPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCommunicationAuthPolicy = createCommunicationAuthPolicy;
var _coreRestPipeline = require("@azure/core-rest-pipeline");
var _coreAuth = require("@azure/core-auth");
var _communicationAccessKeyCredentialPolicy = require("./communicationAccessKeyCredentialPolicy");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Creates a pipeline policy to authenticate request based
 * on the credential passed in.
 * @hidden
 *
 * @param credential - The KeyCredential or TokenCredential.
 */
function createCommunicationAuthPolicy(credential) {
  if ((0, _coreAuth.isTokenCredential)(credential)) {
    var policyOptions = {
      credential: credential,
      scopes: ["https://communication.azure.com//.default"]
    };
    return (0, _coreRestPipeline.bearerTokenAuthenticationPolicy)(policyOptions);
  } else {
    return (0, _communicationAccessKeyCredentialPolicy.createCommunicationAccessKeyCredentialPolicy)(credential);
  }
}
},{"@azure/core-rest-pipeline":"node_modules/@azure/core-rest-pipeline/dist-esm/src/index.js","@azure/core-auth":"node_modules/@azure/core-auth/dist-esm/src/index.js","./communicationAccessKeyCredentialPolicy":"node_modules/@azure/communication-common/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js"}],"node_modules/@azure/communication-common/dist-esm/src/credential/connectionString.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseConnectionString = void 0;
var _coreAuth = require("@azure/core-auth");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

// TODO: update when connection string format is finalized
var CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;
var tryParseConnectionString = function tryParseConnectionString(s) {
  var match = s.match(CONNECTION_STRING_REGEX);
  if ((match === null || match === void 0 ? void 0 : match[1]) && match[2]) {
    return {
      endpoint: match[1],
      credential: new _coreAuth.AzureKeyCredential(match[2])
    };
  }
  return undefined;
};
/**
 * Returns an EndpointCredential to easily access properties of the connection string.
 * @hidden
 *
 * @param connectionString - The connection string to parse
 * @returns Object to access the endpoint and the credentials
 */
var parseConnectionString = exports.parseConnectionString = function parseConnectionString(connectionString) {
  var parsedConnectionString = tryParseConnectionString(connectionString);
  if (parsedConnectionString) {
    return parsedConnectionString;
  } else {
    throw new Error("Invalid connection string ".concat(connectionString));
  }
};
},{"@azure/core-auth":"node_modules/@azure/core-auth/dist-esm/src/index.js"}],"node_modules/@azure/communication-common/dist-esm/src/credential/clientArguments.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseClientArguments = exports.isKeyCredential = void 0;
var _coreAuth = require("@azure/core-auth");
var _connectionString = require("./connectionString");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var isValidEndpoint = function isValidEndpoint(host) {
  var _a;
  var url = new URL(host);
  return !!((_a = url.protocol) === null || _a === void 0 ? void 0 : _a.match(/^http[s]?/)) && url.host !== undefined && url.host !== "" && (url.pathname === undefined || url.pathname === "" || url.pathname === "/");
};
var assertValidEndpoint = function assertValidEndpoint(host) {
  if (!isValidEndpoint(host)) {
    throw new Error("Invalid endpoint url ".concat(host));
  }
};
/**
 * Checks whether a value is a KeyCredential.
 *
 * @param credential - The credential being checked.
 */
var isKeyCredential = exports.isKeyCredential = function isKeyCredential(credential) {
  var castCredential = credential;
  return castCredential && typeof castCredential.key === "string" && castCredential.getToken === undefined;
};
/**
 * Parses arguments passed to a communication client.
 * @hidden
 */
var parseClientArguments = exports.parseClientArguments = function parseClientArguments(connectionStringOrUrl, credentialOrOptions) {
  if (isKeyCredential(credentialOrOptions) || (0, _coreAuth.isTokenCredential)(credentialOrOptions)) {
    assertValidEndpoint(connectionStringOrUrl);
    return {
      url: connectionStringOrUrl,
      credential: credentialOrOptions
    };
  } else {
    var _parseConnectionStrin = (0, _connectionString.parseConnectionString)(connectionStringOrUrl),
      host = _parseConnectionStrin.endpoint,
      credential = _parseConnectionStrin.credential;
    assertValidEndpoint(host);
    return {
      url: host,
      credential: credential
    };
  }
};
},{"@azure/core-auth":"node_modules/@azure/core-auth/dist-esm/src/index.js","./connectionString":"node_modules/@azure/communication-common/dist-esm/src/credential/connectionString.js"}],"node_modules/@azure/communication-common/dist-esm/src/credential/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _communicationAccessKeyCredentialPolicy = require("./communicationAccessKeyCredentialPolicy");
Object.keys(_communicationAccessKeyCredentialPolicy).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _communicationAccessKeyCredentialPolicy[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _communicationAccessKeyCredentialPolicy[key];
    }
  });
});
var _communicationAuthPolicy = require("./communicationAuthPolicy");
Object.keys(_communicationAuthPolicy).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _communicationAuthPolicy[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _communicationAuthPolicy[key];
    }
  });
});
var _clientArguments = require("./clientArguments");
Object.keys(_clientArguments).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _clientArguments[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _clientArguments[key];
    }
  });
});
var _connectionString = require("./connectionString");
Object.keys(_connectionString).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _connectionString[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _connectionString[key];
    }
  });
});
},{"./communicationAccessKeyCredentialPolicy":"node_modules/@azure/communication-common/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js","./communicationAuthPolicy":"node_modules/@azure/communication-common/dist-esm/src/credential/communicationAuthPolicy.js","./clientArguments":"node_modules/@azure/communication-common/dist-esm/src/credential/clientArguments.js","./connectionString":"node_modules/@azure/communication-common/dist-esm/src/credential/connectionString.js"}],"node_modules/@azure/communication-common/dist-esm/src/identifierModels.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUnknownIdentifier = exports.isPhoneNumberIdentifier = exports.isMicrosoftTeamsUserIdentifier = exports.isMicrosoftTeamsAppIdentifier = exports.isCommunicationUserIdentifier = exports.getIdentifierRawId = exports.getIdentifierKind = exports.createIdentifierFromRawId = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.
 *
 * @param identifier - The assumed CommunicationUserIdentifier to be tested.
 */
var isCommunicationUserIdentifier = exports.isCommunicationUserIdentifier = function isCommunicationUserIdentifier(identifier) {
  return typeof identifier.communicationUserId === "string";
};
/**
 * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.
 *
 * @param identifier - The assumed PhoneNumberIdentifier to be tested.
 */
var isPhoneNumberIdentifier = exports.isPhoneNumberIdentifier = function isPhoneNumberIdentifier(identifier) {
  return typeof identifier.phoneNumber === "string";
};
/**
 * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.
 *
 * @param identifier - The assumed available to be tested.
 */
var isMicrosoftTeamsUserIdentifier = exports.isMicrosoftTeamsUserIdentifier = function isMicrosoftTeamsUserIdentifier(identifier) {
  return typeof identifier.microsoftTeamsUserId === "string";
};
/**
 * Tests an Identifier to determine whether it implements MicrosoftTeamsAppIdentifier.
 *
 * @param identifier - The assumed available to be tested.
 */
var isMicrosoftTeamsAppIdentifier = exports.isMicrosoftTeamsAppIdentifier = function isMicrosoftTeamsAppIdentifier(identifier) {
  return typeof identifier.teamsAppId === "string";
};
/**
 * Tests an Identifier to determine whether it implements UnknownIdentifier.
 *
 * @param identifier - The assumed UnknownIdentifier to be tested.
 */
var isUnknownIdentifier = exports.isUnknownIdentifier = function isUnknownIdentifier(identifier) {
  return typeof identifier.id === "string";
};
/**
 * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.
 *
 * @param identifier - The identifier whose kind is to be inferred.
 */
var getIdentifierKind = exports.getIdentifierKind = function getIdentifierKind(identifier) {
  if (isCommunicationUserIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), {
      kind: "communicationUser"
    });
  }
  if (isPhoneNumberIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), {
      kind: "phoneNumber"
    });
  }
  if (isMicrosoftTeamsUserIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), {
      kind: "microsoftTeamsUser"
    });
  }
  if (isMicrosoftTeamsAppIdentifier(identifier)) {
    return Object.assign(Object.assign({}, identifier), {
      kind: "microsoftTeamsApp"
    });
  }
  return Object.assign(Object.assign({}, identifier), {
    kind: "unknown"
  });
};
/**
 * Returns the rawId for a given CommunicationIdentifier. You can use the rawId for encoding the identifier and then use it as a key in a database.
 *
 * @param identifier - The identifier to be translated to its rawId.
 */
var getIdentifierRawId = exports.getIdentifierRawId = function getIdentifierRawId(identifier) {
  var identifierKind = getIdentifierKind(identifier);
  switch (identifierKind.kind) {
    case "communicationUser":
      return identifierKind.communicationUserId;
    case "microsoftTeamsUser":
      {
        var microsoftTeamsUserId = identifierKind.microsoftTeamsUserId,
          rawId = identifierKind.rawId,
          cloud = identifierKind.cloud,
          isAnonymous = identifierKind.isAnonymous;
        if (rawId) return rawId;
        if (isAnonymous) return "8:teamsvisitor:".concat(microsoftTeamsUserId);
        switch (cloud) {
          case "dod":
            return "8:dod:".concat(microsoftTeamsUserId);
          case "gcch":
            return "8:gcch:".concat(microsoftTeamsUserId);
          case "public":
            return "8:orgid:".concat(microsoftTeamsUserId);
        }
        return "8:orgid:".concat(microsoftTeamsUserId);
      }
    case "microsoftTeamsApp":
      {
        var teamsAppId = identifierKind.teamsAppId,
          _rawId = identifierKind.rawId,
          _cloud = identifierKind.cloud;
        if (_rawId) return _rawId;
        switch (_cloud) {
          case "dod":
            return "28:dod:".concat(teamsAppId);
          case "gcch":
            return "28:gcch:".concat(teamsAppId);
        }
        return "28:orgid:".concat(teamsAppId);
      }
    case "phoneNumber":
      {
        var phoneNumber = identifierKind.phoneNumber,
          _rawId2 = identifierKind.rawId;
        if (_rawId2) return _rawId2;
        return "4:".concat(phoneNumber);
      }
    case "unknown":
      {
        return identifierKind.id;
      }
  }
};
var buildMicrosoftTeamsAppIdentifier = function buildMicrosoftTeamsAppIdentifier(teamsAppId, cloud) {
  return {
    kind: "microsoftTeamsApp",
    teamsAppId: teamsAppId,
    cloud: cloud
  };
};
var buildMicrosoftTeamsUserIdentifier = function buildMicrosoftTeamsUserIdentifier(id, cloud, isAnonymous) {
  return {
    kind: "microsoftTeamsUser",
    microsoftTeamsUserId: id,
    isAnonymous: isAnonymous,
    cloud: cloud
  };
};
/**
 * Creates a CommunicationIdentifierKind from a given rawId. When storing rawIds use this function to restore the identifier that was encoded in the rawId.
 *
 * @param rawId - The rawId to be translated to its identifier representation.
 */
var createIdentifierFromRawId = exports.createIdentifierFromRawId = function createIdentifierFromRawId(rawId) {
  if (rawId.startsWith("4:")) {
    return {
      kind: "phoneNumber",
      phoneNumber: "".concat(rawId.substring("4:".length))
    };
  }
  var segments = rawId.split(":");
  if (segments.length !== 3) {
    return {
      kind: "unknown",
      id: rawId
    };
  }
  var prefix = "".concat(segments[0], ":").concat(segments[1], ":");
  var suffix = segments[2];
  switch (prefix) {
    case "8:teamsvisitor:":
      return {
        kind: "microsoftTeamsUser",
        microsoftTeamsUserId: suffix,
        isAnonymous: true
      };
    case "8:orgid:":
      return buildMicrosoftTeamsUserIdentifier(suffix, "public", false);
    case "8:dod:":
      return buildMicrosoftTeamsUserIdentifier(suffix, "dod", false);
    case "8:gcch:":
      return buildMicrosoftTeamsUserIdentifier(suffix, "gcch", false);
    case "8:acs:":
    case "8:spool:":
    case "8:dod-acs:":
    case "8:gcch-acs:":
      return {
        kind: "communicationUser",
        communicationUserId: rawId
      };
    case "28:orgid:":
      return buildMicrosoftTeamsAppIdentifier(suffix, "public");
    case "28:gcch:":
      return buildMicrosoftTeamsAppIdentifier(suffix, "gcch");
    case "28:dod:":
      return buildMicrosoftTeamsAppIdentifier(suffix, "dod");
  }
  return {
    kind: "unknown",
    id: rawId
  };
};
},{}],"node_modules/@azure/communication-common/dist-esm/src/identifierModelSerializer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serializeCommunicationIdentifier = exports.deserializeCommunicationIdentifier = void 0;
var _identifierModels = require("./identifierModels");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var assertNotNullOrUndefined = function assertNotNullOrUndefined(obj, prop) {
  var subObjName = Object.keys(obj)[0];
  var subObj = obj[subObjName];
  if (prop in subObj) {
    return subObj[prop];
  }
  throw new Error("Property ".concat(prop, " is required for identifier of type ").concat(subObjName, "."));
};
var assertMaximumOneNestedModel = function assertMaximumOneNestedModel(identifier) {
  var presentProperties = [];
  if (identifier.communicationUser !== undefined) {
    presentProperties.push("communicationUser");
  }
  if (identifier.microsoftTeamsUser !== undefined) {
    presentProperties.push("microsoftTeamsUser");
  }
  if (identifier.microsoftTeamsApp !== undefined) {
    presentProperties.push("microsoftTeamsApp");
  }
  if (identifier.phoneNumber !== undefined) {
    presentProperties.push("phoneNumber");
  }
  if (presentProperties.length > 1) {
    throw new Error("Only one of the properties in ".concat(JSON.stringify(presentProperties), " should be present."));
  }
};
/**
 * @hidden
 * Translates a CommunicationIdentifier to its serialized format for sending a request.
 * @param identifier - The CommunicationIdentifier to be serialized.
 */
var serializeCommunicationIdentifier = exports.serializeCommunicationIdentifier = function serializeCommunicationIdentifier(identifier) {
  var _a, _b, _c, _d, _e, _f;
  var identifierKind = (0, _identifierModels.getIdentifierKind)(identifier);
  switch (identifierKind.kind) {
    case "communicationUser":
      return {
        rawId: (0, _identifierModels.getIdentifierRawId)(identifierKind),
        communicationUser: {
          id: identifierKind.communicationUserId
        }
      };
    case "phoneNumber":
      return {
        rawId: (_a = identifierKind.rawId) !== null && _a !== void 0 ? _a : (0, _identifierModels.getIdentifierRawId)(identifierKind),
        phoneNumber: {
          value: identifierKind.phoneNumber
        }
      };
    case "microsoftTeamsUser":
      return {
        rawId: (_b = identifierKind.rawId) !== null && _b !== void 0 ? _b : (0, _identifierModels.getIdentifierRawId)(identifierKind),
        microsoftTeamsUser: {
          userId: identifierKind.microsoftTeamsUserId,
          isAnonymous: (_c = identifierKind.isAnonymous) !== null && _c !== void 0 ? _c : false,
          cloud: (_d = identifierKind.cloud) !== null && _d !== void 0 ? _d : "public"
        }
      };
    case "microsoftTeamsApp":
      return {
        rawId: (_e = identifierKind.rawId) !== null && _e !== void 0 ? _e : (0, _identifierModels.getIdentifierRawId)(identifierKind),
        microsoftTeamsApp: {
          teamsAppId: identifierKind.teamsAppId,
          cloud: (_f = identifierKind.cloud) !== null && _f !== void 0 ? _f : "public"
        }
      };
    case "unknown":
      return {
        rawId: identifierKind.id
      };
    default:
      throw new Error("Can't serialize an identifier with kind ".concat(identifierKind.kind));
  }
};
var getKind = function getKind(serializedIdentifier) {
  if (serializedIdentifier.communicationUser) {
    return "communicationUser";
  }
  if (serializedIdentifier.phoneNumber) {
    return "phoneNumber";
  }
  if (serializedIdentifier.microsoftTeamsUser) {
    return "microsoftTeamsUser";
  }
  if (serializedIdentifier.microsoftTeamsApp) {
    return "microsoftTeamsApp";
  }
  return "unknown";
};
/**
 * @hidden
 * Translates the serialized format of a communication identifier to CommunicationIdentifier.
 * @param serializedIdentifier - The SerializedCommunicationIdentifier to be deserialized.
 */
var deserializeCommunicationIdentifier = exports.deserializeCommunicationIdentifier = function deserializeCommunicationIdentifier(serializedIdentifier) {
  var _a;
  assertMaximumOneNestedModel(serializedIdentifier);
  var communicationUser = serializedIdentifier.communicationUser,
    microsoftTeamsUser = serializedIdentifier.microsoftTeamsUser,
    microsoftTeamsApp = serializedIdentifier.microsoftTeamsApp,
    phoneNumber = serializedIdentifier.phoneNumber;
  var kind = (_a = serializedIdentifier.kind) !== null && _a !== void 0 ? _a : getKind(serializedIdentifier);
  if (kind === "communicationUser" && communicationUser) {
    return {
      kind: "communicationUser",
      communicationUserId: assertNotNullOrUndefined({
        communicationUser: communicationUser
      }, "id")
    };
  }
  if (kind === "phoneNumber" && phoneNumber) {
    return {
      kind: "phoneNumber",
      phoneNumber: assertNotNullOrUndefined({
        phoneNumber: phoneNumber
      }, "value"),
      rawId: assertNotNullOrUndefined({
        phoneNumber: serializedIdentifier
      }, "rawId")
    };
  }
  if (kind === "microsoftTeamsUser" && microsoftTeamsUser) {
    return {
      kind: "microsoftTeamsUser",
      microsoftTeamsUserId: assertNotNullOrUndefined({
        microsoftTeamsUser: microsoftTeamsUser
      }, "userId"),
      isAnonymous: assertNotNullOrUndefined({
        microsoftTeamsUser: microsoftTeamsUser
      }, "isAnonymous"),
      cloud: assertNotNullOrUndefined({
        microsoftTeamsUser: microsoftTeamsUser
      }, "cloud"),
      rawId: assertNotNullOrUndefined({
        microsoftTeamsUser: serializedIdentifier
      }, "rawId")
    };
  }
  if (kind === "microsoftTeamsApp" && microsoftTeamsApp) {
    return {
      kind: "microsoftTeamsApp",
      teamsAppId: assertNotNullOrUndefined({
        microsoftTeamsApp: microsoftTeamsApp
      }, "teamsAppId"),
      cloud: assertNotNullOrUndefined({
        microsoftTeamsApp: microsoftTeamsApp
      }, "cloud"),
      rawId: assertNotNullOrUndefined({
        microsoftTeamsApp: serializedIdentifier
      }, "rawId")
    };
  }
  return {
    kind: "unknown",
    id: assertNotNullOrUndefined({
      unknown: serializedIdentifier
    }, "rawId")
  };
};
},{"./identifierModels":"node_modules/@azure/communication-common/dist-esm/src/identifierModels.js"}],"node_modules/@azure/communication-common/dist-esm/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  AzureCommunicationTokenCredential: true
};
Object.defineProperty(exports, "AzureCommunicationTokenCredential", {
  enumerable: true,
  get: function () {
    return _azureCommunicationTokenCredential.AzureCommunicationTokenCredential;
  }
});
var _azureCommunicationTokenCredential = require("./azureCommunicationTokenCredential");
var _credential = require("./credential");
Object.keys(_credential).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _credential[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _credential[key];
    }
  });
});
var _identifierModels = require("./identifierModels");
Object.keys(_identifierModels).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _identifierModels[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _identifierModels[key];
    }
  });
});
var _identifierModelSerializer = require("./identifierModelSerializer");
Object.keys(_identifierModelSerializer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _identifierModelSerializer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _identifierModelSerializer[key];
    }
  });
});
},{"./azureCommunicationTokenCredential":"node_modules/@azure/communication-common/dist-esm/src/azureCommunicationTokenCredential.js","./credential":"node_modules/@azure/communication-common/dist-esm/src/credential/index.js","./identifierModels":"node_modules/@azure/communication-common/dist-esm/src/identifierModels.js","./identifierModelSerializer":"node_modules/@azure/communication-common/dist-esm/src/identifierModelSerializer.js"}],"node_modules/@azure/core-client/dist-esm/src/base64.browser.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeString = decodeString;
exports.decodeStringToString = decodeStringToString;
exports.encodeByteArray = encodeByteArray;
exports.encodeString = encodeString;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Encodes a string in base64 format.
 * @param value - the string to encode
 */
function encodeString(value) {
  return btoa(value);
}
/**
 * Encodes a byte array in base64 format.
 * @param value - the Uint8Aray to encode
 */
function encodeByteArray(value) {
  var str = "";
  for (var i = 0; i < value.length; i++) {
    str += String.fromCharCode(value[i]);
  }
  return btoa(str);
}
/**
 * Decodes a base64 string into a byte array.
 * @param value - the base64 string to decode
 */
function decodeString(value) {
  var byteString = atob(value);
  var arr = new Uint8Array(byteString.length);
  for (var i = 0; i < byteString.length; i++) {
    arr[i] = byteString.charCodeAt(i);
  }
  return arr;
}
/**
 * Decodes a base64 string into a string.
 * @param value - the base64 string to decode
 */
function decodeStringToString(value) {
  return atob(value);
}
},{}],"node_modules/@azure/core-client/dist-esm/src/interfaces.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.XML_CHARKEY = exports.XML_ATTRKEY = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Default key used to access the XML attributes.
 */
var XML_ATTRKEY = exports.XML_ATTRKEY = "$";
/**
 * Default key used to access the XML value content.
 */
var XML_CHARKEY = exports.XML_CHARKEY = "_";
},{}],"node_modules/@azure/core-client/dist-esm/src/utils.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flattenResponse = flattenResponse;
exports.isDuration = isDuration;
exports.isPrimitiveBody = isPrimitiveBody;
exports.isValidUuid = isValidUuid;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A type guard for a primitive response body.
 * @param value - Value to test
 *
 * @internal
 */
function isPrimitiveBody(value, mapperTypeName) {
  return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === undefined || value === null);
}
var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
/**
 * Returns true if the given string is in ISO 8601 format.
 * @param value - The value to be validated for ISO 8601 duration format.
 * @internal
 */
function isDuration(value) {
  return validateISODuration.test(value);
}
var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
/**
 * Returns true if the provided uuid is valid.
 *
 * @param uuid - The uuid that needs to be validated.
 *
 * @internal
 */
function isValidUuid(uuid) {
  return validUuidRegex.test(uuid);
}
/**
 * Maps the response as follows:
 * - wraps the response body if needed (typically if its type is primitive).
 * - returns null if the combination of the headers and the body is empty.
 * - otherwise, returns the combination of the headers and the body.
 *
 * @param responseObject - a representation of the parsed response
 * @returns the response that will be returned to the user which can be null and/or wrapped
 *
 * @internal
 */
function handleNullableResponseAndWrappableBody(responseObject) {
  var combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
    return responseObject.shouldWrapBody ? {
      body: null
    } : null;
  } else {
    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), {
      body: responseObject.body
    }) : combinedHeadersAndBody;
  }
}
/**
 * Take a `FullOperationResponse` and turn it into a flat
 * response object to hand back to the consumer.
 * @param fullResponse - The processed response from the operation request
 * @param responseSpec - The response map from the OperationSpec
 *
 * @internal
 */
function flattenResponse(fullResponse, responseSpec) {
  var _a, _b;
  var parsedHeaders = fullResponse.parsedHeaders;
  // head methods never have a body, but we return a boolean set to body property
  // to indicate presence/absence of the resource
  if (fullResponse.request.method === "HEAD") {
    return Object.assign(Object.assign({}, parsedHeaders), {
      body: fullResponse.parsedBody
    });
  }
  var bodyMapper = responseSpec && responseSpec.bodyMapper;
  var isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
  var expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
  /** If the body is asked for, we look at the expected body type to handle it */
  if (expectedBodyTypeName === "Stream") {
    return Object.assign(Object.assign({}, parsedHeaders), {
      blobBody: fullResponse.blobBody,
      readableStreamBody: fullResponse.readableStreamBody
    });
  }
  var modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
  var isPageableResponse = Object.keys(modelProperties).some(function (k) {
    return modelProperties[k].serializedName === "";
  });
  if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
    var arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];
    for (var _i = 0, _Object$keys = Object.keys(modelProperties); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (modelProperties[key].serializedName) {
        arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];
      }
    }
    if (parsedHeaders) {
      for (var _i2 = 0, _Object$keys2 = Object.keys(parsedHeaders); _i2 < _Object$keys2.length; _i2++) {
        var _key = _Object$keys2[_i2];
        arrayResponse[_key] = parsedHeaders[_key];
      }
    }
    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
  }
  return handleNullableResponseAndWrappableBody({
    body: fullResponse.parsedBody,
    headers: parsedHeaders,
    hasNullableType: isNullable,
    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
  });
}
},{}],"node_modules/@azure/core-client/dist-esm/src/serializer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MapperTypeNames = void 0;
exports.createSerializer = createSerializer;
var base64 = _interopRequireWildcard(require("./base64"));
var _interfaces = require("./interfaces");
var _utils = require("./utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var SerializerImpl = /*#__PURE__*/function () {
  function SerializerImpl() {
    var modelMappers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var isXML = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, SerializerImpl);
    this.modelMappers = modelMappers;
    this.isXML = isXML;
  }
  /**
   * @deprecated Removing the constraints validation on client side.
   */
  _createClass(SerializerImpl, [{
    key: "validateConstraints",
    value: function validateConstraints(mapper, value, objectName) {
      var failValidation = function failValidation(constraintName, constraintValue) {
        throw new Error("\"".concat(objectName, "\" with value \"").concat(value, "\" should satisfy the constraint \"").concat(constraintName, "\": ").concat(constraintValue, "."));
      };
      if (mapper.constraints && value !== undefined && value !== null) {
        var _mapper$constraints = mapper.constraints,
          ExclusiveMaximum = _mapper$constraints.ExclusiveMaximum,
          ExclusiveMinimum = _mapper$constraints.ExclusiveMinimum,
          InclusiveMaximum = _mapper$constraints.InclusiveMaximum,
          InclusiveMinimum = _mapper$constraints.InclusiveMinimum,
          MaxItems = _mapper$constraints.MaxItems,
          MaxLength = _mapper$constraints.MaxLength,
          MinItems = _mapper$constraints.MinItems,
          MinLength = _mapper$constraints.MinLength,
          MultipleOf = _mapper$constraints.MultipleOf,
          Pattern = _mapper$constraints.Pattern,
          UniqueItems = _mapper$constraints.UniqueItems;
        if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {
          failValidation("ExclusiveMaximum", ExclusiveMaximum);
        }
        if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {
          failValidation("ExclusiveMinimum", ExclusiveMinimum);
        }
        if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {
          failValidation("InclusiveMaximum", InclusiveMaximum);
        }
        if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {
          failValidation("InclusiveMinimum", InclusiveMinimum);
        }
        if (MaxItems !== undefined && value.length > MaxItems) {
          failValidation("MaxItems", MaxItems);
        }
        if (MaxLength !== undefined && value.length > MaxLength) {
          failValidation("MaxLength", MaxLength);
        }
        if (MinItems !== undefined && value.length < MinItems) {
          failValidation("MinItems", MinItems);
        }
        if (MinLength !== undefined && value.length < MinLength) {
          failValidation("MinLength", MinLength);
        }
        if (MultipleOf !== undefined && value % MultipleOf !== 0) {
          failValidation("MultipleOf", MultipleOf);
        }
        if (Pattern) {
          var pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
          if (typeof value !== "string" || value.match(pattern) === null) {
            failValidation("Pattern", Pattern);
          }
        }
        if (UniqueItems && value.some(function (item, i, ar) {
          return ar.indexOf(item) !== i;
        })) {
          failValidation("UniqueItems", UniqueItems);
        }
      }
    }
    /**
     * Serialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param object - A valid Javascript object to be serialized
     *
     * @param objectName - Name of the serialized object
     *
     * @param options - additional options to serialization
     *
     * @returns A valid serialized Javascript object
     */
  }, {
    key: "serialize",
    value: function serialize(mapper, object, objectName) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        xml: {}
      };
      var _a, _b, _c;
      var updatedOptions = {
        xml: {
          rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
          includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
          xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : _interfaces.XML_CHARKEY
        }
      };
      var payload = {};
      var mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Sequence$/i) !== null) {
        payload = [];
      }
      if (mapper.isConstant) {
        object = mapper.defaultValue;
      }
      // This table of allowed values should help explain
      // the mapper.required and mapper.nullable properties.
      // X means "neither undefined or null are allowed".
      //           || required
      //           || true      | false
      //  nullable || ==========================
      //      true || null      | undefined/null
      //     false || X         | undefined
      // undefined || X         | undefined/null
      var required = mapper.required,
        nullable = mapper.nullable;
      if (required && nullable && object === undefined) {
        throw new Error("".concat(objectName, " cannot be undefined."));
      }
      if (required && !nullable && (object === undefined || object === null)) {
        throw new Error("".concat(objectName, " cannot be null or undefined."));
      }
      if (!required && nullable === false && object === null) {
        throw new Error("".concat(objectName, " cannot be null."));
      }
      if (object === undefined || object === null) {
        payload = object;
      } else {
        if (mapperType.match(/^any$/i) !== null) {
          payload = object;
        } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
          payload = serializeBasicTypes(mapperType, objectName, object);
        } else if (mapperType.match(/^Enum$/i) !== null) {
          var enumMapper = mapper;
          payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
        } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
          payload = serializeDateTypes(mapperType, object, objectName);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = serializeByteArrayType(objectName, object);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = serializeBase64UrlType(objectName, object);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Composite$/i) !== null) {
          payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        }
      }
      return payload;
    }
    /**
     * Deserialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     *
     * @param responseBody - A valid Javascript entity to be deserialized
     *
     * @param objectName - Name of the deserialized object
     *
     * @param options - Controls behavior of XML parser and builder.
     *
     * @returns A valid deserialized Javascript object
     */
  }, {
    key: "deserialize",
    value: function deserialize(mapper, responseBody, objectName) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        xml: {}
      };
      var _a, _b, _c, _d;
      var updatedOptions = {
        xml: {
          rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
          includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
          xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : _interfaces.XML_CHARKEY
        },
        ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false
      };
      if (responseBody === undefined || responseBody === null) {
        if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
          // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
          // between the list being empty versus being missing,
          // so let's do the more user-friendly thing and return an empty list.
          responseBody = [];
        }
        // specifically check for undefined as default value can be a falsey value `0, "", false, null`
        if (mapper.defaultValue !== undefined) {
          responseBody = mapper.defaultValue;
        }
        return responseBody;
      }
      var payload;
      var mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Composite$/i) !== null) {
        payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
      } else {
        if (this.isXML) {
          var xmlCharKey = updatedOptions.xml.xmlCharKey;
          /**
           * If the mapper specifies this as a non-composite type value but the responseBody contains
           * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
           * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
           */
          if (responseBody[_interfaces.XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {
            responseBody = responseBody[xmlCharKey];
          }
        }
        if (mapperType.match(/^Number$/i) !== null) {
          payload = parseFloat(responseBody);
          if (isNaN(payload)) {
            payload = responseBody;
          }
        } else if (mapperType.match(/^Boolean$/i) !== null) {
          if (responseBody === "true") {
            payload = true;
          } else if (responseBody === "false") {
            payload = false;
          } else {
            payload = responseBody;
          }
        } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
          payload = responseBody;
        } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
          payload = new Date(responseBody);
        } else if (mapperType.match(/^UnixTime$/i) !== null) {
          payload = unixTimeToDate(responseBody);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = base64.decodeString(responseBody);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = base64UrlToByteArray(responseBody);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
        }
      }
      if (mapper.isConstant) {
        payload = mapper.defaultValue;
      }
      return payload;
    }
  }]);
  return SerializerImpl;
}();
/**
 * Method that creates and returns a Serializer.
 * @param modelMappers - Known models to map
 * @param isXML - If XML should be supported
 */
function createSerializer() {
  var modelMappers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var isXML = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return new SerializerImpl(modelMappers, isXML);
}
function trimEnd(str, ch) {
  var len = str.length;
  while (len - 1 >= 0 && str[len - 1] === ch) {
    --len;
  }
  return str.substr(0, len);
}
function bufferToBase64Url(buffer) {
  if (!buffer) {
    return undefined;
  }
  if (!(buffer instanceof Uint8Array)) {
    throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
  }
  // Uint8Array to Base64.
  var str = base64.encodeByteArray(buffer);
  // Base64 to Base64Url.
  return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64UrlToByteArray(str) {
  if (!str) {
    return undefined;
  }
  if (str && typeof str.valueOf() !== "string") {
    throw new Error("Please provide an input of type string for converting to Uint8Array");
  }
  // Base64Url to Base64.
  str = str.replace(/-/g, "+").replace(/_/g, "/");
  // Base64 to Uint8Array.
  return base64.decodeString(str);
}
function splitSerializeName(prop) {
  var classes = [];
  var partialclass = "";
  if (prop) {
    var subwords = prop.split(".");
    var _iterator = _createForOfIteratorHelper(subwords),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var item = _step.value;
        if (item.charAt(item.length - 1) === "\\") {
          partialclass += item.substr(0, item.length - 1) + ".";
        } else {
          partialclass += item;
          classes.push(partialclass);
          partialclass = "";
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return classes;
}
function dateToUnixTime(d) {
  if (!d) {
    return undefined;
  }
  if (typeof d.valueOf() === "string") {
    d = new Date(d);
  }
  return Math.floor(d.getTime() / 1000);
}
function unixTimeToDate(n) {
  if (!n) {
    return undefined;
  }
  return new Date(n * 1000);
}
function serializeBasicTypes(typeName, objectName, value) {
  if (value !== null && value !== undefined) {
    if (typeName.match(/^Number$/i) !== null) {
      if (typeof value !== "number") {
        throw new Error("".concat(objectName, " with value ").concat(value, " must be of type number."));
      }
    } else if (typeName.match(/^String$/i) !== null) {
      if (typeof value.valueOf() !== "string") {
        throw new Error("".concat(objectName, " with value \"").concat(value, "\" must be of type string."));
      }
    } else if (typeName.match(/^Uuid$/i) !== null) {
      if (!(typeof value.valueOf() === "string" && (0, _utils.isValidUuid)(value))) {
        throw new Error("".concat(objectName, " with value \"").concat(value, "\" must be of type string and a valid uuid."));
      }
    } else if (typeName.match(/^Boolean$/i) !== null) {
      if (typeof value !== "boolean") {
        throw new Error("".concat(objectName, " with value ").concat(value, " must be of type boolean."));
      }
    } else if (typeName.match(/^Stream$/i) !== null) {
      var objectType = _typeof(value);
      if (objectType !== "string" && typeof value.pipe !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) &&
      // File objects count as a type of Blob, so we want to use instanceof explicitly
      !((typeof Blob === "function" || (typeof Blob === "undefined" ? "undefined" : _typeof(Blob)) === "object") && value instanceof Blob) && objectType !== "function") {
        throw new Error("".concat(objectName, " must be a string, Blob, ArrayBuffer, ArrayBufferView, NodeJS.ReadableStream, or () => NodeJS.ReadableStream."));
      }
    }
  }
  return value;
}
function serializeEnumType(objectName, allowedValues, value) {
  if (!allowedValues) {
    throw new Error("Please provide a set of allowedValues to validate ".concat(objectName, " as an Enum Type."));
  }
  var isPresent = allowedValues.some(function (item) {
    if (typeof item.valueOf() === "string") {
      return item.toLowerCase() === value.toLowerCase();
    }
    return item === value;
  });
  if (!isPresent) {
    throw new Error("".concat(value, " is not a valid value for ").concat(objectName, ". The valid values are: ").concat(JSON.stringify(allowedValues), "."));
  }
  return value;
}
function serializeByteArrayType(objectName, value) {
  if (value !== undefined && value !== null) {
    if (!(value instanceof Uint8Array)) {
      throw new Error("".concat(objectName, " must be of type Uint8Array."));
    }
    value = base64.encodeByteArray(value);
  }
  return value;
}
function serializeBase64UrlType(objectName, value) {
  if (value !== undefined && value !== null) {
    if (!(value instanceof Uint8Array)) {
      throw new Error("".concat(objectName, " must be of type Uint8Array."));
    }
    value = bufferToBase64Url(value);
  }
  return value;
}
function serializeDateTypes(typeName, value, objectName) {
  if (value !== undefined && value !== null) {
    if (typeName.match(/^Date$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error("".concat(objectName, " must be an instanceof Date or a string in ISO8601 format."));
      }
      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
    } else if (typeName.match(/^DateTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error("".concat(objectName, " must be an instanceof Date or a string in ISO8601 format."));
      }
      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error("".concat(objectName, " must be an instanceof Date or a string in RFC-1123 format."));
      }
      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
    } else if (typeName.match(/^UnixTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error("".concat(objectName, " must be an instanceof Date or a string in RFC-1123/ISO8601 format ") + "for it to be serialized in UnixTime/Epoch format.");
      }
      value = dateToUnixTime(value);
    } else if (typeName.match(/^TimeSpan$/i) !== null) {
      if (!(0, _utils.isDuration)(value)) {
        throw new Error("".concat(objectName, " must be a string in ISO 8601 format. Instead was \"").concat(value, "\"."));
      }
    }
  }
  return value;
}
function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
  var _a;
  if (!Array.isArray(object)) {
    throw new Error("".concat(objectName, " must be of type Array."));
  }
  var elementType = mapper.type.element;
  if (!elementType || _typeof(elementType) !== "object") {
    throw new Error("element\" metadata for an Array must be defined in the " + "mapper and it must of type \"object\" in ".concat(objectName, "."));
  }
  // Quirk: Composite mappers referenced by `element` might
  // not have *all* properties declared (like uberParent),
  // so let's try to look up the full definition by name.
  if (elementType.type.name === "Composite" && elementType.type.className) {
    elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;
  }
  var tempArray = [];
  for (var i = 0; i < object.length; i++) {
    var serializedValue = serializer.serialize(elementType, object[i], objectName, options);
    if (isXml && elementType.xmlNamespace) {
      var xmlnsKey = elementType.xmlNamespacePrefix ? "xmlns:".concat(elementType.xmlNamespacePrefix) : "xmlns";
      if (elementType.type.name === "Composite") {
        tempArray[i] = Object.assign({}, serializedValue);
        tempArray[i][_interfaces.XML_ATTRKEY] = _defineProperty({}, xmlnsKey, elementType.xmlNamespace);
      } else {
        tempArray[i] = {};
        tempArray[i][options.xml.xmlCharKey] = serializedValue;
        tempArray[i][_interfaces.XML_ATTRKEY] = _defineProperty({}, xmlnsKey, elementType.xmlNamespace);
      }
    } else {
      tempArray[i] = serializedValue;
    }
  }
  return tempArray;
}
function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
  if (_typeof(object) !== "object") {
    throw new Error("".concat(objectName, " must be of type object."));
  }
  var valueType = mapper.type.value;
  if (!valueType || _typeof(valueType) !== "object") {
    throw new Error("\"value\" metadata for a Dictionary must be defined in the " + "mapper and it must of type \"object\" in ".concat(objectName, "."));
  }
  var tempDictionary = {};
  for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var serializedValue = serializer.serialize(valueType, object[key], objectName, options);
    // If the element needs an XML namespace we need to add it within the $ property
    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
  }
  // Add the namespace to the root element if needed
  if (isXml && mapper.xmlNamespace) {
    var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:".concat(mapper.xmlNamespacePrefix) : "xmlns";
    var result = tempDictionary;
    result[_interfaces.XML_ATTRKEY] = _defineProperty({}, xmlnsKey, mapper.xmlNamespace);
    return result;
  }
  return tempDictionary;
}
/**
 * Resolves the additionalProperties property from a referenced mapper
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 * @param objectName - name of the object being serialized
 */
function resolveAdditionalProperties(serializer, mapper, objectName) {
  var additionalProperties = mapper.type.additionalProperties;
  if (!additionalProperties && mapper.type.className) {
    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
  }
  return additionalProperties;
}
/**
 * Finds the mapper referenced by className
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 * @param objectName - name of the object being serialized
 */
function resolveReferencedMapper(serializer, mapper, objectName) {
  var className = mapper.type.className;
  if (!className) {
    throw new Error("Class name for model \"".concat(objectName, "\" is not provided in the mapper \"").concat(JSON.stringify(mapper, undefined, 2), "\"."));
  }
  return serializer.modelMappers[className];
}
/**
 * Resolves a composite mapper's modelProperties.
 * @param serializer - the serializer containing the entire set of mappers
 * @param mapper - the composite mapper to resolve
 */
function resolveModelProperties(serializer, mapper, objectName) {
  var modelProps = mapper.type.modelProperties;
  if (!modelProps) {
    var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
    if (!modelMapper) {
      throw new Error("mapper() cannot be null or undefined for model \"".concat(mapper.type.className, "\"."));
    }
    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
    if (!modelProps) {
      throw new Error("modelProperties cannot be null or undefined in the " + "mapper \"".concat(JSON.stringify(modelMapper), "\" of type \"").concat(mapper.type.className, "\" for object \"").concat(objectName, "\"."));
    }
  }
  return modelProps;
}
function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
    mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
  }
  if (object !== undefined && object !== null) {
    var payload = {};
    var modelProps = resolveModelProperties(serializer, mapper, objectName);
    for (var _i2 = 0, _Object$keys2 = Object.keys(modelProps); _i2 < _Object$keys2.length; _i2++) {
      var key = _Object$keys2[_i2];
      var propertyMapper = modelProps[key];
      if (propertyMapper.readOnly) {
        continue;
      }
      var propName = void 0;
      var parentObject = payload;
      if (serializer.isXML) {
        if (propertyMapper.xmlIsWrapped) {
          propName = propertyMapper.xmlName;
        } else {
          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        }
      } else {
        var paths = splitSerializeName(propertyMapper.serializedName);
        propName = paths.pop();
        var _iterator2 = _createForOfIteratorHelper(paths),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var pathName = _step2.value;
            var childObject = parentObject[pathName];
            if ((childObject === undefined || childObject === null) && (object[key] !== undefined && object[key] !== null || propertyMapper.defaultValue !== undefined)) {
              parentObject[pathName] = {};
            }
            parentObject = parentObject[pathName];
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      if (parentObject !== undefined && parentObject !== null) {
        if (isXml && mapper.xmlNamespace) {
          var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:".concat(mapper.xmlNamespacePrefix) : "xmlns";
          parentObject[_interfaces.XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[_interfaces.XML_ATTRKEY]), _defineProperty({}, xmlnsKey, mapper.xmlNamespace));
        }
        var propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
        var toSerialize = object[key];
        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === undefined || toSerialize === null)) {
          toSerialize = mapper.serializedName;
        }
        var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
        if (serializedValue !== undefined && propName !== undefined && propName !== null) {
          var value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
          if (isXml && propertyMapper.xmlIsAttribute) {
            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
            // This keeps things simple while preventing name collision
            // with names in user documents.
            parentObject[_interfaces.XML_ATTRKEY] = parentObject[_interfaces.XML_ATTRKEY] || {};
            parentObject[_interfaces.XML_ATTRKEY][propName] = serializedValue;
          } else if (isXml && propertyMapper.xmlIsWrapped) {
            parentObject[propName] = _defineProperty({}, propertyMapper.xmlElementName, value);
          } else {
            parentObject[propName] = value;
          }
        }
      }
    }
    var additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
    if (additionalPropertiesMapper) {
      var propNames = Object.keys(modelProps);
      var _loop = function _loop(clientPropName) {
        var isAdditionalProperty = propNames.every(function (pn) {
          return pn !== clientPropName;
        });
        if (isAdditionalProperty) {
          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
        }
      };
      for (var clientPropName in object) {
        _loop(clientPropName);
      }
    }
    return payload;
  }
  return object;
}
function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
  if (!isXml || !propertyMapper.xmlNamespace) {
    return serializedValue;
  }
  var xmlnsKey = propertyMapper.xmlNamespacePrefix ? "xmlns:".concat(propertyMapper.xmlNamespacePrefix) : "xmlns";
  var xmlNamespace = _defineProperty({}, xmlnsKey, propertyMapper.xmlNamespace);
  if (["Composite"].includes(propertyMapper.type.name)) {
    if (serializedValue[_interfaces.XML_ATTRKEY]) {
      return serializedValue;
    } else {
      var _result = Object.assign({}, serializedValue);
      _result[_interfaces.XML_ATTRKEY] = xmlNamespace;
      return _result;
    }
  }
  var result = {};
  result[options.xml.xmlCharKey] = serializedValue;
  result[_interfaces.XML_ATTRKEY] = xmlNamespace;
  return result;
}
function isSpecialXmlProperty(propertyName, options) {
  return [_interfaces.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
}
function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
  var _a, _b;
  var xmlCharKey = (_a = options.xml.xmlCharKey) !== null && _a !== void 0 ? _a : _interfaces.XML_CHARKEY;
  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
    mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
  }
  var modelProps = resolveModelProperties(serializer, mapper, objectName);
  var instance = {};
  var handledPropertyNames = [];
  for (var _i3 = 0, _Object$keys3 = Object.keys(modelProps); _i3 < _Object$keys3.length; _i3++) {
    var key = _Object$keys3[_i3];
    var propertyMapper = modelProps[key];
    var paths = splitSerializeName(modelProps[key].serializedName);
    handledPropertyNames.push(paths[0]);
    var serializedName = propertyMapper.serializedName,
      xmlName = propertyMapper.xmlName,
      xmlElementName = propertyMapper.xmlElementName;
    var propertyObjectName = objectName;
    if (serializedName !== "" && serializedName !== undefined) {
      propertyObjectName = objectName + "." + serializedName;
    }
    var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
    if (headerCollectionPrefix) {
      var dictionary = {};
      for (var _i4 = 0, _Object$keys4 = Object.keys(responseBody); _i4 < _Object$keys4.length; _i4++) {
        var headerKey = _Object$keys4[_i4];
        if (headerKey.startsWith(headerCollectionPrefix)) {
          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
        }
        handledPropertyNames.push(headerKey);
      }
      instance[key] = dictionary;
    } else if (serializer.isXML) {
      if (propertyMapper.xmlIsAttribute && responseBody[_interfaces.XML_ATTRKEY]) {
        instance[key] = serializer.deserialize(propertyMapper, responseBody[_interfaces.XML_ATTRKEY][xmlName], propertyObjectName, options);
      } else if (propertyMapper.xmlIsMsText) {
        if (responseBody[xmlCharKey] !== undefined) {
          instance[key] = responseBody[xmlCharKey];
        } else if (typeof responseBody === "string") {
          // The special case where xml parser parses "<Name>content</Name>" into JSON of
          //   `{ name: "content"}` instead of `{ name: { "_": "content" }}`
          instance[key] = responseBody;
        }
      } else {
        var propertyName = xmlElementName || xmlName || serializedName;
        if (propertyMapper.xmlIsWrapped) {
          /* a list of <xmlElementName> wrapped by <xmlName>
            For the xml example below
              <Cors>
                <CorsRule>...</CorsRule>
                <CorsRule>...</CorsRule>
              </Cors>
            the responseBody has
              {
                Cors: {
                  CorsRule: [{...}, {...}]
                }
              }
            xmlName is "Cors" and xmlElementName is"CorsRule".
          */
          var wrapped = responseBody[xmlName];
          var elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];
          instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
          handledPropertyNames.push(xmlName);
        } else {
          var property = responseBody[propertyName];
          instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
          handledPropertyNames.push(propertyName);
        }
      }
    } else {
      // deserialize the property if it is present in the provided responseBody instance
      var propertyInstance = void 0;
      var res = responseBody;
      // traversing the object step by step.
      var steps = 0;
      var _iterator3 = _createForOfIteratorHelper(paths),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var item = _step3.value;
          if (!res) break;
          steps++;
          res = res[item];
        }
        // only accept null when reaching the last position of object otherwise it would be undefined
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      if (res === null && steps < paths.length) {
        res = undefined;
      }
      propertyInstance = res;
      var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
      // checking that the model property name (key)(ex: "fishtype") and the
      // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
      // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
      // is a better approach. The generator is not consistent with escaping '\.' in the
      // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
      // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
      // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
      // the transformation of model property name (ex: "fishtype") is done consistently.
      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === undefined || propertyInstance === null)) {
        propertyInstance = mapper.serializedName;
      }
      var serializedValue = void 0;
      // paging
      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
        propertyInstance = responseBody[key];
        var arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        // Copy over any properties that have already been added into the instance, where they do
        // not exist on the newly de-serialized array
        for (var _i5 = 0, _Object$entries = Object.entries(instance); _i5 < _Object$entries.length; _i5++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),
            k = _Object$entries$_i[0],
            v = _Object$entries$_i[1];
          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
            arrayInstance[k] = v;
          }
        }
        instance = arrayInstance;
      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        instance[key] = serializedValue;
      }
    }
  }
  var additionalPropertiesMapper = mapper.type.additionalProperties;
  if (additionalPropertiesMapper) {
    var isAdditionalProperty = function isAdditionalProperty(responsePropName) {
      for (var clientPropName in modelProps) {
        var _paths = splitSerializeName(modelProps[clientPropName].serializedName);
        if (_paths[0] === responsePropName) {
          return false;
        }
      }
      return true;
    };
    for (var responsePropName in responseBody) {
      if (isAdditionalProperty(responsePropName)) {
        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
      }
    }
  } else if (responseBody && !options.ignoreUnknownProperties) {
    for (var _i6 = 0, _Object$keys5 = Object.keys(responseBody); _i6 < _Object$keys5.length; _i6++) {
      var _key = _Object$keys5[_i6];
      if (instance[_key] === undefined && !handledPropertyNames.includes(_key) && !isSpecialXmlProperty(_key, options)) {
        instance[_key] = responseBody[_key];
      }
    }
  }
  return instance;
}
function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
  /* jshint validthis: true */
  var value = mapper.type.value;
  if (!value || _typeof(value) !== "object") {
    throw new Error("\"value\" metadata for a Dictionary must be defined in the " + "mapper and it must of type \"object\" in ".concat(objectName));
  }
  if (responseBody) {
    var tempDictionary = {};
    for (var _i7 = 0, _Object$keys6 = Object.keys(responseBody); _i7 < _Object$keys6.length; _i7++) {
      var key = _Object$keys6[_i7];
      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
    }
    return tempDictionary;
  }
  return responseBody;
}
function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
  var _a;
  var element = mapper.type.element;
  if (!element || _typeof(element) !== "object") {
    throw new Error("element\" metadata for an Array must be defined in the " + "mapper and it must of type \"object\" in ".concat(objectName));
  }
  if (responseBody) {
    if (!Array.isArray(responseBody)) {
      // xml2js will interpret a single element array as just the element, so force it to be an array
      responseBody = [responseBody];
    }
    // Quirk: Composite mappers referenced by `element` might
    // not have *all* properties declared (like uberParent),
    // so let's try to look up the full definition by name.
    if (element.type.name === "Composite" && element.type.className) {
      element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;
    }
    var tempArray = [];
    for (var i = 0; i < responseBody.length; i++) {
      tempArray[i] = serializer.deserialize(element, responseBody[i], "".concat(objectName, "[").concat(i, "]"), options);
    }
    return tempArray;
  }
  return responseBody;
}
function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
  var typeNamesToCheck = [typeName];
  while (typeNamesToCheck.length) {
    var currentName = typeNamesToCheck.shift();
    var indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
      return discriminators[indexDiscriminator];
    } else {
      for (var _i8 = 0, _Object$entries2 = Object.entries(discriminators); _i8 < _Object$entries2.length; _i8++) {
        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i8], 2),
          name = _Object$entries2$_i[0],
          mapper = _Object$entries2$_i[1];
        if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
          typeNamesToCheck.push(mapper.type.className);
        }
      }
    }
  }
  return undefined;
}
function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
  var _a;
  var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
  if (polymorphicDiscriminator) {
    var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
    if (discriminatorName) {
      // The serializedName might have \\, which we just want to ignore
      if (polymorphicPropertyName === "serializedName") {
        discriminatorName = discriminatorName.replace(/\\/gi, "");
      }
      var discriminatorValue = object[discriminatorName];
      var typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;
      if (typeof discriminatorValue === "string" && typeName) {
        var polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
        if (polymorphicMapper) {
          mapper = polymorphicMapper;
        }
      }
    }
  }
  return mapper;
}
function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
}
function getPolymorphicDiscriminatorSafely(serializer, typeName) {
  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
}
/**
 * Known types of Mappers
 */
var MapperTypeNames = exports.MapperTypeNames = {
  Base64Url: "Base64Url",
  Boolean: "Boolean",
  ByteArray: "ByteArray",
  Composite: "Composite",
  Date: "Date",
  DateTime: "DateTime",
  DateTimeRfc1123: "DateTimeRfc1123",
  Dictionary: "Dictionary",
  Enum: "Enum",
  Number: "Number",
  Object: "Object",
  Sequence: "Sequence",
  String: "String",
  Stream: "Stream",
  TimeSpan: "TimeSpan",
  UnixTime: "UnixTime"
};
},{"./base64":"node_modules/@azure/core-client/dist-esm/src/base64.browser.js","./interfaces":"node_modules/@azure/core-client/dist-esm/src/interfaces.js","./utils":"node_modules/@azure/core-client/dist-esm/src/utils.js"}],"node_modules/@azure/core-client/dist-esm/src/operationHelpers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
exports.getOperationRequestInfo = getOperationRequestInfo;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 * Retrieves the value to use for a given operation argument
 * @param operationArguments - The arguments passed from the generated client
 * @param parameter - The parameter description
 * @param fallbackObject - If something isn't found in the arguments bag, look here.
 *  Generally used to look at the service client properties.
 */
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
  var parameterPath = parameter.parameterPath;
  var parameterMapper = parameter.mapper;
  var value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound && fallbackObject) {
          propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
        }
        var useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (var propertyName in parameterPath) {
      var propertyMapper = parameterMapper.type.modelProperties[propertyName];
      var propertyPath = parameterPath[propertyName];
      var propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
        parameterPath: propertyPath,
        mapper: propertyMapper
      }, fallbackObject);
      if (propertyValue !== undefined) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  var result = {
    propertyFound: false
  };
  var i = 0;
  for (; i < parameterPath.length; ++i) {
    var parameterPathPart = parameterPath[i];
    // Make sure to check inherited properties too, so don't use hasOwnProperty().
    if (parent && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
var operationRequestMap = new WeakMap();
var originalRequestSymbol = Symbol.for("@azure/core-client original request");
function hasOriginalRequest(request) {
  return originalRequestSymbol in request;
}
function getOperationRequestInfo(request) {
  if (hasOriginalRequest(request)) {
    return getOperationRequestInfo(request[originalRequestSymbol]);
  }
  var info = operationRequestMap.get(request);
  if (!info) {
    info = {};
    operationRequestMap.set(request, info);
  }
  return info;
}
},{}],"node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deserializationPolicy = deserializationPolicy;
exports.deserializationPolicyName = void 0;
var _interfaces = require("./interfaces");
var _coreRestPipeline = require("@azure/core-rest-pipeline");
var _serializer = require("./serializer");
var _operationHelpers = require("./operationHelpers");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var defaultJsonContentTypes = ["application/json", "text/json"];
var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
/**
 * The programmatic identifier of the deserializationPolicy.
 */
var deserializationPolicyName = exports.deserializationPolicyName = "deserializationPolicy";
/**
 * This policy handles parsing out responses according to OperationSpecs on the request.
 */
function deserializationPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _a, _b, _c, _d, _e, _f, _g;
  var jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;
  var xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;
  var parseXML = options.parseXML;
  var serializerOptions = options.serializerOptions;
  var updatedOptions = {
    xml: {
      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : _interfaces.XML_CHARKEY
    }
  };
  return {
    name: deserializationPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var response;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return next(request);
            case 2:
              response = _context.sent;
              return _context.abrupt("return", deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML));
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
function getOperationResponseMap(parsedResponse) {
  var result;
  var request = parsedResponse.request;
  var operationInfo = (0, _operationHelpers.getOperationRequestInfo)(request);
  var operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (operationSpec) {
    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse(parsedResponse) {
  var request = parsedResponse.request;
  var operationInfo = (0, _operationHelpers.getOperationRequestInfo)(request);
  var shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
  var result;
  if (shouldDeserialize === undefined) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
function deserializeResponseBody(_x, _x2, _x3, _x4, _x5) {
  return _deserializeResponseBody.apply(this, arguments);
}
function _deserializeResponseBody() {
  _deserializeResponseBody = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
    var parsedResponse, operationInfo, operationSpec, responseSpec, _handleErrorResponse, error, shouldReturnResponse, valueToDeserialize, restError;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
        case 2:
          parsedResponse = _context2.sent;
          if (shouldDeserializeResponse(parsedResponse)) {
            _context2.next = 5;
            break;
          }
          return _context2.abrupt("return", parsedResponse);
        case 5:
          operationInfo = (0, _operationHelpers.getOperationRequestInfo)(parsedResponse.request);
          operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
          if (!(!operationSpec || !operationSpec.responses)) {
            _context2.next = 9;
            break;
          }
          return _context2.abrupt("return", parsedResponse);
        case 9:
          responseSpec = getOperationResponseMap(parsedResponse);
          _handleErrorResponse = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options), error = _handleErrorResponse.error, shouldReturnResponse = _handleErrorResponse.shouldReturnResponse;
          if (!error) {
            _context2.next = 15;
            break;
          }
          throw error;
        case 15:
          if (!shouldReturnResponse) {
            _context2.next = 17;
            break;
          }
          return _context2.abrupt("return", parsedResponse);
        case 17:
          if (!responseSpec) {
            _context2.next = 33;
            break;
          }
          if (!responseSpec.bodyMapper) {
            _context2.next = 31;
            break;
          }
          valueToDeserialize = parsedResponse.parsedBody;
          if (operationSpec.isXML && responseSpec.bodyMapper.type.name === _serializer.MapperTypeNames.Sequence) {
            valueToDeserialize = _typeof(valueToDeserialize) === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
          }
          _context2.prev = 21;
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
          _context2.next = 29;
          break;
        case 25:
          _context2.prev = 25;
          _context2.t0 = _context2["catch"](21);
          restError = new _coreRestPipeline.RestError("Error ".concat(_context2.t0, " occurred in deserializing the responseBody - ").concat(parsedResponse.bodyAsText), {
            statusCode: parsedResponse.status,
            request: parsedResponse.request,
            response: parsedResponse
          });
          throw restError;
        case 29:
          _context2.next = 32;
          break;
        case 31:
          if (operationSpec.httpMethod === "HEAD") {
            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
          }
        case 32:
          if (responseSpec.headersMapper) {
            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", {
              xml: {},
              ignoreUnknownProperties: true
            });
          }
        case 33:
          return _context2.abrupt("return", parsedResponse);
        case 34:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[21, 25]]);
  }));
  return _deserializeResponseBody.apply(this, arguments);
}
function isOperationSpecEmpty(operationSpec) {
  var expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
  var _a;
  var isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  var isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return {
          error: null,
          shouldReturnResponse: false
        };
      }
    } else {
      return {
        error: null,
        shouldReturnResponse: false
      };
    }
  }
  var errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  var initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ? "Unexpected status code: ".concat(parsedResponse.status) : parsedResponse.bodyAsText;
  var error = new _coreRestPipeline.RestError(initialErrorMessage, {
    statusCode: parsedResponse.status,
    request: parsedResponse.request,
    response: parsedResponse
  });
  // If the item failed but there's no error spec or default spec to deserialize the error,
  // we should fail so we just throw the parsed response
  if (!errorResponseSpec) {
    throw error;
  }
  var defaultBodyMapper = errorResponseSpec.bodyMapper;
  var defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    // If error response has a body, try to deserialize it using default body mapper.
    // Then try to extract error code & message from it
    if (parsedResponse.parsedBody) {
      var parsedBody = parsedResponse.parsedBody;
      var deserializedError;
      if (defaultBodyMapper) {
        var valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === _serializer.MapperTypeNames.Sequence) {
          valueToDeserialize = [];
          var elementName = defaultBodyMapper.xmlElementName;
          if (_typeof(parsedBody) === "object" && elementName) {
            valueToDeserialize = parsedBody[elementName];
          }
        }
        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
      }
      var internalError = parsedBody.error || deserializedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = deserializedError;
      }
    }
    // If error response has headers, try to deserialize it using default header mapper
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = "Error \"".concat(defaultError.message, "\" occurred in deserializing the responseBody - \"").concat(parsedResponse.bodyAsText, "\" for the default response.");
  }
  return {
    error: error,
    shouldReturnResponse: false
  };
}
function parse(_x6, _x7, _x8, _x9, _x10) {
  return _parse.apply(this, arguments);
}
function _parse() {
  _parse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
    var _a, text, contentType, contentComponents, body, msg, errCode, e;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          if (!(!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) && operationResponse.bodyAsText)) {
            _context3.next = 26;
            break;
          }
          text = operationResponse.bodyAsText;
          contentType = operationResponse.headers.get("Content-Type") || "";
          contentComponents = !contentType ? [] : contentType.split(";").map(function (component) {
            return component.toLowerCase();
          });
          _context3.prev = 4;
          if (!(contentComponents.length === 0 || contentComponents.some(function (component) {
            return jsonContentTypes.indexOf(component) !== -1;
          }))) {
            _context3.next = 10;
            break;
          }
          operationResponse.parsedBody = JSON.parse(text);
          return _context3.abrupt("return", operationResponse);
        case 10:
          if (!contentComponents.some(function (component) {
            return xmlContentTypes.indexOf(component) !== -1;
          })) {
            _context3.next = 18;
            break;
          }
          if (parseXML) {
            _context3.next = 13;
            break;
          }
          throw new Error("Parsing XML not supported.");
        case 13:
          _context3.next = 15;
          return parseXML(text, opts.xml);
        case 15:
          body = _context3.sent;
          operationResponse.parsedBody = body;
          return _context3.abrupt("return", operationResponse);
        case 18:
          _context3.next = 26;
          break;
        case 20:
          _context3.prev = 20;
          _context3.t0 = _context3["catch"](4);
          msg = "Error \"".concat(_context3.t0, "\" occurred while parsing the response body - ").concat(operationResponse.bodyAsText, ".");
          errCode = _context3.t0.code || _coreRestPipeline.RestError.PARSE_ERROR;
          e = new _coreRestPipeline.RestError(msg, {
            code: errCode,
            statusCode: operationResponse.status,
            request: operationResponse.request,
            response: operationResponse
          });
          throw e;
        case 26:
          return _context3.abrupt("return", operationResponse);
        case 27:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[4, 20]]);
  }));
  return _parse.apply(this, arguments);
}
},{"./interfaces":"node_modules/@azure/core-client/dist-esm/src/interfaces.js","@azure/core-rest-pipeline":"node_modules/@azure/core-rest-pipeline/dist-esm/src/index.js","./serializer":"node_modules/@azure/core-client/dist-esm/src/serializer.js","./operationHelpers":"node_modules/@azure/core-client/dist-esm/src/operationHelpers.js"}],"node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPathStringFromParameter = getPathStringFromParameter;
exports.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
var _serializer = require("./serializer");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Gets the list of status codes for streaming responses.
 * @internal
 */
function getStreamingResponseStatusCodes(operationSpec) {
  var result = new Set();
  for (var statusCode in operationSpec.responses) {
    var operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === _serializer.MapperTypeNames.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
/**
 * Get the path to this parameter's value as a dotted string (a.b.c).
 * @param parameter - The parameter to get the path string for.
 * @returns The path to this parameter's value as a dotted string.
 * @internal
 */
function getPathStringFromParameter(parameter) {
  var parameterPath = parameter.parameterPath,
    mapper = parameter.mapper;
  var result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}
},{"./serializer":"node_modules/@azure/core-client/dist-esm/src/serializer.js"}],"node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serializationPolicy = serializationPolicy;
exports.serializationPolicyName = void 0;
exports.serializeHeaders = serializeHeaders;
exports.serializeRequestBody = serializeRequestBody;
var _interfaces = require("./interfaces");
var _operationHelpers = require("./operationHelpers");
var _serializer = require("./serializer");
var _interfaceHelpers = require("./interfaceHelpers");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The programmatic identifier of the serializationPolicy.
 */
var serializationPolicyName = exports.serializationPolicyName = "serializationPolicy";
/**
 * This policy handles assembling the request body and headers using
 * an OperationSpec and OperationArguments on the request.
 */
function serializationPolicy() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var stringifyXML = options.stringifyXML;
  return {
    name: serializationPolicyName,
    sendRequest: function sendRequest(request, next) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var operationInfo, operationSpec, operationArguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              operationInfo = (0, _operationHelpers.getOperationRequestInfo)(request);
              operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
              operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
              if (operationSpec && operationArguments) {
                serializeHeaders(request, operationArguments, operationSpec);
                serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
              }
              return _context.abrupt("return", next(request));
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
/**
 * @internal
 */
function serializeHeaders(request, operationArguments, operationSpec) {
  var _a, _b;
  if (operationSpec.headerParameters) {
    var _iterator = _createForOfIteratorHelper(operationSpec.headerParameters),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var headerParameter = _step.value;
        var headerValue = (0, _operationHelpers.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
        if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {
          headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, _interfaceHelpers.getPathStringFromParameter)(headerParameter));
          var headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
          if (headerCollectionPrefix) {
            for (var _i = 0, _Object$keys = Object.keys(headerValue); _i < _Object$keys.length; _i++) {
              var key = _Object$keys[_i];
              request.headers.set(headerCollectionPrefix + key, headerValue[key]);
            }
          } else {
            request.headers.set(headerParameter.mapper.serializedName || (0, _interfaceHelpers.getPathStringFromParameter)(headerParameter), headerValue);
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  var customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;
  if (customHeaders) {
    for (var _i2 = 0, _Object$keys2 = Object.keys(customHeaders); _i2 < _Object$keys2.length; _i2++) {
      var customHeaderName = _Object$keys2[_i2];
      request.headers.set(customHeaderName, customHeaders[customHeaderName]);
    }
  }
}
/**
 * @internal
 */
function serializeRequestBody(request, operationArguments, operationSpec) {
  var stringifyXML = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {
    throw new Error("XML serialization unsupported!");
  };
  var _a, _b, _c, _d, _e;
  var serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
  var updatedOptions = {
    xml: {
      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : "",
      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,
      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : _interfaces.XML_CHARKEY
    }
  };
  var xmlCharKey = updatedOptions.xml.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    request.body = (0, _operationHelpers.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
    var bodyMapper = operationSpec.requestBody.mapper;
    var required = bodyMapper.required,
      serializedName = bodyMapper.serializedName,
      xmlName = bodyMapper.xmlName,
      xmlElementName = bodyMapper.xmlElementName,
      xmlNamespace = bodyMapper.xmlNamespace,
      xmlNamespacePrefix = bodyMapper.xmlNamespacePrefix,
      nullable = bodyMapper.nullable;
    var typeName = bodyMapper.type.name;
    try {
      if (request.body !== undefined && request.body !== null || nullable && request.body === null || required) {
        var requestBodyParameterPathString = (0, _interfaceHelpers.getPathStringFromParameter)(operationSpec.requestBody);
        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
        var isStream = typeName === _serializer.MapperTypeNames.Stream;
        if (operationSpec.isXML) {
          var xmlnsKey = xmlNamespacePrefix ? "xmlns:".concat(xmlNamespacePrefix) : "xmlns";
          var value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
          if (typeName === _serializer.MapperTypeNames.Sequence) {
            request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
              rootName: xmlName || serializedName,
              xmlCharKey: xmlCharKey
            });
          } else if (!isStream) {
            request.body = stringifyXML(value, {
              rootName: xmlName || serializedName,
              xmlCharKey: xmlCharKey
            });
          }
        } else if (typeName === _serializer.MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
          // the String serializer has validated that request body is a string
          // so just send the string.
          return;
        } else if (!isStream) {
          request.body = JSON.stringify(request.body);
        }
      }
    } catch (error) {
      throw new Error("Error \"".concat(error.message, "\" occurred in serializing the payload - ").concat(JSON.stringify(serializedName, undefined, "  "), "."));
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    request.formData = {};
    var _iterator2 = _createForOfIteratorHelper(operationSpec.formDataParameters),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var formDataParameter = _step2.value;
        var formDataParameterValue = (0, _operationHelpers.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
        if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
          var formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, _interfaceHelpers.getPathStringFromParameter)(formDataParameter);
          request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, _interfaceHelpers.getPathStringFromParameter)(formDataParameter), updatedOptions);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
}
/**
 * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself
 */
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  // Composite and Sequence schemas already got their root namespace set during serialization
  // We just need to add xmlns to the other schema types
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    var result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[_interfaces.XML_ATTRKEY] = _defineProperty({}, xmlnsKey, xmlNamespace);
    return result;
  }
  return serializedValue;
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return _defineProperty({}, elementName, obj);
  }
  var result = _defineProperty({}, elementName, obj);
  result[_interfaces.XML_ATTRKEY] = _defineProperty({}, xmlNamespaceKey, xmlNamespace);
  return result;
}
},{"./interfaces":"node_modules/@azure/core-client/dist-esm/src/interfaces.js","./operationHelpers":"node_modules/@azure/core-client/dist-esm/src/operationHelpers.js","./serializer":"node_modules/@azure/core-client/dist-esm/src/serializer.js","./interfaceHelpers":"node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js"}],"node_modules/@azure/core-client/dist-esm/src/pipeline.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createClientPipeline = createClientPipeline;
var _deserializationPolicy = require("./deserializationPolicy");
var _coreRestPipeline = require("@azure/core-rest-pipeline");
var _serializationPolicy = require("./serializationPolicy");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * Creates a new Pipeline for use with a Service Client.
 * Adds in deserializationPolicy by default.
 * Also adds in bearerTokenAuthenticationPolicy if passed a TokenCredential.
 * @param options - Options to customize the created pipeline.
 */
function createClientPipeline() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var pipeline = (0, _coreRestPipeline.createPipelineFromOptions)(options !== null && options !== void 0 ? options : {});
  if (options.credentialOptions) {
    pipeline.addPolicy((0, _coreRestPipeline.bearerTokenAuthenticationPolicy)({
      credential: options.credentialOptions.credential,
      scopes: options.credentialOptions.credentialScopes
    }));
  }
  pipeline.addPolicy((0, _serializationPolicy.serializationPolicy)(options.serializationOptions), {
    phase: "Serialize"
  });
  pipeline.addPolicy((0, _deserializationPolicy.deserializationPolicy)(options.deserializationOptions), {
    phase: "Deserialize"
  });
  return pipeline;
}
},{"./deserializationPolicy":"node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js","@azure/core-rest-pipeline":"node_modules/@azure/core-rest-pipeline/dist-esm/src/index.js","./serializationPolicy":"node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js"}],"node_modules/@azure/core-client/dist-esm/src/httpClientCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
var _coreRestPipeline = require("@azure/core-rest-pipeline");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var cachedHttpClient;
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = (0, _coreRestPipeline.createDefaultHttpClient)();
  }
  return cachedHttpClient;
}
},{"@azure/core-rest-pipeline":"node_modules/@azure/core-rest-pipeline/dist-esm/src/index.js"}],"node_modules/@azure/core-client/dist-esm/src/urlHelpers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.appendQueryParams = appendQueryParams;
exports.getRequestUrl = getRequestUrl;
var _operationHelpers = require("./operationHelpers");
var _interfaceHelpers = require("./interfaceHelpers");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var CollectionFormatToDelimiterMap = {
  CSV: ",",
  SSV: " ",
  Multi: "Multi",
  TSV: "\t",
  Pipes: "|"
};
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
  var urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
  var isAbsolutePath = false;
  var requestUrl = replaceAll(baseUri, urlReplacements);
  if (operationSpec.path) {
    var path = replaceAll(operationSpec.path, urlReplacements);
    // QUIRK: sometimes we get a path component like /{nextLink}
    // which may be a fully formed URL with a leading /. In that case, we should
    // remove the leading /
    if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
      path = path.substring(1);
    }
    // QUIRK: sometimes we get a path component like {nextLink}
    // which may be a fully formed URL. In that case, we should
    // ignore the baseUri.
    if (isAbsoluteUrl(path)) {
      requestUrl = path;
      isAbsolutePath = true;
    } else {
      requestUrl = appendPath(requestUrl, path);
    }
  }
  var _calculateQueryParame = calculateQueryParameters(operationSpec, operationArguments, fallbackObject),
    queryParams = _calculateQueryParame.queryParams,
    sequenceParams = _calculateQueryParame.sequenceParams;
  /**
   * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`
   * is an absolute path. This ensures that existing query parameter values in `requestUrl`
   * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it
   * is still being built so there is nothing to overwrite.
   */
  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
  return requestUrl;
}
function replaceAll(input, replacements) {
  var result = input;
  var _iterator = _createForOfIteratorHelper(replacements),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
        searchValue = _step$value[0],
        replaceValue = _step$value[1];
      result = result.split(searchValue).join(replaceValue);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
  var _a;
  var result = new Map();
  if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {
    var _iterator2 = _createForOfIteratorHelper(operationSpec.urlParameters),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var urlParameter = _step2.value;
        var urlParameterValue = (0, _operationHelpers.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
        var parameterPathString = (0, _interfaceHelpers.getPathStringFromParameter)(urlParameter);
        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
        if (!urlParameter.skipEncoding) {
          urlParameterValue = encodeURIComponent(urlParameterValue);
        }
        result.set("{".concat(urlParameter.mapper.serializedName || parameterPathString, "}"), urlParameterValue);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return result;
}
function isAbsoluteUrl(url) {
  return url.includes("://");
}
function appendPath(url, pathToAppend) {
  if (!pathToAppend) {
    return url;
  }
  var parsedUrl = new URL(url);
  var newPath = parsedUrl.pathname;
  if (!newPath.endsWith("/")) {
    newPath = "".concat(newPath, "/");
  }
  if (pathToAppend.startsWith("/")) {
    pathToAppend = pathToAppend.substring(1);
  }
  var searchStart = pathToAppend.indexOf("?");
  if (searchStart !== -1) {
    var path = pathToAppend.substring(0, searchStart);
    var search = pathToAppend.substring(searchStart + 1);
    newPath = newPath + path;
    if (search) {
      parsedUrl.search = parsedUrl.search ? "".concat(parsedUrl.search, "&").concat(search) : search;
    }
  } else {
    newPath = newPath + pathToAppend;
  }
  parsedUrl.pathname = newPath;
  return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
  var _a;
  var result = new Map();
  var sequenceParams = new Set();
  if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {
    var _iterator3 = _createForOfIteratorHelper(operationSpec.queryParameters),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var queryParameter = _step3.value;
        if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
          sequenceParams.add(queryParameter.mapper.serializedName);
        }
        var queryParameterValue = (0, _operationHelpers.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
        if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {
          queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, _interfaceHelpers.getPathStringFromParameter)(queryParameter));
          var delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
          if (Array.isArray(queryParameterValue)) {
            // replace null and undefined
            queryParameterValue = queryParameterValue.map(function (item) {
              if (item === null || item === undefined) {
                return "";
              }
              return item;
            });
          }
          if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
            continue;
          } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          if (!queryParameter.skipEncoding) {
            if (Array.isArray(queryParameterValue)) {
              queryParameterValue = queryParameterValue.map(function (item) {
                return encodeURIComponent(item);
              });
            } else {
              queryParameterValue = encodeURIComponent(queryParameterValue);
            }
          }
          // Join pipes and CSV *after* encoding, or the server will be upset.
          if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          result.set(queryParameter.mapper.serializedName || (0, _interfaceHelpers.getPathStringFromParameter)(queryParameter), queryParameterValue);
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  return {
    queryParams: result,
    sequenceParams: sequenceParams
  };
}
function simpleParseQueryParams(queryString) {
  var result = new Map();
  if (!queryString || queryString[0] !== "?") {
    return result;
  }
  // remove the leading ?
  queryString = queryString.slice(1);
  var pairs = queryString.split("&");
  var _iterator4 = _createForOfIteratorHelper(pairs),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var pair = _step4.value;
      var _pair$split = pair.split("=", 2),
        _pair$split2 = _slicedToArray(_pair$split, 2),
        name = _pair$split2[0],
        value = _pair$split2[1];
      var existingValue = result.get(name);
      if (existingValue) {
        if (Array.isArray(existingValue)) {
          existingValue.push(value);
        } else {
          result.set(name, [existingValue, value]);
        }
      } else {
        result.set(name, value);
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return result;
}
/** @internal */
function appendQueryParams(url, queryParams, sequenceParams) {
  var noOverwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (queryParams.size === 0) {
    return url;
  }
  var parsedUrl = new URL(url);
  // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which
  // can change their meaning to the server, such as in the case of a SAS signature.
  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves
  var combinedParams = simpleParseQueryParams(parsedUrl.search);
  var _iterator5 = _createForOfIteratorHelper(queryParams),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _step5$value = _slicedToArray(_step5.value, 2),
        name = _step5$value[0],
        value = _step5$value[1];
      var existingValue = combinedParams.get(name);
      if (Array.isArray(existingValue)) {
        if (Array.isArray(value)) {
          existingValue.push.apply(existingValue, _toConsumableArray(value));
          var valueSet = new Set(existingValue);
          combinedParams.set(name, Array.from(valueSet));
        } else {
          existingValue.push(value);
        }
      } else if (existingValue) {
        if (Array.isArray(value)) {
          value.unshift(existingValue);
        } else if (sequenceParams.has(name)) {
          combinedParams.set(name, [existingValue, value]);
        }
        if (!noOverwrite) {
          combinedParams.set(name, value);
        }
      } else {
        combinedParams.set(name, value);
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  var searchPieces = [];
  var _iterator6 = _createForOfIteratorHelper(combinedParams),
    _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var _step6$value = _slicedToArray(_step6.value, 2),
        _name = _step6$value[0],
        _value = _step6$value[1];
      if (typeof _value === "string") {
        searchPieces.push("".concat(_name, "=").concat(_value));
      } else if (Array.isArray(_value)) {
        // QUIRK: If we get an array of values, include multiple key/value pairs
        var _iterator7 = _createForOfIteratorHelper(_value),
          _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var subValue = _step7.value;
            searchPieces.push("".concat(_name, "=").concat(subValue));
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      } else {
        searchPieces.push("".concat(_name, "=").concat(_value));
      }
    }
    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
  parsedUrl.search = searchPieces.length ? "?".concat(searchPieces.join("&")) : "";
  return parsedUrl.toString();
}
},{"./operationHelpers":"node_modules/@azure/core-client/dist-esm/src/operationHelpers.js","./interfaceHelpers":"node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js"}],"node_modules/@azure/core-client/dist-esm/src/log.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = void 0;
var _logger = require("@azure/logger");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

var logger = exports.logger = (0, _logger.createClientLogger)("core-client");
},{"@azure/logger":"node_modules/@azure/logger/dist-esm/src/index.js"}],"node_modules/@azure/core-client/dist-esm/src/serviceClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServiceClient = void 0;
var _coreRestPipeline = require("@azure/core-rest-pipeline");
var _pipeline = require("./pipeline");
var _utils = require("./utils");
var _httpClientCache = require("./httpClientCache");
var _operationHelpers = require("./operationHelpers");
var _urlHelpers = require("./urlHelpers");
var _interfaceHelpers = require("./interfaceHelpers");
var _log = require("./log");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Initializes a new instance of the ServiceClient.
 */
var ServiceClient = exports.ServiceClient = /*#__PURE__*/function () {
  /**
   * The ServiceClient constructor
   * @param credential - The credentials used for authentication with the service.
   * @param options - The service client options that govern the behavior of the client.
   */
  function ServiceClient() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, ServiceClient);
    var _a, _b;
    this._requestContentType = options.requestContentType;
    this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;
    if (options.baseUri) {
      _log.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
    }
    this._allowInsecureConnection = options.allowInsecureConnection;
    this._httpClient = options.httpClient || (0, _httpClientCache.getCachedDefaultHttpClient)();
    this.pipeline = options.pipeline || createDefaultPipeline(options);
    if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {
      var _iterator = _createForOfIteratorHelper(options.additionalPolicies),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
            policy = _step$value.policy,
            position = _step$value.position;
          // Sign happens after Retry and is commonly needed to occur
          // before policies that intercept post-retry.
          var afterPhase = position === "perRetry" ? "Sign" : undefined;
          this.pipeline.addPolicy(policy, {
            afterPhase: afterPhase
          });
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }
  /**
   * Send the provided httpRequest.
   */
  _createClass(ServiceClient, [{
    key: "sendRequest",
    value: (function () {
      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.pipeline.sendRequest(this._httpClient, request));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function sendRequest(_x) {
        return _sendRequest.apply(this, arguments);
      }
      return sendRequest;
    }()
    /**
     * Send an HTTP request that is populated using the provided OperationSpec.
     * @typeParam T - The typed result of the request, based on the OperationSpec.
     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
     * @param operationSpec - The OperationSpec to use to populate the httpRequest.
     */
    )
  }, {
    key: "sendOperationRequest",
    value: (function () {
      var _sendOperationRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(operationArguments, operationSpec) {
        var endpoint, url, request, operationInfo, contentType, options, requestOptions, rawResponse, flatResponse, _rawResponse, _flatResponse;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              endpoint = operationSpec.baseUrl || this._endpoint;
              if (endpoint) {
                _context2.next = 3;
                break;
              }
              throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
            case 3:
              // Templatized URLs sometimes reference properties on the ServiceClient child class,
              // so we have to pass `this` below in order to search these properties if they're
              // not part of OperationArguments
              url = (0, _urlHelpers.getRequestUrl)(endpoint, operationSpec, operationArguments, this);
              request = (0, _coreRestPipeline.createPipelineRequest)({
                url: url
              });
              request.method = operationSpec.httpMethod;
              operationInfo = (0, _operationHelpers.getOperationRequestInfo)(request);
              operationInfo.operationSpec = operationSpec;
              operationInfo.operationArguments = operationArguments;
              contentType = operationSpec.contentType || this._requestContentType;
              if (contentType && operationSpec.requestBody) {
                request.headers.set("Content-Type", contentType);
              }
              options = operationArguments.options;
              if (options) {
                requestOptions = options.requestOptions;
                if (requestOptions) {
                  if (requestOptions.timeout) {
                    request.timeout = requestOptions.timeout;
                  }
                  if (requestOptions.onUploadProgress) {
                    request.onUploadProgress = requestOptions.onUploadProgress;
                  }
                  if (requestOptions.onDownloadProgress) {
                    request.onDownloadProgress = requestOptions.onDownloadProgress;
                  }
                  if (requestOptions.shouldDeserialize !== undefined) {
                    operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
                  }
                  if (requestOptions.allowInsecureConnection) {
                    request.allowInsecureConnection = true;
                  }
                }
                if (options.abortSignal) {
                  request.abortSignal = options.abortSignal;
                }
                if (options.tracingOptions) {
                  request.tracingOptions = options.tracingOptions;
                }
              }
              if (this._allowInsecureConnection) {
                request.allowInsecureConnection = true;
              }
              if (request.streamResponseStatusCodes === undefined) {
                request.streamResponseStatusCodes = (0, _interfaceHelpers.getStreamingResponseStatusCodes)(operationSpec);
              }
              _context2.prev = 15;
              _context2.next = 18;
              return this.sendRequest(request);
            case 18:
              rawResponse = _context2.sent;
              flatResponse = (0, _utils.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
              if (options === null || options === void 0 ? void 0 : options.onResponse) {
                options.onResponse(rawResponse, flatResponse);
              }
              return _context2.abrupt("return", flatResponse);
            case 24:
              _context2.prev = 24;
              _context2.t0 = _context2["catch"](15);
              if (_typeof(_context2.t0) === "object" && (_context2.t0 === null || _context2.t0 === void 0 ? void 0 : _context2.t0.response)) {
                _rawResponse = _context2.t0.response;
                _flatResponse = (0, _utils.flattenResponse)(_rawResponse, operationSpec.responses[_context2.t0.statusCode] || operationSpec.responses["default"]);
                _context2.t0.details = _flatResponse;
                if (options === null || options === void 0 ? void 0 : options.onResponse) {
                  options.onResponse(_rawResponse, _flatResponse, _context2.t0);
                }
              }
              throw _context2.t0;
            case 28:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[15, 24]]);
      }));
      function sendOperationRequest(_x2, _x3) {
        return _sendOperationRequest.apply(this, arguments);
      }
      return sendOperationRequest;
    }())
  }]);
  return ServiceClient;
}();
function createDefaultPipeline(options) {
  var credentialScopes = getCredentialScopes(options);
  var credentialOptions = options.credential && credentialScopes ? {
    credentialScopes: credentialScopes,
    credential: options.credential
  } : undefined;
  return (0, _pipeline.createClientPipeline)(Object.assign(Object.assign({}, options), {
    credentialOptions: credentialOptions
  }));
}
function getCredentialScopes(options) {
  if (options.credentialScopes) {
    return options.credentialScopes;
  }
  if (options.endpoint) {
    return "".concat(options.endpoint, "/.default");
  }
  if (options.baseUri) {
    return "".concat(options.baseUri, "/.default");
  }
  if (options.credential && !options.credentialScopes) {
    throw new Error("When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy");
  }
  return undefined;
}
},{"@azure/core-rest-pipeline":"node_modules/@azure/core-rest-pipeline/dist-esm/src/index.js","./pipeline":"node_modules/@azure/core-client/dist-esm/src/pipeline.js","./utils":"node_modules/@azure/core-client/dist-esm/src/utils.js","./httpClientCache":"node_modules/@azure/core-client/dist-esm/src/httpClientCache.js","./operationHelpers":"node_modules/@azure/core-client/dist-esm/src/operationHelpers.js","./urlHelpers":"node_modules/@azure/core-client/dist-esm/src/urlHelpers.js","./interfaceHelpers":"node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js","./log":"node_modules/@azure/core-client/dist-esm/src/log.js"}],"node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnClaimChallenge.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
exports.parseCAEChallenge = parseCAEChallenge;
var _log = require("./log");
var _base = require("./base64");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Converts: `Bearer a="b", c="d", Bearer d="e", f="g"`.
 * Into: `[ { a: 'b', c: 'd' }, { d: 'e', f: 'g' } ]`.
 *
 * @internal
 */
function parseCAEChallenge(challenges) {
  var bearerChallenges = ", ".concat(challenges.trim()).split(", Bearer ").filter(function (x) {
    return x;
  });
  return bearerChallenges.map(function (challenge) {
    var challengeParts = "".concat(challenge.trim(), ", ").split('", ').filter(function (x) {
      return x;
    });
    var keyValuePairs = challengeParts.map(function (keyValue) {
      return function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];
        return _defineProperty({}, key, value);
      }(keyValue.trim().split('="'));
    });
    // Key-value pairs to plain object:
    return keyValuePairs.reduce(function (a, b) {
      return Object.assign(Object.assign({}, a), b);
    }, {});
  });
}
/**
 * This function can be used as a callback for the `bearerTokenAuthenticationPolicy` of `@azure/core-rest-pipeline`, to support CAE challenges:
 * [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation).
 *
 * Call the `bearerTokenAuthenticationPolicy` with the following options:
 *
 * ```ts
 * import { bearerTokenAuthenticationPolicy } from "@azure/core-rest-pipeline";
 * import { authorizeRequestOnClaimChallenge } from "@azure/core-client";
 *
 * const bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy({
 *   authorizeRequestOnChallenge: authorizeRequestOnClaimChallenge
 * });
 * ```
 *
 * Once provided, the `bearerTokenAuthenticationPolicy` policy will internally handle Continuous Access Evaluation (CAE) challenges.
 * When it can't complete a challenge it will return the 401 (unauthorized) response from ARM.
 *
 * Example challenge with claims:
 *
 * ```
 * Bearer authorization_uri="https://login.windows-ppe.net/", error="invalid_token",
 * error_description="User session has been revoked",
 * claims="eyJhY2Nlc3NfdG9rZW4iOnsibmJmIjp7ImVzc2VudGlhbCI6dHJ1ZSwgInZhbHVlIjoiMTYwMzc0MjgwMCJ9fX0="
 * ```
 */
function authorizeRequestOnClaimChallenge(_x) {
  return _authorizeRequestOnClaimChallenge.apply(this, arguments);
}
function _authorizeRequestOnClaimChallenge() {
  _authorizeRequestOnClaimChallenge = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(onChallengeOptions) {
    var scopes, response, logger, challenge, challenges, parsedChallenge, accessToken;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          scopes = onChallengeOptions.scopes, response = onChallengeOptions.response;
          logger = onChallengeOptions.logger || _log.logger;
          challenge = response.headers.get("WWW-Authenticate");
          if (challenge) {
            _context.next = 6;
            break;
          }
          logger.info("The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.");
          return _context.abrupt("return", false);
        case 6:
          challenges = parseCAEChallenge(challenge) || [];
          parsedChallenge = challenges.find(function (x) {
            return x.claims;
          });
          if (parsedChallenge) {
            _context.next = 11;
            break;
          }
          logger.info("The WWW-Authenticate header was missing the necessary \"claims\" to perform the Continuous Access Evaluation authentication flow.");
          return _context.abrupt("return", false);
        case 11:
          _context.next = 13;
          return onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
            claims: (0, _base.decodeStringToString)(parsedChallenge.claims)
          });
        case 13:
          accessToken = _context.sent;
          if (accessToken) {
            _context.next = 16;
            break;
          }
          return _context.abrupt("return", false);
        case 16:
          onChallengeOptions.request.headers.set("Authorization", "Bearer ".concat(accessToken.token));
          return _context.abrupt("return", true);
        case 18:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _authorizeRequestOnClaimChallenge.apply(this, arguments);
}
},{"./log":"node_modules/@azure/core-client/dist-esm/src/log.js","./base64":"node_modules/@azure/core-client/dist-esm/src/base64.browser.js"}],"node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnTenantChallenge.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.authorizeRequestOnTenantChallenge = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A set of constants used internally when processing requests.
 */
var Constants = {
  DefaultScope: "/.default",
  /**
   * Defines constants for use with HTTP headers.
   */
  HeaderConstants: {
    /**
     * The Authorization header.
     */
    AUTHORIZATION: "authorization"
  }
};
/**
 * Defines a callback to handle auth challenge for Storage APIs.
 * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge
 * Handling has specific features for storage that departs to the general AAD challenge docs.
 **/
var authorizeRequestOnTenantChallenge = exports.authorizeRequestOnTenantChallenge = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(challengeOptions) {
    var requestOptions, challenge, challengeInfo, challengeScopes, tenantId, accessToken;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          requestOptions = requestToOptions(challengeOptions.request);
          challenge = getChallenge(challengeOptions.response);
          if (!challenge) {
            _context.next = 13;
            break;
          }
          challengeInfo = parseChallenge(challenge);
          challengeScopes = buildScopes(challengeOptions, challengeInfo);
          tenantId = extractTenantId(challengeInfo);
          _context.next = 8;
          return challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), {
            tenantId: tenantId
          }));
        case 8:
          accessToken = _context.sent;
          if (accessToken) {
            _context.next = 11;
            break;
          }
          return _context.abrupt("return", false);
        case 11:
          challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, "Bearer ".concat(accessToken.token));
          return _context.abrupt("return", true);
        case 13:
          return _context.abrupt("return", false);
        case 14:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function authorizeRequestOnTenantChallenge(_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Extracts the tenant id from the challenge information
 * The tenant id is contained in the authorization_uri as the first
 * path part.
 */
function extractTenantId(challengeInfo) {
  var parsedAuthUri = new URL(challengeInfo.authorization_uri);
  var pathSegments = parsedAuthUri.pathname.split("/");
  var tenantId = pathSegments[1];
  return tenantId;
}
/**
 * Builds the authentication scopes based on the information that comes in the
 * challenge information. Scopes url is present in the resource_id, if it is empty
 * we keep using the original scopes.
 */
function buildScopes(challengeOptions, challengeInfo) {
  if (!challengeInfo.resource_uri) {
    return challengeOptions.scopes;
  }
  var challengeScopes = new URL(challengeInfo.resource_uri);
  challengeScopes.pathname = Constants.DefaultScope;
  return [challengeScopes.toString()];
}
/**
 * We will retrieve the challenge only if the response status code was 401,
 * and if the response contained the header "WWW-Authenticate" with a non-empty value.
 */
function getChallenge(response) {
  var challenge = response.headers.get("WWW-Authenticate");
  if (response.status === 401 && challenge) {
    return challenge;
  }
  return;
}
/**
 * Converts: `Bearer a="b" c="d"`.
 * Into: `[ { a: 'b', c: 'd' }]`.
 *
 * @internal
 */
function parseChallenge(challenge) {
  var bearerChallenge = challenge.slice("Bearer ".length);
  var challengeParts = "".concat(bearerChallenge.trim(), " ").split(" ").filter(function (x) {
    return x;
  });
  var keyValuePairs = challengeParts.map(function (keyValue) {
    return function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
        key = _ref3[0],
        value = _ref3[1];
      return _defineProperty({}, key, value);
    }(keyValue.trim().split("="));
  });
  // Key-value pairs to plain object:
  return keyValuePairs.reduce(function (a, b) {
    return Object.assign(Object.assign({}, a), b);
  }, {});
}
/**
 * Extracts the options form a Pipeline Request for later re-use
 */
function requestToOptions(request) {
  return {
    abortSignal: request.abortSignal,
    requestOptions: {
      timeout: request.timeout
    },
    tracingOptions: request.tracingOptions
  };
}
},{}],"node_modules/@azure/core-client/dist-esm/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "MapperTypeNames", {
  enumerable: true,
  get: function () {
    return _serializer.MapperTypeNames;
  }
});
Object.defineProperty(exports, "ServiceClient", {
  enumerable: true,
  get: function () {
    return _serviceClient.ServiceClient;
  }
});
Object.defineProperty(exports, "XML_ATTRKEY", {
  enumerable: true,
  get: function () {
    return _interfaces.XML_ATTRKEY;
  }
});
Object.defineProperty(exports, "XML_CHARKEY", {
  enumerable: true,
  get: function () {
    return _interfaces.XML_CHARKEY;
  }
});
Object.defineProperty(exports, "authorizeRequestOnClaimChallenge", {
  enumerable: true,
  get: function () {
    return _authorizeRequestOnClaimChallenge.authorizeRequestOnClaimChallenge;
  }
});
Object.defineProperty(exports, "authorizeRequestOnTenantChallenge", {
  enumerable: true,
  get: function () {
    return _authorizeRequestOnTenantChallenge.authorizeRequestOnTenantChallenge;
  }
});
Object.defineProperty(exports, "createClientPipeline", {
  enumerable: true,
  get: function () {
    return _pipeline.createClientPipeline;
  }
});
Object.defineProperty(exports, "createSerializer", {
  enumerable: true,
  get: function () {
    return _serializer.createSerializer;
  }
});
Object.defineProperty(exports, "deserializationPolicy", {
  enumerable: true,
  get: function () {
    return _deserializationPolicy.deserializationPolicy;
  }
});
Object.defineProperty(exports, "deserializationPolicyName", {
  enumerable: true,
  get: function () {
    return _deserializationPolicy.deserializationPolicyName;
  }
});
Object.defineProperty(exports, "serializationPolicy", {
  enumerable: true,
  get: function () {
    return _serializationPolicy.serializationPolicy;
  }
});
Object.defineProperty(exports, "serializationPolicyName", {
  enumerable: true,
  get: function () {
    return _serializationPolicy.serializationPolicyName;
  }
});
var _serializer = require("./serializer");
var _serviceClient = require("./serviceClient");
var _pipeline = require("./pipeline");
var _interfaces = require("./interfaces");
var _deserializationPolicy = require("./deserializationPolicy");
var _serializationPolicy = require("./serializationPolicy");
var _authorizeRequestOnClaimChallenge = require("./authorizeRequestOnClaimChallenge");
var _authorizeRequestOnTenantChallenge = require("./authorizeRequestOnTenantChallenge");
},{"./serializer":"node_modules/@azure/core-client/dist-esm/src/serializer.js","./serviceClient":"node_modules/@azure/core-client/dist-esm/src/serviceClient.js","./pipeline":"node_modules/@azure/core-client/dist-esm/src/pipeline.js","./interfaces":"node_modules/@azure/core-client/dist-esm/src/interfaces.js","./deserializationPolicy":"node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js","./serializationPolicy":"node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js","./authorizeRequestOnClaimChallenge":"node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnClaimChallenge.js","./authorizeRequestOnTenantChallenge":"node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnTenantChallenge.js"}],"node_modules/@azure/communication-email/dist-esm/src/generated/src/models/mappers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorResponse = exports.ErrorDetail = exports.ErrorAdditionalInfo = exports.EmailSendResult = exports.EmailSendHeaders = exports.EmailSendExceptionHeaders = exports.EmailRecipients = exports.EmailMessage = exports.EmailGetSendResultHeaders = exports.EmailGetSendResultExceptionHeaders = exports.EmailContent = exports.EmailAttachment = exports.EmailAddress = void 0;
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var EmailSendResult = exports.EmailSendResult = {
  type: {
    name: "Composite",
    className: "EmailSendResult",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      status: {
        serializedName: "status",
        required: true,
        type: {
          name: "String"
        }
      },
      error: {
        serializedName: "error",
        type: {
          name: "Composite",
          className: "ErrorDetail"
        }
      }
    }
  }
};
var ErrorDetail = exports.ErrorDetail = {
  type: {
    name: "Composite",
    className: "ErrorDetail",
    modelProperties: {
      code: {
        serializedName: "code",
        readOnly: true,
        type: {
          name: "String"
        }
      },
      message: {
        serializedName: "message",
        readOnly: true,
        type: {
          name: "String"
        }
      },
      target: {
        serializedName: "target",
        readOnly: true,
        type: {
          name: "String"
        }
      },
      details: {
        serializedName: "details",
        readOnly: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ErrorDetail"
            }
          }
        }
      },
      additionalInfo: {
        serializedName: "additionalInfo",
        readOnly: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ErrorAdditionalInfo"
            }
          }
        }
      }
    }
  }
};
var ErrorAdditionalInfo = exports.ErrorAdditionalInfo = {
  type: {
    name: "Composite",
    className: "ErrorAdditionalInfo",
    modelProperties: {
      type: {
        serializedName: "type",
        readOnly: true,
        type: {
          name: "String"
        }
      },
      info: {
        serializedName: "info",
        readOnly: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
var ErrorResponse = exports.ErrorResponse = {
  type: {
    name: "Composite",
    className: "ErrorResponse",
    modelProperties: {
      error: {
        serializedName: "error",
        type: {
          name: "Composite",
          className: "ErrorDetail"
        }
      }
    }
  }
};
var EmailMessage = exports.EmailMessage = {
  type: {
    name: "Composite",
    className: "EmailMessage",
    modelProperties: {
      headers: {
        serializedName: "headers",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        }
      },
      senderAddress: {
        serializedName: "senderAddress",
        required: true,
        type: {
          name: "String"
        }
      },
      content: {
        serializedName: "content",
        type: {
          name: "Composite",
          className: "EmailContent"
        }
      },
      recipients: {
        serializedName: "recipients",
        type: {
          name: "Composite",
          className: "EmailRecipients"
        }
      },
      attachments: {
        serializedName: "attachments",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "EmailAttachment"
            }
          }
        }
      },
      replyTo: {
        serializedName: "replyTo",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "EmailAddress"
            }
          }
        }
      },
      disableUserEngagementTracking: {
        serializedName: "userEngagementTrackingDisabled",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
var EmailContent = exports.EmailContent = {
  type: {
    name: "Composite",
    className: "EmailContent",
    modelProperties: {
      subject: {
        serializedName: "subject",
        required: true,
        type: {
          name: "String"
        }
      },
      plainText: {
        serializedName: "plainText",
        type: {
          name: "String"
        }
      },
      html: {
        serializedName: "html",
        type: {
          name: "String"
        }
      }
    }
  }
};
var EmailRecipients = exports.EmailRecipients = {
  type: {
    name: "Composite",
    className: "EmailRecipients",
    modelProperties: {
      to: {
        serializedName: "to",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "EmailAddress"
            }
          }
        }
      },
      cc: {
        serializedName: "cc",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "EmailAddress"
            }
          }
        }
      },
      bcc: {
        serializedName: "bcc",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "EmailAddress"
            }
          }
        }
      }
    }
  }
};
var EmailAddress = exports.EmailAddress = {
  type: {
    name: "Composite",
    className: "EmailAddress",
    modelProperties: {
      address: {
        serializedName: "address",
        required: true,
        type: {
          name: "String"
        }
      },
      displayName: {
        serializedName: "displayName",
        type: {
          name: "String"
        }
      }
    }
  }
};
var EmailAttachment = exports.EmailAttachment = {
  type: {
    name: "Composite",
    className: "EmailAttachment",
    modelProperties: {
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      contentType: {
        serializedName: "contentType",
        required: true,
        type: {
          name: "String"
        }
      },
      contentInBase64: {
        serializedName: "contentInBase64",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var EmailGetSendResultHeaders = exports.EmailGetSendResultHeaders = {
  type: {
    name: "Composite",
    className: "EmailGetSendResultHeaders",
    modelProperties: {
      retryAfter: {
        serializedName: "retry-after",
        type: {
          name: "Number"
        }
      }
    }
  }
};
var EmailGetSendResultExceptionHeaders = exports.EmailGetSendResultExceptionHeaders = {
  type: {
    name: "Composite",
    className: "EmailGetSendResultExceptionHeaders",
    modelProperties: {
      xMsErrorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
};
var EmailSendHeaders = exports.EmailSendHeaders = {
  type: {
    name: "Composite",
    className: "EmailSendHeaders",
    modelProperties: {
      operationLocation: {
        serializedName: "operation-location",
        type: {
          name: "String"
        }
      },
      retryAfter: {
        serializedName: "retry-after",
        type: {
          name: "Number"
        }
      }
    }
  }
};
var EmailSendExceptionHeaders = exports.EmailSendExceptionHeaders = {
  type: {
    name: "Composite",
    className: "EmailSendExceptionHeaders",
    modelProperties: {
      xMsErrorCode: {
        serializedName: "x-ms-error-code",
        type: {
          name: "String"
        }
      }
    }
  }
};
},{}],"node_modules/@azure/communication-email/dist-esm/src/generated/src/models/parameters.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operationId1 = exports.operationId = exports.message = exports.endpoint = exports.contentType = exports.clientRequestId = exports.apiVersion = exports.accept = void 0;
var _mappers = require("../models/mappers");
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

var accept = exports.accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
var endpoint = exports.endpoint = {
  parameterPath: "endpoint",
  mapper: {
    serializedName: "endpoint",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
var operationId = exports.operationId = {
  parameterPath: "operationId",
  mapper: {
    serializedName: "operationId",
    required: true,
    type: {
      name: "String"
    }
  }
};
var apiVersion = exports.apiVersion = {
  parameterPath: "apiVersion",
  mapper: {
    defaultValue: "2023-03-31",
    isConstant: true,
    serializedName: "api-version",
    type: {
      name: "String"
    }
  }
};
var contentType = exports.contentType = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
var message = exports.message = {
  parameterPath: "message",
  mapper: _mappers.EmailMessage
};
var operationId1 = exports.operationId1 = {
  parameterPath: ["options", "operationId"],
  mapper: {
    serializedName: "Operation-Id",
    type: {
      name: "Uuid"
    }
  }
};
var clientRequestId = exports.clientRequestId = {
  parameterPath: ["options", "clientRequestId"],
  mapper: {
    serializedName: "x-ms-client-request-id",
    type: {
      name: "Uuid"
    }
  }
};
},{"../models/mappers":"node_modules/@azure/communication-email/dist-esm/src/generated/src/models/mappers.js"}],"node_modules/@azure/core-lro/dist-esm/src/logger.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = void 0;
var _logger = require("@azure/logger");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The `@azure/logger` configuration for this package.
 * @internal
 */
var logger = exports.logger = (0, _logger.createClientLogger)("core-lro");
},{"@azure/logger":"node_modules/@azure/logger/dist-esm/src/index.js"}],"node_modules/@azure/core-lro/dist-esm/src/poller/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.terminalStates = exports.POLL_INTERVAL_IN_MS = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The default time interval to wait before sending the next polling request.
 */
var POLL_INTERVAL_IN_MS = exports.POLL_INTERVAL_IN_MS = 2000;
/**
 * The closed set of terminal states.
 */
var terminalStates = exports.terminalStates = ["succeeded", "canceled", "failed"];
},{}],"node_modules/@azure/core-lro/dist-esm/src/poller/operation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deserializeState = deserializeState;
exports.initOperation = initOperation;
exports.pollOperation = pollOperation;
var _logger = require("../logger");
var _constants = require("./constants");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Deserializes the state
 */
function deserializeState(serializedState) {
  try {
    return JSON.parse(serializedState).state;
  } catch (e) {
    throw new Error("Unable to deserialize input state: ".concat(serializedState));
  }
}
function setStateError(inputs) {
  var state = inputs.state,
    stateProxy = inputs.stateProxy,
    isOperationError = inputs.isOperationError;
  return function (error) {
    if (isOperationError(error)) {
      stateProxy.setError(state, error);
      stateProxy.setFailed(state);
    }
    throw error;
  };
}
function appendReadableErrorMessage(currentMessage, innerMessage) {
  var message = currentMessage;
  if (message.slice(-1) !== ".") {
    message = message + ".";
  }
  return message + " " + innerMessage;
}
function simplifyError(err) {
  var message = err.message;
  var code = err.code;
  var curErr = err;
  while (curErr.innererror) {
    curErr = curErr.innererror;
    code = curErr.code;
    message = appendReadableErrorMessage(message, curErr.message);
  }
  return {
    code: code,
    message: message
  };
}
function processOperationStatus(result) {
  var state = result.state,
    stateProxy = result.stateProxy,
    status = result.status,
    isDone = result.isDone,
    processResult = result.processResult,
    getError = result.getError,
    response = result.response,
    setErrorAsResult = result.setErrorAsResult;
  switch (status) {
    case "succeeded":
      {
        stateProxy.setSucceeded(state);
        break;
      }
    case "failed":
      {
        var err = getError === null || getError === void 0 ? void 0 : getError(response);
        var postfix = "";
        if (err) {
          var _simplifyError = simplifyError(err),
            code = _simplifyError.code,
            message = _simplifyError.message;
          postfix = ". ".concat(code, ". ").concat(message);
        }
        var errStr = "The long-running operation has failed".concat(postfix);
        stateProxy.setError(state, new Error(errStr));
        stateProxy.setFailed(state);
        _logger.logger.warning(errStr);
        break;
      }
    case "canceled":
      {
        stateProxy.setCanceled(state);
        break;
      }
  }
  if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === undefined && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status)) {
    stateProxy.setResult(state, buildResult({
      response: response,
      state: state,
      processResult: processResult
    }));
  }
}
function buildResult(inputs) {
  var processResult = inputs.processResult,
    response = inputs.response,
    state = inputs.state;
  return processResult ? processResult(response, state) : response;
}
/**
 * Initiates the long-running operation.
 */
function initOperation(_x) {
  return _initOperation.apply(this, arguments);
}
function _initOperation() {
  _initOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(inputs) {
    var init, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult, _yield$init, operationLocation, resourceLocation, metadata, response, config, state, status;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          init = inputs.init, stateProxy = inputs.stateProxy, processResult = inputs.processResult, getOperationStatus = inputs.getOperationStatus, withOperationLocation = inputs.withOperationLocation, setErrorAsResult = inputs.setErrorAsResult;
          _context.next = 3;
          return init();
        case 3:
          _yield$init = _context.sent;
          operationLocation = _yield$init.operationLocation;
          resourceLocation = _yield$init.resourceLocation;
          metadata = _yield$init.metadata;
          response = _yield$init.response;
          if (operationLocation) withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
          config = {
            metadata: metadata,
            operationLocation: operationLocation,
            resourceLocation: resourceLocation
          };
          _logger.logger.verbose("LRO: Operation description:", config);
          state = stateProxy.initState(config);
          status = getOperationStatus({
            response: response,
            state: state,
            operationLocation: operationLocation
          });
          processOperationStatus({
            state: state,
            status: status,
            stateProxy: stateProxy,
            response: response,
            setErrorAsResult: setErrorAsResult,
            processResult: processResult
          });
          return _context.abrupt("return", state);
        case 15:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _initOperation.apply(this, arguments);
}
function pollOperationHelper(_x2) {
  return _pollOperationHelper.apply(this, arguments);
}
/** Polls the long-running operation. */
function _pollOperationHelper() {
  _pollOperationHelper = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(inputs) {
    var poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, isOperationError, options, response, status, resourceLocation;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          poll = inputs.poll, state = inputs.state, stateProxy = inputs.stateProxy, operationLocation = inputs.operationLocation, getOperationStatus = inputs.getOperationStatus, getResourceLocation = inputs.getResourceLocation, isOperationError = inputs.isOperationError, options = inputs.options;
          _context2.next = 3;
          return poll(operationLocation, options).catch(setStateError({
            state: state,
            stateProxy: stateProxy,
            isOperationError: isOperationError
          }));
        case 3:
          response = _context2.sent;
          status = getOperationStatus(response, state);
          _logger.logger.verbose("LRO: Status:\n\tPolling from: ".concat(state.config.operationLocation, "\n\tOperation status: ").concat(status, "\n\tPolling status: ").concat(_constants.terminalStates.includes(status) ? "Stopped" : "Running"));
          if (!(status === "succeeded")) {
            _context2.next = 14;
            break;
          }
          resourceLocation = getResourceLocation(response, state);
          if (!(resourceLocation !== undefined)) {
            _context2.next = 14;
            break;
          }
          _context2.next = 11;
          return poll(resourceLocation).catch(setStateError({
            state: state,
            stateProxy: stateProxy,
            isOperationError: isOperationError
          }));
        case 11:
          _context2.t0 = _context2.sent;
          _context2.t1 = status;
          return _context2.abrupt("return", {
            response: _context2.t0,
            status: _context2.t1
          });
        case 14:
          return _context2.abrupt("return", {
            response: response,
            status: status
          });
        case 15:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _pollOperationHelper.apply(this, arguments);
}
function pollOperation(_x3) {
  return _pollOperation.apply(this, arguments);
}
function _pollOperation() {
  _pollOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(inputs) {
    var poll, state, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, isOperationError, withOperationLocation, getPollingInterval, processResult, getError, updateState, setDelay, isDone, setErrorAsResult, operationLocation, _yield$pollOperationH, response, status, intervalInMs, location, isUpdated;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          poll = inputs.poll, state = inputs.state, stateProxy = inputs.stateProxy, options = inputs.options, getOperationStatus = inputs.getOperationStatus, getResourceLocation = inputs.getResourceLocation, getOperationLocation = inputs.getOperationLocation, isOperationError = inputs.isOperationError, withOperationLocation = inputs.withOperationLocation, getPollingInterval = inputs.getPollingInterval, processResult = inputs.processResult, getError = inputs.getError, updateState = inputs.updateState, setDelay = inputs.setDelay, isDone = inputs.isDone, setErrorAsResult = inputs.setErrorAsResult;
          operationLocation = state.config.operationLocation;
          if (!(operationLocation !== undefined)) {
            _context3.next = 11;
            break;
          }
          _context3.next = 5;
          return pollOperationHelper({
            poll: poll,
            getOperationStatus: getOperationStatus,
            state: state,
            stateProxy: stateProxy,
            operationLocation: operationLocation,
            getResourceLocation: getResourceLocation,
            isOperationError: isOperationError,
            options: options
          });
        case 5:
          _yield$pollOperationH = _context3.sent;
          response = _yield$pollOperationH.response;
          status = _yield$pollOperationH.status;
          processOperationStatus({
            status: status,
            response: response,
            state: state,
            stateProxy: stateProxy,
            isDone: isDone,
            processResult: processResult,
            getError: getError,
            setErrorAsResult: setErrorAsResult
          });
          if (!_constants.terminalStates.includes(status)) {
            intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);
            if (intervalInMs) setDelay(intervalInMs);
            location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);
            if (location !== undefined) {
              isUpdated = operationLocation !== location;
              state.config.operationLocation = location;
              withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);
            } else withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);
          }
          updateState === null || updateState === void 0 ? void 0 : updateState(state, response);
        case 11:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _pollOperation.apply(this, arguments);
}
},{"../logger":"node_modules/@azure/core-lro/dist-esm/src/logger.js","./constants":"node_modules/@azure/core-lro/dist-esm/src/poller/constants.js"}],"node_modules/@azure/core-lro/dist-esm/src/http/operation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getErrorFromResponse = getErrorFromResponse;
exports.getOperationLocation = getOperationLocation;
exports.getOperationStatus = getOperationStatus;
exports.getResourceLocation = getResourceLocation;
exports.getStatusFromInitialResponse = getStatusFromInitialResponse;
exports.inferLroMode = inferLroMode;
exports.initHttpOperation = initHttpOperation;
exports.isOperationError = isOperationError;
exports.parseRetryAfter = parseRetryAfter;
exports.pollHttpOperation = pollHttpOperation;
var _operation = require("../poller/operation");
var _logger = require("../logger");
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getOperationLocationPollingUrl(inputs) {
  var azureAsyncOperation = inputs.azureAsyncOperation,
    operationLocation = inputs.operationLocation;
  return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;
}
function getLocationHeader(rawResponse) {
  return rawResponse.headers["location"];
}
function getOperationLocationHeader(rawResponse) {
  return rawResponse.headers["operation-location"];
}
function getAzureAsyncOperationHeader(rawResponse) {
  return rawResponse.headers["azure-asyncoperation"];
}
function findResourceLocation(inputs) {
  var _a;
  var location = inputs.location,
    requestMethod = inputs.requestMethod,
    requestPath = inputs.requestPath,
    resourceLocationConfig = inputs.resourceLocationConfig;
  switch (requestMethod) {
    case "PUT":
      {
        return requestPath;
      }
    case "DELETE":
      {
        return undefined;
      }
    case "PATCH":
      {
        return (_a = getDefault()) !== null && _a !== void 0 ? _a : requestPath;
      }
    default:
      {
        return getDefault();
      }
  }
  function getDefault() {
    switch (resourceLocationConfig) {
      case "azure-async-operation":
        {
          return undefined;
        }
      case "original-uri":
        {
          return requestPath;
        }
      case "location":
      default:
        {
          return location;
        }
    }
  }
}
function inferLroMode(inputs) {
  var rawResponse = inputs.rawResponse,
    requestMethod = inputs.requestMethod,
    requestPath = inputs.requestPath,
    resourceLocationConfig = inputs.resourceLocationConfig;
  var operationLocation = getOperationLocationHeader(rawResponse);
  var azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);
  var pollingUrl = getOperationLocationPollingUrl({
    operationLocation: operationLocation,
    azureAsyncOperation: azureAsyncOperation
  });
  var location = getLocationHeader(rawResponse);
  var normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();
  if (pollingUrl !== undefined) {
    return {
      mode: "OperationLocation",
      operationLocation: pollingUrl,
      resourceLocation: findResourceLocation({
        requestMethod: normalizedRequestMethod,
        location: location,
        requestPath: requestPath,
        resourceLocationConfig: resourceLocationConfig
      })
    };
  } else if (location !== undefined) {
    return {
      mode: "ResourceLocation",
      operationLocation: location
    };
  } else if (normalizedRequestMethod === "PUT" && requestPath) {
    return {
      mode: "Body",
      operationLocation: requestPath
    };
  } else {
    return undefined;
  }
}
function transformStatus(inputs) {
  var status = inputs.status,
    statusCode = inputs.statusCode;
  if (typeof status !== "string" && status !== undefined) {
    throw new Error("Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ".concat(status, ". This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information."));
  }
  switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {
    case undefined:
      return toOperationStatus(statusCode);
    case "succeeded":
      return "succeeded";
    case "failed":
      return "failed";
    case "running":
    case "accepted":
    case "started":
    case "canceling":
    case "cancelling":
      return "running";
    case "canceled":
    case "cancelled":
      return "canceled";
    default:
      {
        _logger.logger.verbose("LRO: unrecognized operation status: ".concat(status));
        return status;
      }
  }
}
function getStatus(rawResponse) {
  var _a;
  var _ref = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {},
    status = _ref.status;
  return transformStatus({
    status: status,
    statusCode: rawResponse.statusCode
  });
}
function getProvisioningState(rawResponse) {
  var _a, _b;
  var _ref2 = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {},
    properties = _ref2.properties,
    provisioningState = _ref2.provisioningState;
  var status = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;
  return transformStatus({
    status: status,
    statusCode: rawResponse.statusCode
  });
}
function toOperationStatus(statusCode) {
  if (statusCode === 202) {
    return "running";
  } else if (statusCode < 300) {
    return "succeeded";
  } else {
    return "failed";
  }
}
function parseRetryAfter(_ref3) {
  var rawResponse = _ref3.rawResponse;
  var retryAfter = rawResponse.headers["retry-after"];
  if (retryAfter !== undefined) {
    // Retry-After header value is either in HTTP date format, or in seconds
    var retryAfterInSeconds = parseInt(retryAfter);
    return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;
  }
  return undefined;
}
function getErrorFromResponse(response) {
  var error = response.flatResponse.error;
  if (!error) {
    _logger.logger.warning("The long-running operation failed but there is no error property in the response's body");
    return;
  }
  if (!error.code || !error.message) {
    _logger.logger.warning("The long-running operation failed but the error property in the response's body doesn't contain code or message");
    return;
  }
  return error;
}
function calculatePollingIntervalFromDate(retryAfterDate) {
  var timeNow = Math.floor(new Date().getTime());
  var retryAfterTime = retryAfterDate.getTime();
  if (timeNow < retryAfterTime) {
    return retryAfterTime - timeNow;
  }
  return undefined;
}
function getStatusFromInitialResponse(inputs) {
  var response = inputs.response,
    state = inputs.state,
    operationLocation = inputs.operationLocation;
  function helper() {
    var _a;
    var mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
    switch (mode) {
      case undefined:
        return toOperationStatus(response.rawResponse.statusCode);
      case "Body":
        return getOperationStatus(response, state);
      default:
        return "running";
    }
  }
  var status = helper();
  return status === "running" && operationLocation === undefined ? "succeeded" : status;
}
/**
 * Initiates the long-running operation.
 */
function initHttpOperation(_x) {
  return _initHttpOperation.apply(this, arguments);
}
function _initHttpOperation() {
  _initHttpOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(inputs) {
    var stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          stateProxy = inputs.stateProxy, resourceLocationConfig = inputs.resourceLocationConfig, processResult = inputs.processResult, lro = inputs.lro, setErrorAsResult = inputs.setErrorAsResult;
          return _context2.abrupt("return", (0, _operation.initOperation)({
            init: function () {
              var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                var response, config;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return lro.sendInitialRequest();
                    case 2:
                      response = _context.sent;
                      config = inferLroMode({
                        rawResponse: response.rawResponse,
                        requestPath: lro.requestPath,
                        requestMethod: lro.requestMethod,
                        resourceLocationConfig: resourceLocationConfig
                      });
                      return _context.abrupt("return", Object.assign({
                        response: response,
                        operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation,
                        resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation
                      }, (config === null || config === void 0 ? void 0 : config.mode) ? {
                        metadata: {
                          mode: config.mode
                        }
                      } : {}));
                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
              function init() {
                return _init.apply(this, arguments);
              }
              return init;
            }(),
            stateProxy: stateProxy,
            processResult: processResult ? function (_ref7, state) {
              var flatResponse = _ref7.flatResponse;
              return processResult(flatResponse, state);
            } : function (_ref8) {
              var flatResponse = _ref8.flatResponse;
              return flatResponse;
            },
            getOperationStatus: getStatusFromInitialResponse,
            setErrorAsResult: setErrorAsResult
          }));
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _initHttpOperation.apply(this, arguments);
}
function getOperationLocation(_ref4, state) {
  var rawResponse = _ref4.rawResponse;
  var _a;
  var mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
  switch (mode) {
    case "OperationLocation":
      {
        return getOperationLocationPollingUrl({
          operationLocation: getOperationLocationHeader(rawResponse),
          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
        });
      }
    case "ResourceLocation":
      {
        return getLocationHeader(rawResponse);
      }
    case "Body":
    default:
      {
        return undefined;
      }
  }
}
function getOperationStatus(_ref5, state) {
  var rawResponse = _ref5.rawResponse;
  var _a;
  var mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a["mode"];
  switch (mode) {
    case "OperationLocation":
      {
        return getStatus(rawResponse);
      }
    case "ResourceLocation":
      {
        return toOperationStatus(rawResponse.statusCode);
      }
    case "Body":
      {
        return getProvisioningState(rawResponse);
      }
    default:
      throw new Error("Internal error: Unexpected operation mode: ".concat(mode));
  }
}
function getResourceLocation(_ref6, state) {
  var flatResponse = _ref6.flatResponse;
  if (_typeof(flatResponse) === "object") {
    var resourceLocation = flatResponse.resourceLocation;
    if (resourceLocation !== undefined) {
      state.config.resourceLocation = resourceLocation;
    }
  }
  return state.config.resourceLocation;
}
function isOperationError(e) {
  return e.name === "RestError";
}
/** Polls the long-running operation. */
function pollHttpOperation(_x2) {
  return _pollHttpOperation.apply(this, arguments);
}
function _pollHttpOperation() {
  _pollHttpOperation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(inputs) {
    var lro, stateProxy, options, processResult, updateState, setDelay, state, setErrorAsResult;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          lro = inputs.lro, stateProxy = inputs.stateProxy, options = inputs.options, processResult = inputs.processResult, updateState = inputs.updateState, setDelay = inputs.setDelay, state = inputs.state, setErrorAsResult = inputs.setErrorAsResult;
          return _context4.abrupt("return", (0, _operation.pollOperation)({
            state: state,
            stateProxy: stateProxy,
            setDelay: setDelay,
            processResult: processResult ? function (_ref9, inputState) {
              var flatResponse = _ref9.flatResponse;
              return processResult(flatResponse, inputState);
            } : function (_ref10) {
              var flatResponse = _ref10.flatResponse;
              return flatResponse;
            },
            getError: getErrorFromResponse,
            updateState: updateState,
            getPollingInterval: parseRetryAfter,
            getOperationLocation: getOperationLocation,
            getOperationStatus: getOperationStatus,
            isOperationError: isOperationError,
            getResourceLocation: getResourceLocation,
            options: options,
            /**
             * The expansion here is intentional because `lro` could be an object that
             * references an inner this, so we need to preserve a reference to it.
             */
            poll: function () {
              var _poll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(location, inputOptions) {
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      return _context3.abrupt("return", lro.sendPollRequest(location, inputOptions));
                    case 1:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }));
              function poll(_x3, _x4) {
                return _poll.apply(this, arguments);
              }
              return poll;
            }(),
            setErrorAsResult: setErrorAsResult
          }));
        case 2:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _pollHttpOperation.apply(this, arguments);
}
},{"../poller/operation":"node_modules/@azure/core-lro/dist-esm/src/poller/operation.js","../logger":"node_modules/@azure/core-lro/dist-esm/src/logger.js"}],"node_modules/@azure/core-lro/dist-esm/src/poller/poller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildCreatePoller = buildCreatePoller;
var _abortController = require("@azure/abort-controller");
var _operation = require("./operation");
var _constants = require("./constants");
var _coreUtil = require("@azure/core-util");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var createStateProxy = function createStateProxy() {
  return {
    /**
     * The state at this point is created to be of type OperationState<TResult>.
     * It will be updated later to be of type TState when the
     * customer-provided callback, `updateState`, is called during polling.
     */
    initState: function initState(config) {
      return {
        status: "running",
        config: config
      };
    },
    setCanceled: function setCanceled(state) {
      return state.status = "canceled";
    },
    setError: function setError(state, error) {
      return state.error = error;
    },
    setResult: function setResult(state, result) {
      return state.result = result;
    },
    setRunning: function setRunning(state) {
      return state.status = "running";
    },
    setSucceeded: function setSucceeded(state) {
      return state.status = "succeeded";
    },
    setFailed: function setFailed(state) {
      return state.status = "failed";
    },
    getError: function getError(state) {
      return state.error;
    },
    getResult: function getResult(state) {
      return state.result;
    },
    isCanceled: function isCanceled(state) {
      return state.status === "canceled";
    },
    isFailed: function isFailed(state) {
      return state.status === "failed";
    },
    isRunning: function isRunning(state) {
      return state.status === "running";
    },
    isSucceeded: function isSucceeded(state) {
      return state.status === "succeeded";
    }
  };
};
/**
 * Returns a poller factory.
 */
function buildCreatePoller(inputs) {
  var getOperationLocation = inputs.getOperationLocation,
    getStatusFromInitialResponse = inputs.getStatusFromInitialResponse,
    getStatusFromPollResponse = inputs.getStatusFromPollResponse,
    isOperationError = inputs.isOperationError,
    getResourceLocation = inputs.getResourceLocation,
    getPollingInterval = inputs.getPollingInterval,
    getError = inputs.getError,
    resolveOnUnsuccessful = inputs.resolveOnUnsuccessful;
  return /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref, options) {
      var init, _poll, _ref3, processResult, updateState, withOperationLocationCallback, _ref3$intervalInMs, intervalInMs, restoreFrom, stateProxy, withOperationLocation, state, resultPromise, abortController, handlers, handleProgressEvents, cancelErrMsg, currentPollIntervalInMs, poller;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            init = _ref.init, _poll = _ref.poll;
            _ref3 = options || {}, processResult = _ref3.processResult, updateState = _ref3.updateState, withOperationLocationCallback = _ref3.withOperationLocation, _ref3$intervalInMs = _ref3.intervalInMs, intervalInMs = _ref3$intervalInMs === void 0 ? _constants.POLL_INTERVAL_IN_MS : _ref3$intervalInMs, restoreFrom = _ref3.restoreFrom;
            stateProxy = createStateProxy();
            withOperationLocation = withOperationLocationCallback ? function () {
              var called = false;
              return function (operationLocation, isUpdated) {
                if (isUpdated) withOperationLocationCallback(operationLocation);else if (!called) withOperationLocationCallback(operationLocation);
                called = true;
              };
            }() : undefined;
            if (!restoreFrom) {
              _context4.next = 8;
              break;
            }
            _context4.t0 = (0, _operation.deserializeState)(restoreFrom);
            _context4.next = 11;
            break;
          case 8:
            _context4.next = 10;
            return (0, _operation.initOperation)({
              init: init,
              stateProxy: stateProxy,
              processResult: processResult,
              getOperationStatus: getStatusFromInitialResponse,
              withOperationLocation: withOperationLocation,
              setErrorAsResult: !resolveOnUnsuccessful
            });
          case 10:
            _context4.t0 = _context4.sent;
          case 11:
            state = _context4.t0;
            abortController = new _abortController.AbortController();
            handlers = new Map();
            handleProgressEvents = /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      return _context.abrupt("return", handlers.forEach(function (h) {
                        return h(state);
                      }));
                    case 1:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
              return function handleProgressEvents() {
                return _ref4.apply(this, arguments);
              };
            }();
            cancelErrMsg = "Operation was canceled";
            currentPollIntervalInMs = intervalInMs;
            poller = {
              getOperationState: function getOperationState() {
                return state;
              },
              getResult: function getResult() {
                return state.result;
              },
              isDone: function isDone() {
                return ["succeeded", "failed", "canceled"].includes(state.status);
              },
              isStopped: function isStopped() {
                return resultPromise === undefined;
              },
              stopPolling: function stopPolling() {
                abortController.abort();
              },
              toString: function toString() {
                return JSON.stringify({
                  state: state
                });
              },
              onProgress: function onProgress(callback) {
                var s = Symbol();
                handlers.set(s, callback);
                return function () {
                  return handlers.delete(s);
                };
              },
              pollUntilDone: function pollUntilDone(pollOptions) {
                return resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                  var _ref6, inputAbortSignal, _ref7, abortSignal;
                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        _ref6 = pollOptions || {}, inputAbortSignal = _ref6.abortSignal;
                        _ref7 = inputAbortSignal ? new _abortController.AbortController([inputAbortSignal, abortController.signal]) : abortController, abortSignal = _ref7.signal;
                        if (poller.isDone()) {
                          _context2.next = 12;
                          break;
                        }
                        _context2.next = 5;
                        return poller.poll({
                          abortSignal: abortSignal
                        });
                      case 5:
                        if (poller.isDone()) {
                          _context2.next = 12;
                          break;
                        }
                        _context2.next = 8;
                        return (0, _coreUtil.delay)(currentPollIntervalInMs, {
                          abortSignal: abortSignal
                        });
                      case 8:
                        _context2.next = 10;
                        return poller.poll({
                          abortSignal: abortSignal
                        });
                      case 10:
                        _context2.next = 5;
                        break;
                      case 12:
                        if (!resolveOnUnsuccessful) {
                          _context2.next = 16;
                          break;
                        }
                        return _context2.abrupt("return", poller.getResult());
                      case 16:
                        _context2.t0 = state.status;
                        _context2.next = _context2.t0 === "succeeded" ? 19 : _context2.t0 === "canceled" ? 20 : _context2.t0 === "failed" ? 21 : _context2.t0 === "notStarted" ? 22 : _context2.t0 === "running" ? 22 : 23;
                        break;
                      case 19:
                        return _context2.abrupt("return", poller.getResult());
                      case 20:
                        throw new Error(cancelErrMsg);
                      case 21:
                        throw state.error;
                      case 22:
                        throw new Error("Polling completed without succeeding or failing");
                      case 23:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2);
                }))().finally(function () {
                  resultPromise = undefined;
                });
              },
              poll: function poll(pollOptions) {
                return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        if (!resolveOnUnsuccessful) {
                          _context3.next = 5;
                          break;
                        }
                        if (!poller.isDone()) {
                          _context3.next = 3;
                          break;
                        }
                        return _context3.abrupt("return");
                      case 3:
                        _context3.next = 11;
                        break;
                      case 5:
                        _context3.t0 = state.status;
                        _context3.next = _context3.t0 === "succeeded" ? 8 : _context3.t0 === "canceled" ? 9 : _context3.t0 === "failed" ? 10 : 11;
                        break;
                      case 8:
                        return _context3.abrupt("return");
                      case 9:
                        throw new Error(cancelErrMsg);
                      case 10:
                        throw state.error;
                      case 11:
                        _context3.next = 13;
                        return (0, _operation.pollOperation)({
                          poll: _poll,
                          state: state,
                          stateProxy: stateProxy,
                          getOperationLocation: getOperationLocation,
                          isOperationError: isOperationError,
                          withOperationLocation: withOperationLocation,
                          getPollingInterval: getPollingInterval,
                          getOperationStatus: getStatusFromPollResponse,
                          getResourceLocation: getResourceLocation,
                          processResult: processResult,
                          getError: getError,
                          updateState: updateState,
                          options: pollOptions,
                          setDelay: function setDelay(pollIntervalInMs) {
                            currentPollIntervalInMs = pollIntervalInMs;
                          },
                          setErrorAsResult: !resolveOnUnsuccessful
                        });
                      case 13:
                        _context3.next = 15;
                        return handleProgressEvents();
                      case 15:
                        if (resolveOnUnsuccessful) {
                          _context3.next = 21;
                          break;
                        }
                        _context3.t1 = state.status;
                        _context3.next = _context3.t1 === "canceled" ? 19 : _context3.t1 === "failed" ? 20 : 21;
                        break;
                      case 19:
                        throw new Error(cancelErrMsg);
                      case 20:
                        throw state.error;
                      case 21:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3);
                }))();
              }
            };
            return _context4.abrupt("return", poller);
          case 19:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function (_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }();
}
},{"@azure/abort-controller":"node_modules/@azure/abort-controller/dist-esm/src/index.js","./operation":"node_modules/@azure/core-lro/dist-esm/src/poller/operation.js","./constants":"node_modules/@azure/core-lro/dist-esm/src/poller/constants.js","@azure/core-util":"node_modules/@azure/core-util/dist-esm/src/index.js"}],"node_modules/@azure/core-lro/dist-esm/src/http/poller.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHttpPoller = createHttpPoller;
var _operation = require("./operation");
var _poller = require("../poller/poller");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Creates a poller that can be used to poll a long-running operation.
 * @param lro - Description of the long-running operation
 * @param options - options to configure the poller
 * @returns an initialized poller
 */
function createHttpPoller(_x, _x2) {
  return _createHttpPoller.apply(this, arguments);
}
function _createHttpPoller() {
  _createHttpPoller = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(lro, options) {
    var _ref, resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, _ref$resolveOnUnsucce, resolveOnUnsuccessful;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _ref = options || {}, resourceLocationConfig = _ref.resourceLocationConfig, intervalInMs = _ref.intervalInMs, processResult = _ref.processResult, restoreFrom = _ref.restoreFrom, updateState = _ref.updateState, withOperationLocation = _ref.withOperationLocation, _ref$resolveOnUnsucce = _ref.resolveOnUnsuccessful, resolveOnUnsuccessful = _ref$resolveOnUnsucce === void 0 ? false : _ref$resolveOnUnsucce;
          return _context2.abrupt("return", (0, _poller.buildCreatePoller)({
            getStatusFromInitialResponse: _operation.getStatusFromInitialResponse,
            getStatusFromPollResponse: _operation.getOperationStatus,
            isOperationError: _operation.isOperationError,
            getOperationLocation: _operation.getOperationLocation,
            getResourceLocation: _operation.getResourceLocation,
            getPollingInterval: _operation.parseRetryAfter,
            getError: _operation.getErrorFromResponse,
            resolveOnUnsuccessful: resolveOnUnsuccessful
          })({
            init: function () {
              var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                var response, config;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return lro.sendInitialRequest();
                    case 2:
                      response = _context.sent;
                      config = (0, _operation.inferLroMode)({
                        rawResponse: response.rawResponse,
                        requestPath: lro.requestPath,
                        requestMethod: lro.requestMethod,
                        resourceLocationConfig: resourceLocationConfig
                      });
                      return _context.abrupt("return", Object.assign({
                        response: response,
                        operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation,
                        resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation
                      }, (config === null || config === void 0 ? void 0 : config.mode) ? {
                        metadata: {
                          mode: config.mode
                        }
                      } : {}));
                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
              function init() {
                return _init.apply(this, arguments);
              }
              return init;
            }(),
            poll: lro.sendPollRequest
          }, {
            intervalInMs: intervalInMs,
            withOperationLocation: withOperationLocation,
            restoreFrom: restoreFrom,
            updateState: updateState,
            processResult: processResult ? function (_ref2, state) {
              var flatResponse = _ref2.flatResponse;
              return processResult(flatResponse, state);
            } : function (_ref3) {
              var flatResponse = _ref3.flatResponse;
              return flatResponse;
            }
          }));
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _createHttpPoller.apply(this, arguments);
}
},{"./operation":"node_modules/@azure/core-lro/dist-esm/src/http/operation.js","../poller/poller":"node_modules/@azure/core-lro/dist-esm/src/poller/poller.js"}],"node_modules/@azure/core-lro/dist-esm/src/legacy/lroEngine/operation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenericPollOperation = void 0;
var _operation = require("../../http/operation");
var _logger = require("../../logger");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var createStateProxy = function createStateProxy() {
  return {
    initState: function initState(config) {
      return {
        config: config,
        isStarted: true
      };
    },
    setCanceled: function setCanceled(state) {
      return state.isCancelled = true;
    },
    setError: function setError(state, error) {
      return state.error = error;
    },
    setResult: function setResult(state, result) {
      return state.result = result;
    },
    setRunning: function setRunning(state) {
      return state.isStarted = true;
    },
    setSucceeded: function setSucceeded(state) {
      return state.isCompleted = true;
    },
    setFailed: function setFailed() {
      /** empty body */
    },
    getError: function getError(state) {
      return state.error;
    },
    getResult: function getResult(state) {
      return state.result;
    },
    isCanceled: function isCanceled(state) {
      return !!state.isCancelled;
    },
    isFailed: function isFailed(state) {
      return !!state.error;
    },
    isRunning: function isRunning(state) {
      return !!state.isStarted;
    },
    isSucceeded: function isSucceeded(state) {
      return Boolean(state.isCompleted && !state.isCancelled && !state.error);
    }
  };
};
var GenericPollOperation = exports.GenericPollOperation = /*#__PURE__*/function () {
  function GenericPollOperation(state, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {
    _classCallCheck(this, GenericPollOperation);
    this.state = state;
    this.lro = lro;
    this.setErrorAsResult = setErrorAsResult;
    this.lroResourceLocationConfig = lroResourceLocationConfig;
    this.processResult = processResult;
    this.updateState = updateState;
    this.isDone = isDone;
  }
  _createClass(GenericPollOperation, [{
    key: "setPollerConfig",
    value: function setPollerConfig(pollerConfig) {
      this.pollerConfig = pollerConfig;
    }
  }, {
    key: "update",
    value: function () {
      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
        var _this = this;
        var _a, stateProxy, updateState, isDone;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              stateProxy = createStateProxy();
              if (this.state.isStarted) {
                _context.next = 8;
                break;
              }
              _context.t0 = Object;
              _context.t1 = Object.assign({}, this.state);
              _context.next = 6;
              return (0, _operation.initHttpOperation)({
                lro: this.lro,
                stateProxy: stateProxy,
                resourceLocationConfig: this.lroResourceLocationConfig,
                processResult: this.processResult,
                setErrorAsResult: this.setErrorAsResult
              });
            case 6:
              _context.t2 = _context.sent;
              this.state = _context.t0.assign.call(_context.t0, _context.t1, _context.t2);
            case 8:
              updateState = this.updateState;
              isDone = this.isDone;
              if (!(!this.state.isCompleted && this.state.error === undefined)) {
                _context.next = 13;
                break;
              }
              _context.next = 13;
              return (0, _operation.pollHttpOperation)({
                lro: this.lro,
                state: this.state,
                stateProxy: stateProxy,
                processResult: this.processResult,
                updateState: updateState ? function (state, _ref) {
                  var rawResponse = _ref.rawResponse;
                  return updateState(state, rawResponse);
                } : undefined,
                isDone: isDone ? function (_ref2, state) {
                  var flatResponse = _ref2.flatResponse;
                  return isDone(flatResponse, state);
                } : undefined,
                options: options,
                setDelay: function setDelay(intervalInMs) {
                  _this.pollerConfig.intervalInMs = intervalInMs;
                },
                setErrorAsResult: this.setErrorAsResult
              });
            case 13:
              (_a = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _a === void 0 ? void 0 : _a.call(options, this.state);
              return _context.abrupt("return", this);
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function update(_x) {
        return _update.apply(this, arguments);
      }
      return update;
    }()
  }, {
    key: "cancel",
    value: function () {
      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _logger.logger.error("`cancelOperation` is deprecated because it wasn't implemented");
              return _context2.abrupt("return", this);
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function cancel() {
        return _cancel.apply(this, arguments);
      }
      return cancel;
    }()
    /**
     * Serializes the Poller operation.
     */
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify({
        state: this.state
      });
    }
  }]);
  return GenericPollOperation;
}();
},{"../../http/operation":"node_modules/@azure/core-lro/dist-esm/src/http/operation.js","../../logger":"node_modules/@azure/core-lro/dist-esm/src/logger.js"}],"node_modules/@azure/core-lro/dist-esm/src/legacy/poller.js":[function(require,module,exports) {
var define;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PollerStoppedError = exports.PollerCancelledError = exports.Poller = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * When a poller is manually stopped through the `stopPolling` method,
 * the poller will be rejected with an instance of the PollerStoppedError.
 */
var PollerStoppedError = exports.PollerStoppedError = /*#__PURE__*/function (_Error) {
  _inherits(PollerStoppedError, _Error);
  var _super = _createSuper(PollerStoppedError);
  function PollerStoppedError(message) {
    var _this;
    _classCallCheck(this, PollerStoppedError);
    _this = _super.call(this, message);
    _this.name = "PollerStoppedError";
    Object.setPrototypeOf(_assertThisInitialized(_this), PollerStoppedError.prototype);
    return _this;
  }
  return _createClass(PollerStoppedError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * When the operation is cancelled, the poller will be rejected with an instance
 * of the PollerCancelledError.
 */
var PollerCancelledError = exports.PollerCancelledError = /*#__PURE__*/function (_Error2) {
  _inherits(PollerCancelledError, _Error2);
  var _super2 = _createSuper(PollerCancelledError);
  function PollerCancelledError(message) {
    var _this2;
    _classCallCheck(this, PollerCancelledError);
    _this2 = _super2.call(this, message);
    _this2.name = "PollerCancelledError";
    Object.setPrototypeOf(_assertThisInitialized(_this2), PollerCancelledError.prototype);
    return _this2;
  }
  return _createClass(PollerCancelledError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * A class that represents the definition of a program that polls through consecutive requests
 * until it reaches a state of completion.
 *
 * A poller can be executed manually, by polling request by request by calling to the `poll()` method repeatedly, until its operation is completed.
 * It also provides a way to wait until the operation completes, by calling `pollUntilDone()` and waiting until the operation finishes.
 * Pollers can also request the cancellation of the ongoing process to whom is providing the underlying long running operation.
 *
 * ```ts
 * const poller = new MyPoller();
 *
 * // Polling just once:
 * await poller.poll();
 *
 * // We can try to cancel the request here, by calling:
 * //
 * //     await poller.cancelOperation();
 * //
 *
 * // Getting the final result:
 * const result = await poller.pollUntilDone();
 * ```
 *
 * The Poller is defined by two types, a type representing the state of the poller, which
 * must include a basic set of properties from `PollOperationState<TResult>`,
 * and a return type defined by `TResult`, which can be anything.
 *
 * The Poller class implements the `PollerLike` interface, which allows poller implementations to avoid having
 * to export the Poller's class directly, and instead only export the already instantiated poller with the PollerLike type.
 *
 * ```ts
 * class Client {
 *   public async makePoller: PollerLike<MyOperationState, MyResult> {
 *     const poller = new MyPoller({});
 *     // It might be preferred to return the poller after the first request is made,
 *     // so that some information can be obtained right away.
 *     await poller.poll();
 *     return poller;
 *   }
 * }
 *
 * const poller: PollerLike<MyOperationState, MyResult> = myClient.makePoller();
 * ```
 *
 * A poller can be created through its constructor, then it can be polled until it's completed.
 * At any point in time, the state of the poller can be obtained without delay through the getOperationState method.
 * At any point in time, the intermediate forms of the result type can be requested without delay.
 * Once the underlying operation is marked as completed, the poller will stop and the final value will be returned.
 *
 * ```ts
 * const poller = myClient.makePoller();
 * const state: MyOperationState = poller.getOperationState();
 *
 * // The intermediate result can be obtained at any time.
 * const result: MyResult | undefined = poller.getResult();
 *
 * // The final result can only be obtained after the poller finishes.
 * const result: MyResult = await poller.pollUntilDone();
 * ```
 *
 */
// eslint-disable-next-line no-use-before-define
var Poller = exports.Poller = /*#__PURE__*/function () {
  /**
   * A poller needs to be initialized by passing in at least the basic properties of the `PollOperation<TState, TResult>`.
   *
   * When writing an implementation of a Poller, this implementation needs to deal with the initialization
   * of any custom state beyond the basic definition of the poller. The basic poller assumes that the poller's
   * operation has already been defined, at least its basic properties. The code below shows how to approach
   * the definition of the constructor of a new custom poller.
   *
   * ```ts
   * export class MyPoller extends Poller<MyOperationState, string> {
   *   constructor({
   *     // Anything you might need outside of the basics
   *   }) {
   *     let state: MyOperationState = {
   *       privateProperty: private,
   *       publicProperty: public,
   *     };
   *
   *     const operation = {
   *       state,
   *       update,
   *       cancel,
   *       toString
   *     }
   *
   *     // Sending the operation to the parent's constructor.
   *     super(operation);
   *
   *     // You can assign more local properties here.
   *   }
   * }
   * ```
   *
   * Inside of this constructor, a new promise is created. This will be used to
   * tell the user when the poller finishes (see `pollUntilDone()`). The promise's
   * resolve and reject methods are also used internally to control when to resolve
   * or reject anyone waiting for the poller to finish.
   *
   * The constructor of a custom implementation of a poller is where any serialized version of
   * a previous poller's operation should be deserialized into the operation sent to the
   * base constructor. For example:
   *
   * ```ts
   * export class MyPoller extends Poller<MyOperationState, string> {
   *   constructor(
   *     baseOperation: string | undefined
   *   ) {
   *     let state: MyOperationState = {};
   *     if (baseOperation) {
   *       state = {
   *         ...JSON.parse(baseOperation).state,
   *         ...state
   *       };
   *     }
   *     const operation = {
   *       state,
   *       // ...
   *     }
   *     super(operation);
   *   }
   * }
   * ```
   *
   * @param operation - Must contain the basic properties of `PollOperation<State, TResult>`.
   */
  function Poller(operation) {
    var _this3 = this;
    _classCallCheck(this, Poller);
    /** controls whether to throw an error if the operation failed or was canceled. */
    this.resolveOnUnsuccessful = false;
    this.stopped = true;
    this.pollProgressCallbacks = [];
    this.operation = operation;
    this.promise = new Promise(function (resolve, reject) {
      _this3.resolve = resolve;
      _this3.reject = reject;
    });
    // This prevents the UnhandledPromiseRejectionWarning in node.js from being thrown.
    // The above warning would get thrown if `poller.poll` is called, it returns an error,
    // and pullUntilDone did not have a .catch or await try/catch on it's return value.
    this.promise.catch(function () {
      /* intentionally blank */
    });
  }
  /**
   * Starts a loop that will break only if the poller is done
   * or if the poller is stopped.
   */
  _createClass(Poller, [{
    key: "startPolling",
    value: (function () {
      var _startPolling = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var pollOptions,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              pollOptions = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              if (this.stopped) {
                this.stopped = false;
              }
            case 2:
              if (!(!this.isStopped() && !this.isDone())) {
                _context.next = 9;
                break;
              }
              _context.next = 5;
              return this.poll(pollOptions);
            case 5:
              _context.next = 7;
              return this.delay();
            case 7:
              _context.next = 2;
              break;
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function startPolling() {
        return _startPolling.apply(this, arguments);
      }
      return startPolling;
    }()
    /**
     * pollOnce does one polling, by calling to the update method of the underlying
     * poll operation to make any relevant change effective.
     *
     * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
     *
     * @param options - Optional properties passed to the operation's update method.
     */
    )
  }, {
    key: "pollOnce",
    value: (function () {
      var _pollOnce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var options,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
              if (this.isDone()) {
                _context2.next = 5;
                break;
              }
              _context2.next = 4;
              return this.operation.update({
                abortSignal: options.abortSignal,
                fireProgress: this.fireProgress.bind(this)
              });
            case 4:
              this.operation = _context2.sent;
            case 5:
              this.processUpdatedState();
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function pollOnce() {
        return _pollOnce.apply(this, arguments);
      }
      return pollOnce;
    }()
    /**
     * fireProgress calls the functions passed in via onProgress the method of the poller.
     *
     * It loops over all of the callbacks received from onProgress, and executes them, sending them
     * the current operation state.
     *
     * @param state - The current operation state.
     */
    )
  }, {
    key: "fireProgress",
    value: function fireProgress(state) {
      var _iterator = _createForOfIteratorHelper(this.pollProgressCallbacks),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var callback = _step.value;
          callback(state);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Invokes the underlying operation's cancel method.
     */
  }, {
    key: "cancelOnce",
    value: (function () {
      var _cancelOnce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var options,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
              _context3.next = 3;
              return this.operation.cancel(options);
            case 3:
              this.operation = _context3.sent;
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function cancelOnce() {
        return _cancelOnce.apply(this, arguments);
      }
      return cancelOnce;
    }()
    /**
     * Returns a promise that will resolve once a single polling request finishes.
     * It does this by calling the update method of the Poller's operation.
     *
     * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
     *
     * @param options - Optional properties passed to the operation's update method.
     */
    )
  }, {
    key: "poll",
    value: function poll() {
      var _this4 = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!this.pollOncePromise) {
        this.pollOncePromise = this.pollOnce(options);
        var clearPollOncePromise = function clearPollOncePromise() {
          _this4.pollOncePromise = undefined;
        };
        this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
      }
      return this.pollOncePromise;
    }
  }, {
    key: "processUpdatedState",
    value: function processUpdatedState() {
      if (this.operation.state.error) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          this.reject(this.operation.state.error);
          throw this.operation.state.error;
        }
      }
      if (this.operation.state.isCancelled) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          var error = new PollerCancelledError("Operation was canceled");
          this.reject(error);
          throw error;
        }
      }
      if (this.isDone() && this.resolve) {
        // If the poller has finished polling, this means we now have a result.
        // However, it can be the case that TResult is instantiated to void, so
        // we are not expecting a result anyway. To assert that we might not
        // have a result eventually after finishing polling, we cast the result
        // to TResult.
        this.resolve(this.getResult());
      }
    }
    /**
     * Returns a promise that will resolve once the underlying operation is completed.
     */
  }, {
    key: "pollUntilDone",
    value: (function () {
      var _pollUntilDone = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var pollOptions,
          _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              pollOptions = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
              if (this.stopped) {
                this.startPolling(pollOptions).catch(this.reject);
              }
              // This is needed because the state could have been updated by
              // `cancelOperation`, e.g. the operation is canceled or an error occurred.
              this.processUpdatedState();
              return _context4.abrupt("return", this.promise);
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function pollUntilDone() {
        return _pollUntilDone.apply(this, arguments);
      }
      return pollUntilDone;
    }()
    /**
     * Invokes the provided callback after each polling is completed,
     * sending the current state of the poller's operation.
     *
     * It returns a method that can be used to stop receiving updates on the given callback function.
     */
    )
  }, {
    key: "onProgress",
    value: function onProgress(callback) {
      var _this5 = this;
      this.pollProgressCallbacks.push(callback);
      return function () {
        _this5.pollProgressCallbacks = _this5.pollProgressCallbacks.filter(function (c) {
          return c !== callback;
        });
      };
    }
    /**
     * Returns true if the poller has finished polling.
     */
  }, {
    key: "isDone",
    value: function isDone() {
      var state = this.operation.state;
      return Boolean(state.isCompleted || state.isCancelled || state.error);
    }
    /**
     * Stops the poller from continuing to poll.
     */
  }, {
    key: "stopPolling",
    value: function stopPolling() {
      if (!this.stopped) {
        this.stopped = true;
        if (this.reject) {
          this.reject(new PollerStoppedError("This poller is already stopped"));
        }
      }
    }
    /**
     * Returns true if the poller is stopped.
     */
  }, {
    key: "isStopped",
    value: function isStopped() {
      return this.stopped;
    }
    /**
     * Attempts to cancel the underlying operation.
     *
     * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
     *
     * If it's called again before it finishes, it will throw an error.
     *
     * @param options - Optional properties passed to the operation's update method.
     */
  }, {
    key: "cancelOperation",
    value: function cancelOperation() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!this.cancelPromise) {
        this.cancelPromise = this.cancelOnce(options);
      } else if (options.abortSignal) {
        throw new Error("A cancel request is currently pending");
      }
      return this.cancelPromise;
    }
    /**
     * Returns the state of the operation.
     *
     * Even though TState will be the same type inside any of the methods of any extension of the Poller class,
     * implementations of the pollers can customize what's shared with the public by writing their own
     * version of the `getOperationState` method, and by defining two types, one representing the internal state of the poller
     * and a public type representing a safe to share subset of the properties of the internal state.
     * Their definition of getOperationState can then return their public type.
     *
     * Example:
     *
     * ```ts
     * // Let's say we have our poller's operation state defined as:
     * interface MyOperationState extends PollOperationState<ResultType> {
     *   privateProperty?: string;
     *   publicProperty?: string;
     * }
     *
     * // To allow us to have a true separation of public and private state, we have to define another interface:
     * interface PublicState extends PollOperationState<ResultType> {
     *   publicProperty?: string;
     * }
     *
     * // Then, we define our Poller as follows:
     * export class MyPoller extends Poller<MyOperationState, ResultType> {
     *   // ... More content is needed here ...
     *
     *   public getOperationState(): PublicState {
     *     const state: PublicState = this.operation.state;
     *     return {
     *       // Properties from PollOperationState<TResult>
     *       isStarted: state.isStarted,
     *       isCompleted: state.isCompleted,
     *       isCancelled: state.isCancelled,
     *       error: state.error,
     *       result: state.result,
     *
     *       // The only other property needed by PublicState.
     *       publicProperty: state.publicProperty
     *     }
     *   }
     * }
     * ```
     *
     * You can see this in the tests of this repository, go to the file:
     * `../test/utils/testPoller.ts`
     * and look for the getOperationState implementation.
     */
  }, {
    key: "getOperationState",
    value: function getOperationState() {
      return this.operation.state;
    }
    /**
     * Returns the result value of the operation,
     * regardless of the state of the poller.
     * It can return undefined or an incomplete form of the final TResult value
     * depending on the implementation.
     */
  }, {
    key: "getResult",
    value: function getResult() {
      var state = this.operation.state;
      return state.result;
    }
    /**
     * Returns a serialized version of the poller's operation
     * by invoking the operation's toString method.
     */
  }, {
    key: "toString",
    value: function toString() {
      return this.operation.toString();
    }
  }]);
  return Poller;
}();
},{}],"node_modules/@azure/core-lro/dist-esm/src/legacy/lroEngine/lroEngine.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LroEngine = void 0;
var _operation = require("./operation");
var _constants = require("../../poller/constants");
var _poller = require("../poller");
var _operation2 = require("../../poller/operation");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The LRO Engine, a class that performs polling.
 */
var LroEngine = exports.LroEngine = /*#__PURE__*/function (_Poller) {
  _inherits(LroEngine, _Poller);
  var _super = _createSuper(LroEngine);
  function LroEngine(lro, options) {
    var _this;
    _classCallCheck(this, LroEngine);
    var _ref = options || {},
      _ref$intervalInMs = _ref.intervalInMs,
      intervalInMs = _ref$intervalInMs === void 0 ? _constants.POLL_INTERVAL_IN_MS : _ref$intervalInMs,
      resumeFrom = _ref.resumeFrom,
      _ref$resolveOnUnsucce = _ref.resolveOnUnsuccessful,
      resolveOnUnsuccessful = _ref$resolveOnUnsucce === void 0 ? false : _ref$resolveOnUnsucce,
      isDone = _ref.isDone,
      lroResourceLocationConfig = _ref.lroResourceLocationConfig,
      processResult = _ref.processResult,
      updateState = _ref.updateState;
    var state = resumeFrom ? (0, _operation2.deserializeState)(resumeFrom) : {};
    var operation = new _operation.GenericPollOperation(state, lro, !resolveOnUnsuccessful, lroResourceLocationConfig, processResult, updateState, isDone);
    _this = _super.call(this, operation);
    _this.resolveOnUnsuccessful = resolveOnUnsuccessful;
    _this.config = {
      intervalInMs: intervalInMs
    };
    operation.setPollerConfig(_this.config);
    return _this;
  }
  /**
   * The method used by the poller to wait before attempting to update its operation.
   */
  _createClass(LroEngine, [{
    key: "delay",
    value: function delay() {
      var _this2 = this;
      return new Promise(function (resolve) {
        return setTimeout(function () {
          return resolve();
        }, _this2.config.intervalInMs);
      });
    }
  }]);
  return LroEngine;
}(_poller.Poller);
},{"./operation":"node_modules/@azure/core-lro/dist-esm/src/legacy/lroEngine/operation.js","../../poller/constants":"node_modules/@azure/core-lro/dist-esm/src/poller/constants.js","../poller":"node_modules/@azure/core-lro/dist-esm/src/legacy/poller.js","../../poller/operation":"node_modules/@azure/core-lro/dist-esm/src/poller/operation.js"}],"node_modules/@azure/core-lro/dist-esm/src/legacy/lroEngine/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "LroEngine", {
  enumerable: true,
  get: function () {
    return _lroEngine.LroEngine;
  }
});
var _lroEngine = require("./lroEngine");
},{"./lroEngine":"node_modules/@azure/core-lro/dist-esm/src/legacy/lroEngine/lroEngine.js"}],"node_modules/@azure/core-lro/dist-esm/src/legacy/pollOperation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
},{}],"node_modules/@azure/core-lro/dist-esm/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createHttpPoller: true
};
Object.defineProperty(exports, "createHttpPoller", {
  enumerable: true,
  get: function () {
    return _poller.createHttpPoller;
  }
});
var _poller = require("./http/poller");
var _lroEngine = require("./legacy/lroEngine");
Object.keys(_lroEngine).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _lroEngine[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _lroEngine[key];
    }
  });
});
var _poller2 = require("./legacy/poller");
Object.keys(_poller2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _poller2[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _poller2[key];
    }
  });
});
var _pollOperation = require("./legacy/pollOperation");
Object.keys(_pollOperation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _pollOperation[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _pollOperation[key];
    }
  });
});
},{"./http/poller":"node_modules/@azure/core-lro/dist-esm/src/http/poller.js","./legacy/lroEngine":"node_modules/@azure/core-lro/dist-esm/src/legacy/lroEngine/index.js","./legacy/poller":"node_modules/@azure/core-lro/dist-esm/src/legacy/poller.js","./legacy/pollOperation":"node_modules/@azure/core-lro/dist-esm/src/legacy/pollOperation.js"}],"node_modules/tslib/tslib.es6.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__assign = void 0;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncValues = __asyncValues;
exports.__await = __await;
exports.__awaiter = __awaiter;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__createBinding = __createBinding;
exports.__decorate = __decorate;
exports.__exportStar = __exportStar;
exports.__extends = __extends;
exports.__generator = __generator;
exports.__importDefault = __importDefault;
exports.__importStar = __importStar;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__metadata = __metadata;
exports.__param = __param;
exports.__read = __read;
exports.__rest = __rest;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__values = __values;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  exports.__assign = __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
exports.__assign = __assign;
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
}
;
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
;
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
},{}],"node_modules/@azure/communication-email/dist-esm/src/generated/src/lroImpl.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LroImpl = void 0;
var _tslib = require("tslib");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var LroImpl = exports.LroImpl = /*#__PURE__*/function () {
  function LroImpl(sendOperationFn, args, spec) {
    var requestPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : spec.path;
    var requestMethod = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : spec.httpMethod;
    _classCallCheck(this, LroImpl);
    this.sendOperationFn = sendOperationFn;
    this.args = args;
    this.spec = spec;
    this.requestPath = requestPath;
    this.requestMethod = requestMethod;
  }
  _createClass(LroImpl, [{
    key: "sendInitialRequest",
    value: function () {
      var _sendInitialRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.sendOperationFn(this.args, this.spec));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function sendInitialRequest() {
        return _sendInitialRequest.apply(this, arguments);
      }
      return sendInitialRequest;
    }()
  }, {
    key: "sendPollRequest",
    value: function () {
      var _sendPollRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path) {
        var _a, requestBody, restSpec;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _a = this.spec, requestBody = _a.requestBody, restSpec = (0, _tslib.__rest)(_a, ["requestBody"]);
              return _context2.abrupt("return", this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), {
                path: path,
                httpMethod: "GET"
              })));
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function sendPollRequest(_x) {
        return _sendPollRequest.apply(this, arguments);
      }
      return sendPollRequest;
    }()
  }]);
  return LroImpl;
}();
},{"tslib":"node_modules/tslib/tslib.es6.js"}],"node_modules/@azure/communication-email/dist-esm/src/generated/src/operations/email.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmailImpl = void 0;
var coreClient = _interopRequireWildcard(require("@azure/core-client"));
var Mappers = _interopRequireWildcard(require("../models/mappers"));
var Parameters = _interopRequireWildcard(require("../models/parameters"));
var _coreLro = require("@azure/core-lro");
var _lroImpl = require("../lroImpl");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Email operations. */
var EmailImpl = exports.EmailImpl = /*#__PURE__*/function () {
  /**
   * Initialize a new instance of the class Email class.
   * @param client Reference to the service client
   */
  function EmailImpl(client) {
    _classCallCheck(this, EmailImpl);
    this.client = client;
  }
  /**
   * Gets the status of the email send operation.
   * @param operationId ID of the long running operation (GUID) returned from a previous call to send
   *                    email
   * @param options The options parameters.
   */
  _createClass(EmailImpl, [{
    key: "getSendResult",
    value: function getSendResult(operationId, options) {
      return this.client.sendOperationRequest({
        operationId: operationId,
        options: options
      }, getSendResultOperationSpec);
    }
    /**
     * Queues an email message to be sent to one or more recipients
     * @param message Message payload for sending an email
     * @param options The options parameters.
     */
  }, {
    key: "beginSend",
    value: (function () {
      var _beginSend = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(message, options) {
        var _this = this;
        var directSendOperation, sendOperation, lro, poller;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              directSendOperation = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(args, spec) {
                  return _regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        return _context.abrupt("return", _this.client.sendOperationRequest(args, spec));
                      case 1:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee);
                }));
                return function directSendOperation(_x3, _x4) {
                  return _ref.apply(this, arguments);
                };
              }();
              sendOperation = /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(args, spec) {
                  var _a, currentRawResponse, providedCallback, callback, updatedArgs, flatResponse;
                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        currentRawResponse = undefined;
                        providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                        callback = function callback(rawResponse, flatResponse) {
                          currentRawResponse = rawResponse;
                          providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                        };
                        updatedArgs = Object.assign(Object.assign({}, args), {
                          options: Object.assign(Object.assign({}, args.options), {
                            onResponse: callback
                          })
                        });
                        _context2.next = 6;
                        return directSendOperation(updatedArgs, spec);
                      case 6:
                        flatResponse = _context2.sent;
                        return _context2.abrupt("return", {
                          flatResponse: flatResponse,
                          rawResponse: {
                            statusCode: currentRawResponse.status,
                            body: currentRawResponse.parsedBody,
                            headers: currentRawResponse.headers.toJSON()
                          }
                        });
                      case 8:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2);
                }));
                return function sendOperation(_x5, _x6) {
                  return _ref2.apply(this, arguments);
                };
              }();
              lro = new _lroImpl.LroImpl(sendOperation, {
                message: message,
                options: options
              }, sendOperationSpec);
              poller = new _coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
              });
              _context3.next = 6;
              return poller.poll();
            case 6:
              return _context3.abrupt("return", poller);
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function beginSend(_x, _x2) {
        return _beginSend.apply(this, arguments);
      }
      return beginSend;
    }()
    /**
     * Queues an email message to be sent to one or more recipients
     * @param message Message payload for sending an email
     * @param options The options parameters.
     */
    )
  }, {
    key: "beginSendAndWait",
    value: (function () {
      var _beginSendAndWait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(message, options) {
        var poller;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.beginSend(message, options);
            case 2:
              poller = _context4.sent;
              return _context4.abrupt("return", poller.pollUntilDone());
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function beginSendAndWait(_x7, _x8) {
        return _beginSendAndWait.apply(this, arguments);
      }
      return beginSendAndWait;
    }())
  }]);
  return EmailImpl;
}(); // Operation Specifications
var serializer = coreClient.createSerializer(Mappers, /* isXml */false);
var getSendResultOperationSpec = {
  path: "/emails/operations/{operationId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.EmailSendResult,
      headersMapper: Mappers.EmailGetSendResultHeaders
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper: Mappers.EmailGetSendResultExceptionHeaders
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.operationId],
  headerParameters: [Parameters.accept],
  serializer: serializer
};
var sendOperationSpec = {
  path: "/emails:send",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.EmailSendResult,
      headersMapper: Mappers.EmailSendHeaders
    },
    201: {
      bodyMapper: Mappers.EmailSendResult,
      headersMapper: Mappers.EmailSendHeaders
    },
    202: {
      bodyMapper: Mappers.EmailSendResult,
      headersMapper: Mappers.EmailSendHeaders
    },
    204: {
      bodyMapper: Mappers.EmailSendResult,
      headersMapper: Mappers.EmailSendHeaders
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper: Mappers.EmailSendExceptionHeaders
    }
  },
  requestBody: Parameters.message,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept, Parameters.contentType, Parameters.operationId1, Parameters.clientRequestId],
  mediaType: "json",
  serializer: serializer
};
},{"@azure/core-client":"node_modules/@azure/core-client/dist-esm/src/index.js","../models/mappers":"node_modules/@azure/communication-email/dist-esm/src/generated/src/models/mappers.js","../models/parameters":"node_modules/@azure/communication-email/dist-esm/src/generated/src/models/parameters.js","@azure/core-lro":"node_modules/@azure/core-lro/dist-esm/src/index.js","../lroImpl":"node_modules/@azure/communication-email/dist-esm/src/generated/src/lroImpl.js"}],"node_modules/@azure/communication-email/dist-esm/src/generated/src/operations/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _email = require("./email");
Object.keys(_email).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _email[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _email[key];
    }
  });
});
},{"./email":"node_modules/@azure/communication-email/dist-esm/src/generated/src/operations/email.js"}],"node_modules/@azure/communication-email/dist-esm/src/generated/src/emailRestApiClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmailRestApiClient = void 0;
var coreClient = _interopRequireWildcard(require("@azure/core-client"));
var _operations = require("./operations");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); } /*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
var EmailRestApiClient = exports.EmailRestApiClient = /*#__PURE__*/function (_coreClient$ServiceCl) {
  _inherits(EmailRestApiClient, _coreClient$ServiceCl);
  var _super = _createSuper(EmailRestApiClient);
  /**
   * Initializes a new instance of the EmailRestApiClient class.
   * @param endpoint The communication resource, for example https://my-resource.communication.azure.com
   * @param options The parameter options
   */
  function EmailRestApiClient(endpoint, options) {
    var _this;
    _classCallCheck(this, EmailRestApiClient);
    var _a, _b;
    if (endpoint === undefined) {
      throw new Error("'endpoint' cannot be null");
    }
    // Initializing default values for options
    if (!options) {
      options = {};
    }
    var defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    var packageDetails = "azsdk-js-communication-email/1.0.0";
    var userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? "".concat(options.userAgentOptions.userAgentPrefix, " ").concat(packageDetails) : "".concat(packageDetails);
    var optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), {
      userAgentOptions: {
        userAgentPrefix: userAgentPrefix
      },
      baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{endpoint}"
    });
    _this = _super.call(this, optionsWithDefaults);
    // Parameter assignments
    _this.endpoint = endpoint;
    // Assigning values to Constant parameters
    _this.apiVersion = options.apiVersion || "2023-03-31";
    _this.email = new _operations.EmailImpl(_assertThisInitialized(_this));
    _this.addCustomApiVersionPolicy(options.apiVersion);
    return _this;
  }
  /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
  _createClass(EmailRestApiClient, [{
    key: "addCustomApiVersionPolicy",
    value: function addCustomApiVersionPolicy(apiVersion) {
      if (!apiVersion) {
        return;
      }
      var apiVersionPolicy = {
        name: "CustomApiVersionPolicy",
        sendRequest: function sendRequest(request, next) {
          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var param, newParams;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  param = request.url.split("?");
                  if (param.length > 1) {
                    newParams = param[1].split("&").map(function (item) {
                      if (item.indexOf("api-version") > -1) {
                        return "api-version=" + apiVersion;
                      } else {
                        return item;
                      }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                  }
                  return _context.abrupt("return", next(request));
                case 3:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }))();
        }
      };
      this.pipeline.addPolicy(apiVersionPolicy);
    }
  }]);
  return EmailRestApiClient;
}(coreClient.ServiceClient);
},{"@azure/core-client":"node_modules/@azure/core-client/dist-esm/src/index.js","./operations":"node_modules/@azure/communication-email/dist-esm/src/generated/src/operations/index.js"}],"node_modules/@azure/communication-email/dist-esm/src/logger.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logger = void 0;
var _logger = require("@azure/logger");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/**
 * The \@azure/logger configuration for this package.
 */
var logger = exports.logger = (0, _logger.createClientLogger)("communication-email");
},{"@azure/logger":"node_modules/@azure/logger/dist-esm/src/index.js"}],"node_modules/@azure/communication-email/dist-esm/src/emailClient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmailClient = void 0;
var _coreAuth = require("@azure/core-auth");
var _communicationCommon = require("@azure/communication-common");
var _emailRestApiClient = require("./generated/src/emailRestApiClient");
var _logger = require("./logger");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } // Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Checks whether the type of a value is EmailClientOptions or not.
 *
 * @param options - The value being checked.
 */
var isEmailClientOptions = function isEmailClientOptions(options) {
  return !!options && !(0, _coreAuth.isTokenCredential)(options) && !(0, _communicationCommon.isKeyCredential)(options);
};
/**
 *  The Email service client.
 */
var EmailClient = exports.EmailClient = /*#__PURE__*/function () {
  function EmailClient(connectionStringOrUrl, credentialOrOptions) {
    var maybeOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, EmailClient);
    var _parseClientArguments = (0, _communicationCommon.parseClientArguments)(connectionStringOrUrl, credentialOrOptions),
      url = _parseClientArguments.url,
      credential = _parseClientArguments.credential;
    var options = isEmailClientOptions(credentialOrOptions) ? credentialOrOptions : maybeOptions;
    var internalPipelineOptions = Object.assign(Object.assign({}, options), {
      loggingOptions: {
        logger: _logger.logger.info
      }
    });
    var authPolicy = (0, _communicationCommon.createCommunicationAuthPolicy)(credential);
    this.generatedClient = new _emailRestApiClient.EmailRestApiClient(url, internalPipelineOptions);
    this.generatedClient.pipeline.addPolicy(authPolicy);
  }
  /**
   * Queues an email message to be sent to one or more recipients
   * @param message - Message payload for sending an email
   * @param options - The options parameters.
   */
  _createClass(EmailClient, [{
    key: "beginSend",
    value: function beginSend(message, options) {
      return this.generatedClient.email.beginSend(message, options);
    }
  }]);
  return EmailClient;
}();
},{"@azure/core-auth":"node_modules/@azure/core-auth/dist-esm/src/index.js","@azure/communication-common":"node_modules/@azure/communication-common/dist-esm/src/index.js","./generated/src/emailRestApiClient":"node_modules/@azure/communication-email/dist-esm/src/generated/src/emailRestApiClient.js","./logger":"node_modules/@azure/communication-email/dist-esm/src/logger.js"}],"node_modules/@azure/communication-email/dist-esm/src/generated/src/models/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KnownEmailSendStatus = void 0;
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link EmailSendStatus} that the service accepts. */
var KnownEmailSendStatus;
(function (KnownEmailSendStatus) {
  /** NotStarted */
  KnownEmailSendStatus["NotStarted"] = "NotStarted";
  /** Running */
  KnownEmailSendStatus["Running"] = "Running";
  /** Succeeded */
  KnownEmailSendStatus["Succeeded"] = "Succeeded";
  /** Failed */
  KnownEmailSendStatus["Failed"] = "Failed";
  /** Canceled */
  KnownEmailSendStatus["Canceled"] = "Canceled";
})(KnownEmailSendStatus || (exports.KnownEmailSendStatus = KnownEmailSendStatus = {}));
},{}],"node_modules/@azure/communication-email/dist-esm/src/models.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "KnownEmailSendStatus", {
  enumerable: true,
  get: function () {
    return _models.KnownEmailSendStatus;
  }
});
var _models = require("./generated/src/models");
},{"./generated/src/models":"node_modules/@azure/communication-email/dist-esm/src/generated/src/models/index.js"}],"node_modules/@azure/communication-email/dist-esm/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _emailClient = require("./emailClient");
Object.keys(_emailClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _emailClient[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _emailClient[key];
    }
  });
});
var _models = require("./models");
Object.keys(_models).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _models[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _models[key];
    }
  });
});
},{"./emailClient":"node_modules/@azure/communication-email/dist-esm/src/emailClient.js","./models":"node_modules/@azure/communication-email/dist-esm/src/models.js"}],"app.js":[function(require,module,exports) {
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
document.addEventListener('DOMContentLoaded', function () {
  var connectionString = "endpoint=https://serviciodecorreos.unitedstates.communication.azure.com/;accesskey=qEgllRx/Nv2EhX9rKWx1QvtH09iAGD3isMiPGCZ/reuhM/UHVOxeqOn3HGkBBhLcdB5bsUzc5vuntCEpub4RaA==";
  var senderAddress = "DoNotReply@9852b27d-68d3-4d58-b9d5-bfea1630f998.azurecomm.net";
  var _require = require("@azure/communication-email"),
    EmailClient = _require.EmailClient,
    KnownEmailSendStatus = _require.KnownEmailSendStatus;
  var button = document.getElementById("button");
  button.addEventListener("click", main);
  function main() {
    return _main.apply(this, arguments);
  }
  function _main() {
    _main = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var emailInput, recipientAddress, POLLER_WAIT_TIME, message, client, poller, timeElapsed;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            emailInput = document.getElementById('email');
            recipientAddress = emailInput.value;
            POLLER_WAIT_TIME = 10;
            message = {
              senderAddress: senderAddress,
              recipients: {
                to: [{
                  address: recipientAddress
                }]
              },
              content: {
                subject: "Test email from JS Sample",
                plainText: "This is plaintext body of test email.",
                html: "<html><h1>This is the html body of test email.</h1></html>"
              }
            };
            _context.prev = 4;
            client = new EmailClient(connectionString);
            _context.next = 8;
            return client.beginSend(message);
          case 8:
            poller = _context.sent;
            if (poller.getOperationState().isStarted) {
              _context.next = 11;
              break;
            }
            throw "Poller was not started.";
          case 11:
            timeElapsed = 0;
          case 12:
            if (poller.isDone()) {
              _context.next = 22;
              break;
            }
            poller.poll();
            console.log("Email send polling in progress");
            _context.next = 17;
            return new Promise(function (resolve) {
              return setTimeout(resolve, POLLER_WAIT_TIME * 1000);
            });
          case 17:
            timeElapsed += 10;
            if (!(timeElapsed > 18 * POLLER_WAIT_TIME)) {
              _context.next = 20;
              break;
            }
            throw "Polling timed out.";
          case 20:
            _context.next = 12;
            break;
          case 22:
            if (!(poller.getResult().status === KnownEmailSendStatus.Succeeded)) {
              _context.next = 26;
              break;
            }
            console.log("Successfully sent the email (operation id: ".concat(poller.getResult().id, ")"));
            _context.next = 27;
            break;
          case 26:
            throw poller.getResult().error;
          case 27:
            _context.next = 31;
            break;
          case 29:
            _context.prev = 29;
            _context.t0 = _context["catch"](4);
          case 31:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[4, 29]]);
    }));
    return _main.apply(this, arguments);
  }
});

//main();
},{"@azure/communication-email":"node_modules/@azure/communication-email/dist-esm/src/index.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}
module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "62557" + '/');
  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);
    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);
          if (didAccept) {
            handled = true;
          }
        }
      });

      // Enable HMR for CSS by default.
      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });
      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }
    if (data.type === 'reload') {
      ws.close();
      ws.onclose = function () {
        location.reload();
      };
    }
    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }
    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}
function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);
  if (overlay) {
    overlay.remove();
  }
}
function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;

  // html encode message and stack trace
  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}
function getParents(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return [];
  }
  var parents = [];
  var k, d, dep;
  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];
      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }
  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }
  return parents;
}
function hmrApply(bundle, asset) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}
function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;
  if (!modules) {
    return;
  }
  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }
  if (checkedAssets[id]) {
    return;
  }
  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }
  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}
function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};
  if (cached) {
    cached.hot.data = bundle.hotData;
  }
  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }
  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];
  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });
    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","app.js"], null)
//# sourceMappingURL=/app.c328ef1a.js.map